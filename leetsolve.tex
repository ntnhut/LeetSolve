%% Generated by Sphinx.
\def\sphinxdocclass{book}
\documentclass[letterpaper,11pt,english]{book}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage[paperwidth=7.5in,paperheight=9.25in]{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



    \usepackage{charter}
    \usepackage[defaultsans]{lato}
    \usepackage{inconsolata}
    \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
    \setcounter{tocdepth}{1}
    

\title{The Problem Solver's Guide To Coding}
\date{February, 2024}
\release{}
\author{Nhut Nguyen, Ph. D.}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}
\frontmatter
\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\textit{The Problem Solver's Guide To Coding} 

\textbf{First edition. February, 2024.} 

ISBN 9788797517413 (PDF)

Copyright © 2024 Nhut Nguyen.

All rights reserved.

www.nhutnguyen.com

\newpage
\begin{center}
    \textit{To my dearest mother, Nguyen Thi Kim Sa.}
\end{center}

\sphinxstepscope

\pagestyle{plain}
\chapter*{Preface}
\label{\detokenize{preface:preface}}\label{\detokenize{preface::doc}}
\sphinxAtStartPar
Welcome to \sphinxstyleemphasis{The Problem Solver’s Guide To Coding}, a comprehensive journey to master problem\sphinxhyphen{}solving, data structures, algorithms, and programming techniques using C++. This book results from my experiences, challenges, failures and successes in my programming career.

\sphinxAtStartPar
One of the most critical phases in software developer hiring process is the \sphinxstylestrong{coding interview}, a rigorous process where candidates are tested on their problem\sphinxhyphen{}solving skills and technical proficiency. Companies like FAANG (Facebook, Amazon, Apple, Netflix, and Google) often subject candidates to three to four rounds of interviews, making preparation essential for success.

\sphinxAtStartPar
My journey with coding interviews began during a pivotal career change in the summer of 2021. During this transitional period, I discovered LeetCode, a platform that soon became my daily companion in honing my programming skills. What started as a means to practice new languages (Golang and C\#) quickly evolved into a deep exploration of my strongest language, C++.

\sphinxAtStartPar
One day, I decided to write an article for each challenge and share it on my blog leetsolve.com. Over time, my daily practice transformed into more than 70 challenges, each accompanied by a detailed article encompassing problem statements, various approaches, C++ code implementations, thorough explanations, and complexity analyses.

\sphinxAtStartPar
As I delved into these coding challenges, I realized their potential to empower aspiring programmers, students, and junior developers \sphinxstylestrong{to excel in interviews and master problem\sphinxhyphen{}solving and algorithmic thinking}.


\section*{Overview of the book}
\label{\detokenize{preface:overview-of-the-book}}
\sphinxAtStartPar
\sphinxstyleemphasis{The Problem Solver’s Guide to Coding} presents challenges covering \sphinxstylestrong{fundamental} data structures, algorithms, and mathematical problems. Challenges are grouped in topics, starting with the simplest data structure \sphinxhyphen{} Array. Most are arranged in order of increasing difficulty, but you can pick any chapter or any challenge to start since I write each independently to the other.

\sphinxAtStartPar
Challenges in this book are curated from LeetCode.com, focusing on those that are \sphinxstylestrong{not difficult} but provide valuable learning experiences. You might encounter some simple challenges I go directly to the code without saying much about the idea (intuition) since their solution is straightforward.

\sphinxAtStartPar
I also keep the problems’ original constraints (inputs’ size, limits, etc.) as the code in this book is the ones I submitted on Leetcode.com. It explains why I usually focus on the core algorithm and do not consider/handle corner cases or invalid inputs.

\sphinxAtStartPar
The problems in each chapter comes with a detailed solution, explaining the logic behind the solution and how to implement it in C++, my strongest programming language.

\sphinxAtStartPar
At the end of some problems, I also provide similar problems on leetcode.com for you to solve on your own, as practicing is essential for reinforcing understanding and mastery of the concepts presented in the book. By engaging in problem\sphinxhyphen{}solving exercises, you can apply what you have learned, develop your problem\sphinxhyphen{}solving skills, and gain confidence in your ability to tackle real\sphinxhyphen{}world challenges.

\sphinxAtStartPar
In this book, I focus on readable code rather than optimal one, as most of you are at the beginner level. Some of my solutions might need to be in better runtime or memory. But I keep my code in my style or coding convention, where readability is vital.

\sphinxAtStartPar
Moreover, my weekly sharing of articles with various developer communities has refined the content and established a connection with a diverse group of programming enthusiasts.


\section*{Who is this book for?}
\label{\detokenize{preface:who-is-this-book-for}}
\sphinxAtStartPar
This book is tailored to benefit a wide audience, from \sphinxstylestrong{students} beginning their programming journey to \sphinxstylestrong{experienced developers} looking to enhance their skills. Regardless of your experience level, whether you’re \sphinxstylestrong{preparing for coding interviews} or simply seeking to \sphinxstylestrong{improve your problem\sphinxhyphen{}solving abilities}, this book is designed to meet your needs.

\sphinxAtStartPar
As a minimum requirement, you are supposed to have some basic background in C++ programming language, data structures and algorithms like a second\sphinxhyphen{}year undergraduate in Computer Science.

\sphinxAtStartPar
What sets this book apart is its focus on practicality. The challenges presented here are not just exercises; they mirror \sphinxstylestrong{real coding interviews} from top companies like FAANG.

\sphinxAtStartPar
As you work through the coding challenges in this book, you’ll learn new skills, improve your problem\sphinxhyphen{}solving abilities, and develop your confidence as a programmer.


\section*{Acknowledgement}
\label{\detokenize{preface:acknowledgement}}
\sphinxAtStartPar
I am deeply grateful to my invaluable previewers, especially Alexander Volkodav, Phung Phu Tai, Le Nhat Tung, Tran Anh Tuan A, Bui Nguyen Cong Duy, Cao Minh Thinh, Nguyen Trung Tuan, Nguyen Tuan Hung, Nguyen Hoang Nhat Minh, Nhan Nguyen, Phan Dinh Thai and Nguyen Quang Trung, whose dedication and insights have shaped this book into its final form. Your contributions and unwavering support are truly appreciated.

\sphinxAtStartPar
I would like to express my heartfelt gratitude to Ninh Pham, Hoang Thanh Lam, Dinh Thai Minh Tam and Tran Anh Tuan B, whose invaluable feedback contributed to the refinement of this book in future versions. Your insightful comments and constructive criticism have played a pivotal role in shaping its content and enhancing its quality. Thank you for your dedication and generosity in sharing your expertise. Your input will undoubtedly pave the way for future improvements and iterations of this work.

\newpage

\sphinxAtStartPar
Students and developers! By immersing yourself in the challenges and insights shared in this book, you will not only prepare for coding interviews but also cultivate a mindset beyond the scope of a job interview. You will become a problem solver, a strategic thinker, and a proficient C++ programmer.

\sphinxAtStartPar
As you embark on this journey, remember that every challenge you encounter is an opportunity for growth. Embrace the complexities, learn from each solution, and let the knowledge you gain propel you to new heights in your programming career.

\sphinxAtStartPar
Thank you for joining me on this expedition.

\sphinxAtStartPar
\sphinxstylestrong{May your code be elegant, your algorithms efficient, and your programming journey genuinely transformative.}
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{Happy coding!}
\end{quote}

\sphinxAtStartPar
Copenhagen, February 2024.

\sphinxAtStartPar
Nhut Nguyen, Ph.D.

\sphinxstepscope


\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index_book1::doc}}


\sphinxstepscope

\mainmatter


\chapter{Introduction}
\label{\detokenize{intro:introduction}}\label{\detokenize{intro::doc}}

\section{Why LeetCode?}
\label{\detokenize{intro:why-leetcode}}\index{LeetCode@\spxentry{LeetCode}}
\sphinxAtStartPar
Coding challenges are a great way to practice problem\sphinxhyphen{}solving, algorithm development, and logical thinking. They showcase your creativity and innovation while improving your coding techniques. This book offers diverse coding challenges to help you develop your skills.

\sphinxAtStartPar
\index{Coding challenges@\spxentry{Coding challenges}}Coding challenges could be programming puzzles or mathematical problems that require coding solutions. Each challenge requires different coding skills and is designed to challenge and develop a particular set of skills.

\sphinxAtStartPar
The coding challenges in this book are picked from \sphinxhref{https://leetcode.com}{LeetCode}. It is a popular online platform for programmers and software engineers that provides many coding challenges and problems. The website was launched in 2015 and has since grown to become one of the go\sphinxhyphen{}to resources for coding practice, technical interview preparation, and skills enhancement.

\sphinxAtStartPar
LeetCode offers diverse coding challenges, ranging from easy to hard, covering a wide range of topics such as algorithms, data structures, databases, system design, and more. The problems are created by industry experts and are designed to simulate real\sphinxhyphen{}world scenarios, allowing you to gain practical experience in problem\sphinxhyphen{}solving.

\sphinxAtStartPar
One feature that makes LeetCode stand out is its extensive discussion forum, where you can interact, share your solutions, and learn from one another. This fosters community and collaboration, as you can receive feedback on their solutions and ask for clarification on difficult problems.

\sphinxAtStartPar
LeetCode also provides premium services like mock interviews with real\sphinxhyphen{}world companies, career coaching, and job postings. These premium services are designed to help you prepare for technical interviews, sharpen your skills, and advance your careers.

\sphinxAtStartPar
LeetCode has become a popular resource for technical interview preparation, as many companies use similar problems to screen and evaluate potential candidates. The platform has helped many users to secure job offers from top companies in the technology industry, including Google, Microsoft, and Facebook.

\sphinxAtStartPar
In summary, LeetCode is a valuable resource for programmers and software engineers looking to improve their coding skills, prepare for technical interviews, and advance their careers. Its extensive collection of coding challenges, community discussion forums, and premium services make it an all\sphinxhyphen{}in\sphinxhyphen{}one platform for coding practice and skills enhancement.


\section{A brief about algorithm complexity}
\label{\detokenize{intro:a-brief-about-algorithm-complexity}}\index{algorithm complexity@\spxentry{algorithm complexity}}
\sphinxAtStartPar
\sphinxstyleemphasis{Algorithm complexity}, also known as \sphinxstyleemphasis{runtime complexity}, is a measure of how the running time of an algorithm increases as the input size grows. It is an essential concept in computer science, as it helps programmers evaluate and optimize their algorithms’ performance.

\sphinxAtStartPar
The complexity of an algorithm is usually measured in terms of its \sphinxstyleemphasis{Big O notation}, which describes the upper bound of the algorithm’s running time as a function of the input size. For example, an algorithm with a time complexity of \sphinxcode{\sphinxupquote{O(n)}} will have a running time proportional to the input size. In contrast, an algorithm with a time complexity of \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}} will have a running time proportional to the square of the input size.

\sphinxAtStartPar
Algorithm complexity is important because it helps programmers determine their algorithms’ efficiency and scalability. In general, algorithms with lower complexity are more efficient, as they require less time and resources to process larger inputs. By analyzing the time complexity of an algorithm, programmers can identify potential performance bottlenecks and optimize their code accordingly.

\sphinxAtStartPar
In addition to time complexity, algorithms may also have space complexity, which measures the memory required to execute the algorithm. Space complexity is also measured in Big O notation and is important for optimizing the memory usage of an algorithm.

\sphinxAtStartPar
\sphinxincludegraphics{{complexity_graph}.png}

\sphinxAtStartPar
While it is important to optimize the performance of algorithms, it is also important to balance this with readability and maintainability. A highly optimized algorithm may be difficult to understand and maintain, which can lead to problems in the long run. Therefore, it is important to balance performance and readability when designing and implementing algorithms.

\sphinxAtStartPar
In summary, algorithm complexity is an essential concept in computer science that helps programmers evaluate and optimize their algorithms’ performance. By analyzing an algorithm’s time and space complexity, programmers can identify potential performance bottlenecks and optimize their code to improve efficiency and scalability.


\section{Why readable code?}
\label{\detokenize{intro:why-readable-code}}\index{readable code@\spxentry{readable code}}
\sphinxAtStartPar
Readable code is code that is easy to understand, maintain, and modify. It is an essential aspect of programming, as it ensures that code is accessible to other programmers and helps to prevent errors and bugs. Readable code is important for several reasons.

\sphinxAtStartPar
Firstly, readable code makes it easier for other programmers to understand and modify it. This is particularly important in collaborative projects where multiple programmers work on the same codebase. If the code is not readable, it can lead to confusion and errors, making it difficult for others to work on it.

\sphinxAtStartPar
Secondly, readable code helps to prevent bugs and errors. When code is easy to understand, it is easier to identify and fix potential issues before they become problems. This is important for ensuring the code is reliable and performs as expected.

\sphinxAtStartPar
Thirdly, readable code can improve the overall quality of the codebase. When code is easy to understand, it is easier to identify areas for improvement and make changes to improve the code. This can help improve the codebase’s efficiency and maintainability, leading to a better overall product.

\sphinxAtStartPar
Finally, readable code can save time and money. When code is easy to understand, it is easier to maintain and modify. This can help reduce the time and resources required to make changes to the codebase, leading to cost savings in the long run.

\sphinxAtStartPar
In conclusion, readable code is an essential aspect of programming that ensures that code is accessible, error\sphinxhyphen{}free, and efficient. By focusing on readability when designing and implementing code, programmers can improve the quality and reliability of their code, leading to a better overall product.
\newpage


\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{I hope this book is an enjoyable and educational experience that will challenge and inspire you. Whether you want to enhance your skills, prepare for a technical interview, or just have fun, this book has something for you. So, get ready to put your coding skills to the test and embark on a challenging and rewarding journey through the world of coding challenges!}
\end{quote}

\sphinxstepscope


\chapter{Array}
\label{\detokenize{Array/index:array}}\label{\detokenize{Array/index::doc}}
\sphinxAtStartPar
This chapter will explore the basics of \sphinxstylestrong{arrays} \sphinxhyphen{} collections of elements organized in a sequence. While they may seem simple, you can learn many concepts and techniques from arrays to improve your coding skills. We’ll cover topics like \sphinxstylestrong{indexing}, \sphinxstylestrong{iteration}, and \sphinxstylestrong{manipulation}, as well as dynamic arrays (\sphinxcode{\sphinxupquote{std::vector}}) and time/space complexity.

\sphinxAtStartPar
Along the way, we’ll tackle challenging problems like \sphinxstylestrong{searching}, \sphinxstylestrong{sorting}, and \sphinxstylestrong{subarray} problems, using a structured approach to break down complex tasks into manageable steps.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Fundamentals of Arrays:} Gain a solid understanding of arrays, their properties, and how to access and manipulate elements efficiently.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Array Operations:} Learn essential array operations like insertion, deletion, and updating elements, and understand their trade\sphinxhyphen{}offs.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dynamic Arrays:} Explore dynamic arrays, their advantages over static arrays, and the mechanics of resizing.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time and Space Complexity:} Grasp the importance of analyzing the efficiency of algorithms and how to evaluate the time and space complexity of array\sphinxhyphen{}related operations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Common Array Algorithms:} Discover classic algorithms such as searching, sorting, and various techniques for tackling subarray problems.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving Strategies:} Develop systematic strategies to approach array\sphinxhyphen{}related challenges, including how to break down problems, devise algorithms, and validate solutions.

\end{enumerate}

\sphinxstepscope


\section{Transpose Matrix}
\label{\detokenize{Array/867_Transpose_Matrix:transpose-matrix}}\label{\detokenize{Array/867_Transpose_Matrix::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/867_Transpose_Matrix:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/transpose\sphinxhyphen{}matrix/
%
\end{footnote}You are given a 2D integer array \sphinxcode{\sphinxupquote{matrix}}, and your objective is to find the transpose of the given matrix.

\sphinxAtStartPar
The transpose of a matrix involves flipping the matrix over its main diagonal, effectively swapping its row and column indices.
\begin{equation*}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
1 & 4 & 7 \\
2 & 5 & 8 \\
3 & 6 & 9
\end{bmatrix}
\end{equation*}

\subsubsection{Example 1}
\label{\detokenize{Array/867_Transpose_Matrix:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[1,4,7],[2,5,8],[3,6,9]]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/867_Transpose_Matrix:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[1,2,3],[4,5,6]]
Output: [[1,4],[2,5],[3,6]]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/867_Transpose_Matrix:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{m == matrix.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == matrix{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m, n \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m * n \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}9 \textless{}= matrix{[}i{]}{[}j{]} \textless{}= 10\textasciicircum{}9}}.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Array/867_Transpose_Matrix:solution}}

\subsubsection{Code}
\label{\detokenize{Array/867_Transpose_Matrix:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{transpose}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// declare the transposed matrix mt of desired size, i.e.}
\PYG{+w}{    }\PYG{c+c1}{// mt\PYGZsq{}s number of rows = matrix\PYGZsq{}s number of columns}
\PYG{+w}{    }\PYG{c+c1}{// mt\PYGZsq{}s number of columns = matrix\PYGZsq{}s number of rows}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{mt}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{                           }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{mt}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{mt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{mt}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{mt}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{transpose}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{transpose}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[[1,4,7,][2,5,8,][3,6,9,]]
[[1,4,][2,5,][3,6,]]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Array/867_Transpose_Matrix:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m*n)}}, where \sphinxcode{\sphinxupquote{m = matrix.length}} and \sphinxcode{\sphinxupquote{n = matrix{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Implementation note}
\label{\detokenize{Array/867_Transpose_Matrix:implementation-note}}
\sphinxAtStartPar
Note that the matrix might not be square, you cannot just swap the elements using for example the function \sphinxcode{\sphinxupquote{std::swap}}.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Valid Mountain Array}
\label{\detokenize{Array/941_Valid_Mountain_Array:valid-mountain-array}}\label{\detokenize{Array/941_Valid_Mountain_Array::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/941_Valid_Mountain_Array:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/valid\sphinxhyphen{}mountain\sphinxhyphen{}array/
%
\end{footnote}You are given an array of integers \sphinxcode{\sphinxupquote{arr}}, and your task is to determine whether it is a valid \sphinxstyleemphasis{mountain array}.

\sphinxAtStartPar
A valid \sphinxstyleemphasis{mountain array} must meet the following conditions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The length of \sphinxcode{\sphinxupquote{arr}} should be greater than or equal to \sphinxcode{\sphinxupquote{3}}.

\item {} 
\sphinxAtStartPar
There should exist an index \sphinxcode{\sphinxupquote{i}} such that \sphinxcode{\sphinxupquote{0 \textless{} i \textless{} arr.length \sphinxhyphen{} 1}}, and the elements up to \sphinxcode{\sphinxupquote{i}} (\sphinxcode{\sphinxupquote{arr{[}0{]}}} to \sphinxcode{\sphinxupquote{arr{[}i{]}}}) should be in strictly ascending order, while the elements starting from \sphinxcode{\sphinxupquote{i}} (\sphinxcode{\sphinxupquote{arr{[}i{]}}} to \sphinxcode{\sphinxupquote{arr{[}arr.length\sphinxhyphen{}1{]}}}) should be in strictly descending order.

\end{enumerate}

\sphinxAtStartPar
\sphinxincludegraphics{{941_hint_valid_mountain_array}.png}


\subsubsection{Example 1}
\label{\detokenize{Array/941_Valid_Mountain_Array:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: arr = [2,1]
Output: false
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/941_Valid_Mountain_Array:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: arr = [3,5,5]
Output: false
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Array/941_Valid_Mountain_Array:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: arr = [0,3,2,1]
Output: true
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/941_Valid_Mountain_Array:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= arr.length \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= arr{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Array/941_Valid_Mountain_Array:solution}}
\sphinxAtStartPar
Following the conditions, we have the following implementation.


\subsubsection{Code}
\label{\detokenize{Array/941_Valid_Mountain_Array:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{validMountainArray}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// find the top of the mountain}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// condition: 0 \PYGZlt{} i \PYGZlt{} N \PYGZhy{} 1}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// going from the top to the bottom}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{validMountainArray}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{arr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{   }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{validMountainArray}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{arr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{   }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{validMountainArray}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{arr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{validMountainArray}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
0
0
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution iteratively checks for the two slopes of a mountain array, ensuring that the elements to the left are strictly increasing and the elements to the right are strictly decreasing. If both conditions are met, the function returns \sphinxcode{\sphinxupquote{true}}, indicating that the input array is a valid mountain array; otherwise, it returns \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Complexity}
\label{\detokenize{Array/941_Valid_Mountain_Array:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = arr.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Coding best practices}
\label{\detokenize{Array/941_Valid_Mountain_Array:coding-best-practices}}
\sphinxAtStartPar
Breaking down the problem into distinct stages, like finding the peak of the mountain and then traversing down from there, can simplify the logic and improve code readability. This approach facilitates a clear understanding of the algorithm’s progression and helps in handling complex conditions effectively.


\subsection{Exercise}
\label{\detokenize{Array/941_Valid_Mountain_Array:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/beautiful-towers-i/}{Beautiful Towers I}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Shift 2D Grid}
\label{\detokenize{Array/1260_Shift_2D_Grid:shift-2d-grid}}\label{\detokenize{Array/1260_Shift_2D_Grid::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/1260_Shift_2D_Grid:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/shift\sphinxhyphen{}2d\sphinxhyphen{}grid/
%
\end{footnote}You are given a 2D \sphinxcode{\sphinxupquote{grid}} with dimension \sphinxcode{\sphinxupquote{mxn}} and an integer \sphinxcode{\sphinxupquote{k}}. Your task is to perform \sphinxcode{\sphinxupquote{k}} shift operations on the grid.

\sphinxAtStartPar
In each shift operation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The element at \sphinxcode{\sphinxupquote{grid{[}i{]}{[}j{]}}} moves to \sphinxcode{\sphinxupquote{grid{[}i{]}{[}j+1{]}}}.

\item {} 
\sphinxAtStartPar
The element at \sphinxcode{\sphinxupquote{grid{[}i{]}{[}n\sphinxhyphen{}1{]}}} moves to \sphinxcode{\sphinxupquote{grid{[}i+1{]}{[}0{]}}}.

\item {} 
\sphinxAtStartPar
The element at \sphinxcode{\sphinxupquote{grid{[}m\sphinxhyphen{}1{]}{[}n\sphinxhyphen{}1{]}}} moves to \sphinxcode{\sphinxupquote{grid{[}0{]}{[}0{]}}}.

\end{itemize}

\sphinxAtStartPar
After performing \sphinxcode{\sphinxupquote{k}} shift operations, return the updated 2D grid.


\subsubsection{Example 1}
\label{\detokenize{Array/1260_Shift_2D_Grid:example-1}}\begin{equation*}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
9 & 1 & 2 \\
3 & 4 & 5 \\
6 & 7 & 8
\end{bmatrix}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1
Output: [[9,1,2],[3,4,5],[6,7,8]]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/1260_Shift_2D_Grid:example-2}}\begin{equation*}
\begin{bmatrix}
3 & 8 & 1 & 9 \\
19 & 7 & 2 & 5 \\
4 & 6 & 11 & 10 \\
12 & 0 & 21 & 13
\end{bmatrix}
\rightarrow
\begin{bmatrix}
13 & 3 & 8 & 1 \\
9 & 19 & 7 & 2 \\
5 & 4 & 6 & 11 \\
10 & 12 & 0 & 21
\end{bmatrix}
\rightarrow
\begin{bmatrix}
21 & 13 & 3 & 8 \\
1 & 9 & 19 & 7 \\
2 & 5 & 4 & 6  \\
11 & 10 & 12 & 0 
\end{bmatrix} \\
\end{equation*}\begin{equation*}
\rightarrow
\begin{bmatrix}
0 & 21 & 13 & 3 \\
8 & 1 & 9 & 19 \\
7 & 2 & 5 & 4 \\
6 & 11 & 10 & 12
\end{bmatrix}
\rightarrow
\begin{bmatrix}
12 & 0 & 21 & 13 \\
3 & 8 & 1 & 9 \\
19 & 7 & 2 & 5 \\
4 & 6 & 11 & 10
\end{bmatrix}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4
Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Array/1260_Shift_2D_Grid:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9
Output: [[1,2,3],[4,5,6],[7,8,9]]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/1260_Shift_2D_Grid:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= grid.length \textless{}= 50}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= grid{[}i{]}.length \textless{}= 50}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}1000 \textless{}= grid{[}i{]}{[}j{]} \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= k \textless{}= 100}}.

\end{itemize}


\subsection{Solution: Convert a 2D array into a 1D one}
\label{\detokenize{Array/1260_Shift_2D_Grid:solution-convert-a-2d-array-into-a-1d-one}}
\sphinxAtStartPar
You can convert the 2D \sphinxcode{\sphinxupquote{grid}} into a 1D vector \sphinxcode{\sphinxupquote{v}} to perform the shifting easier. One way of doing this is concatenating the rows of the matrix.
\begin{itemize}
\item {} 
\sphinxAtStartPar
If you shift the grid \sphinxcode{\sphinxupquote{k = i*N}} times where \sphinxcode{\sphinxupquote{N = v.size()}} and \sphinxcode{\sphinxupquote{i}} is any non\sphinxhyphen{}negative integer, you go back to the original grid; i.e. you did not shift it.

\item {} 
\sphinxAtStartPar
If you shift the grid \sphinxcode{\sphinxupquote{k}} times with \sphinxcode{\sphinxupquote{0 \textless{} k \textless{} N}}, the first element of the result starts from \sphinxcode{\sphinxupquote{v{[}N\sphinxhyphen{}k{]}}}.

\item {} 
\sphinxAtStartPar
In general, the first element of the result starts from \sphinxcode{\sphinxupquote{v{[}N \sphinxhyphen{} k\%N{]}}}.

\end{itemize}


\subsubsection{Example 1}
\label{\detokenize{Array/1260_Shift_2D_Grid:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{grid = {[}{[}1,2,3{]},{[}4,5,6{]},{[}7,8,9{]}{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
It can be converted into a 1D vector \sphinxcode{\sphinxupquote{v = {[}1,2,3,4,5,6,7,8,9{]}}} of size \sphinxcode{\sphinxupquote{m*n = 9}}.

\item {} 
\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{k = 1}} the shifted \sphinxcode{\sphinxupquote{grid}} now starts from \sphinxcode{\sphinxupquote{v{[}9\sphinxhyphen{}1{]} = 9}}.

\item {} 
\sphinxAtStartPar
The final result is \sphinxcode{\sphinxupquote{grid = {[}{[}9,1,2{]}{[}3,4,5{]}{[}6,7,8{]}{]}}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Array/1260_Shift_2D_Grid:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{shiftGrid}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// store the 2D grid values into a 1D vector v}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{v}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// perform the shifting}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{;}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{c+c1}{// number of rows}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// number of columns}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{p}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{c+c1}{// reconstruct the grid}
\PYG{+w}{            }\PYG{n}{grid}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{[}\PYG{n}{p}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{grid}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{shiftGrid}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{grid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{19}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{21}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{shiftGrid}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{grid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{shiftGrid}\PYG{p}{(}\PYG{n}{grid}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[[9,1,2,][3,4,5,][6,7,8,]]
[[12,0,21,13,][3,8,1,9,][19,7,2,5,][4,6,11,10,]]
[[1,2,3,][4,5,6,][7,8,9,]]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution flattens the 2D \sphinxcode{\sphinxupquote{grid}} into a 1D vector \sphinxcode{\sphinxupquote{v}}, representing the grid’s elements in a linear sequence. Then, by calculating the new position for each element after the shift operation, it reconstructs the grid by placing the elements back into their respective positions based on the calculated indices. This approach avoids unnecessary copying or shifting of elements within the grid, optimizing both memory and time complexity.


\subsubsection{Complexity}
\label{\detokenize{Array/1260_Shift_2D_Grid:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m*n)}} (the nested \sphinxcode{\sphinxupquote{for}} loops), where \sphinxcode{\sphinxupquote{m = grid.length}} and \sphinxcode{\sphinxupquote{n = grid{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(m*n)}} (the vector \sphinxcode{\sphinxupquote{v}}).

\end{itemize}


\subsection{Key takeaway}
\label{\detokenize{Array/1260_Shift_2D_Grid:key-takeaway}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
To convert a 2D matrix into a 1D vector, you can use the \sphinxcode{\sphinxupquote{std::vector}}’s function \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/insert}{\sphinxcode{\sphinxupquote{insert()}}}.

\item {} 
\sphinxAtStartPar
The modulo operator \sphinxcode{\sphinxupquote{\%}} is usually used to ensure the index is inbound.

\end{enumerate}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Find All Numbers Disappeared in an Array}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:find-all-numbers-disappeared-in-an-array}}\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/find\sphinxhyphen{}all\sphinxhyphen{}numbers\sphinxhyphen{}disappeared\sphinxhyphen{}in\sphinxhyphen{}an\sphinxhyphen{}array/
%
\end{footnote}You are given an array \sphinxcode{\sphinxupquote{nums}} of \sphinxcode{\sphinxupquote{n}} integers, where each integer \sphinxcode{\sphinxupquote{nums{[}i{]}}} falls within the range \sphinxcode{\sphinxupquote{{[}1, n{]}}}. Your task is to find and return an array containing all the integers in the range \sphinxcode{\sphinxupquote{{[}1, n{]}}} that are not present in the given array \sphinxcode{\sphinxupquote{nums}}.


\subsubsection{Example 1}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,1]
Output: [2]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == nums.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums{[}i{]} \textless{}= n}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:follow-up}}
\sphinxAtStartPar
Can you solve the problem without using additional memory and achieve a linear runtime complexity? You can assume that the list you return does not count as extra space.


\subsection{Solution 1: Marking the appearances by \sphinxstyleliteralintitle{\sphinxupquote{bool}}}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:solution-1-marking-the-appearances-by-bool}}
\sphinxAtStartPar
You can use a vector of \sphinxcode{\sphinxupquote{bool}} to mark which value appeared in the array.


\subsubsection{Code}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{        }

\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{exist}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{        }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{exist}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{exist}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[5,6,]
[2,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This code declares a vector named \sphinxcode{\sphinxupquote{exist}} of type \sphinxcode{\sphinxupquote{bool}} and initializes all of its values to \sphinxcode{\sphinxupquote{false}}. Its size is declared as \sphinxcode{\sphinxupquote{n + 1}} where \sphinxcode{\sphinxupquote{n = nums.size()}} so it can mark the values ranged from \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
Then it performs the marking of all \sphinxcode{\sphinxupquote{nums}}’s elements to \sphinxcode{\sphinxupquote{true}}. The ones that are \sphinxcode{\sphinxupquote{false}} will belong to the result.


\subsubsection{Complexity}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: much less than \sphinxcode{\sphinxupquote{O(n)}}. \sphinxhref{https://en.cppreference.com/w/cpp/container/vector\_bool}{\sphinxcode{\sphinxupquote{vector\textless{}bool\textgreater{}}}} is optimized for space efficiency; it stores single bits.

\end{itemize}


\subsection{Solution 2: Marking the appearances by sign}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:solution-2-marking-the-appearances-by-sign}}
\sphinxAtStartPar
You could use the indices of the array \sphinxcode{\sphinxupquote{nums}} to mark the appearances of its elements because they are just a shift (\sphinxcode{\sphinxupquote{{[}1, n{]}}} vs. \sphinxcode{\sphinxupquote{{[}0, n\sphinxhyphen{}1{]}}}).

\sphinxAtStartPar
One way of marking the appearance of a value \sphinxcode{\sphinxupquote{j}} (\sphinxcode{\sphinxupquote{1 \textless{}= j \textless{}= n}}) is making the element \sphinxcode{\sphinxupquote{nums{[}j\sphinxhyphen{}1{]}}} to be negative. Then the indices \sphinxcode{\sphinxupquote{j}}’s whose \sphinxcode{\sphinxupquote{nums{[}j\sphinxhyphen{}1{]}}} are still positive are the ones that do not appear in \sphinxcode{\sphinxupquote{nums}}.


\subsubsection{Example 1}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:id2}}
\sphinxAtStartPar
With \sphinxcode{\sphinxupquote{nums = {[}4,3,2,7,8,2,3,1{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
To indicate \sphinxcode{\sphinxupquote{4}} is present, make \sphinxcode{\sphinxupquote{nums{[}4\sphinxhyphen{}1{]}}} is negative, i.e. changing \sphinxcode{\sphinxupquote{nums{[}4\sphinxhyphen{}1{]} = nums{[}3{]}}} to \sphinxcode{\sphinxupquote{\sphinxhyphen{}7}}.

\item {} 
\sphinxAtStartPar
To indicate \sphinxcode{\sphinxupquote{3}} is present, make \sphinxcode{\sphinxupquote{nums{[}3\sphinxhyphen{}1{]}}} is negative, i.e. changing \sphinxcode{\sphinxupquote{nums{[}3\sphinxhyphen{}1{]} = nums{[}2{]}}} to \sphinxcode{\sphinxupquote{\sphinxhyphen{}2}}.

\item {} 
\sphinxAtStartPar
And so on.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums}} becomes \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}4,\sphinxhyphen{}3,\sphinxhyphen{}2,\sphinxhyphen{}7,8,2,\sphinxhyphen{}3,\sphinxhyphen{}1{]}}}.

\item {} 
\sphinxAtStartPar
The positive values \sphinxcode{\sphinxupquote{8}} corresponds to \sphinxcode{\sphinxupquote{nums{[}4{]} = nums{[}5\sphinxhyphen{}1{]}}}, indicates \sphinxcode{\sphinxupquote{5}} was not present in \sphinxcode{\sphinxupquote{nums}}.

\item {} 
\sphinxAtStartPar
Similarly, the positive values \sphinxcode{\sphinxupquote{2}} corresponds to \sphinxcode{\sphinxupquote{nums{[}5{]} = nums{[}6\sphinxhyphen{}1{]}}}, indicates \sphinxcode{\sphinxupquote{6}} was not present in \sphinxcode{\sphinxupquote{nums}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// make sure j is positive since nums[i] might be }
\PYG{+w}{        }\PYG{c+c1}{// changed to be negative in previous steps}
\PYG{+w}{        }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{abs}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// Mark nums[j \PYGZhy{} 1] as negative to indicate its presence       }
\PYG{+w}{        }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{abs}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// If nums[j \PYGZhy{} 1] is positive, it means j is missing        }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findDisappearedNumbers}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[5,6,]
[2,]
\end{sphinxVerbatim}

\sphinxAtStartPar
The key to this solution is that it utilizes the array to mark the presence of numbers. Negating the value at the index corresponding to each number found in the input array effectively marks that number as present. Then, by iterating through the modified array, it identifies the missing numbers by checking which indices still hold positive values.


\subsubsection{Complexity}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}} (the returned list does not count as extra space).

\end{itemize}


\subsection{Readable code}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:readable-code}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Solution 2 helps to avoid allocating extra memory but it is not straightforward to understand.

\item {} 
\sphinxAtStartPar
Though Solution 1 requires some extra space, that memory is not much since \sphinxcode{\sphinxupquote{std::vector\textless{}bool\textgreater{}}} is optimized for space efficiency. Moreover, it is easier to understand than Solution 2.

\end{itemize}


\subsection{Exercise}
\label{\detokenize{Array/448_Find_All_Numbers_Disappeared_in_an_Array:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/find-all-duplicates-in-an-array}{Find All Duplicates in an Array}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Rotate Image}
\label{\detokenize{Array/48_Rotate_Image:rotate-image}}\label{\detokenize{Array/48_Rotate_Image::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/48_Rotate_Image:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/rotate\sphinxhyphen{}image/
%
\end{footnote}Given an \sphinxcode{\sphinxupquote{n x n}} 2D matrix representing an image, your task is to rotate the image by 90 degrees clockwise. The rotation must be performed in\sphinxhyphen{}place, meaning you need to modify the original input 2D matrix directly. It is not allowed to create another 2D matrix for the rotation.


\subsubsection{Example 1}
\label{\detokenize{Array/48_Rotate_Image:example-1}}\begin{equation*}
\begin{bmatrix}
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
7 & 4 & 1 \\
8 & 5 & 2 \\
9 & 6 & 3
\end{bmatrix}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/48_Rotate_Image:example-2}}\begin{equation*}
\begin{bmatrix}
5 & 1 & 9 & 11 \\
2 & 4 & 8 & 10 \\
13 & 3 & 6 & 7 \\
15 & 14 & 12 & 16
\end{bmatrix}
\longrightarrow
\begin{bmatrix}
15 & 13 & 2 & 5 \\
14 & 3 & 4 & 1 \\
12 & 6 & 8 & 9 \\
16 & 7 & 10 & 11
\end{bmatrix}
\end{equation*}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/48_Rotate_Image:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == matrix.length == matrix{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 20}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}1000 \textless{}= matrix{[}i{]}{[}j{]} \textless{}= 1000}}.

\end{itemize}


\subsection{Solution: The math behind}
\label{\detokenize{Array/48_Rotate_Image:solution-the-math-behind}}
\sphinxAtStartPar
For any square matrix, the rotation 90 degrees clockwise can be performed in two steps:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Transpose the matrix.

\item {} 
\sphinxAtStartPar
Mirror the matrix vertically.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{Array/48_Rotate_Image:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{rotate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// transpose}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{swap}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// vertical mirror}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{swap}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printMatrix}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{row}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{],}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printMatrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rotate}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printMatrix}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[[7,4,1,],[8,5,2,],[9,6,3,],]
[[15,13,2,5,],[14,3,4,1,],[12,6,8,9,],[16,7,10,11,],]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Array/48_Rotate_Image:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n = matrix.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Implementation tips}
\label{\detokenize{Array/48_Rotate_Image:implementation-tips}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The function \index{std::swap@\spxentry{std::swap}}std::swap%
\begin{footnote}[2]\sphinxAtStartFootnote
https://en.cppreference.com/w/cpp/algorithm/swap
%
\end{footnote} can be used to exchange two values.

\item {} 
\sphinxAtStartPar
When doing the transpose or mirroring, you could visit over only one\sphinxhyphen{}half of the matrix.

\end{enumerate}


\subsection{Exercise}
\label{\detokenize{Array/48_Rotate_Image:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/determine-whether-matrix-can-be-obtained-by-rotation/}{Determine Whether Matrix Can Be Obtained By Rotation}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Spiral Matrix II}
\label{\detokenize{Array/59_Spiral_Matrix_II:spiral-matrix-ii}}\label{\detokenize{Array/59_Spiral_Matrix_II::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/59_Spiral_Matrix_II:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/spiral\sphinxhyphen{}matrix\sphinxhyphen{}ii/
%
\end{footnote}Given a positive integer \sphinxcode{\sphinxupquote{n}}, generate an \sphinxcode{\sphinxupquote{n x n}} matrix filled with elements from \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{n\textasciicircum{}2}} in spiral order.


\subsubsection{Example 1}
\label{\detokenize{Array/59_Spiral_Matrix_II:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{59_spiraln}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/59_Spiral_Matrix_II:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 1
Output: [[1]]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/59_Spiral_Matrix_II:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 20}}.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Array/59_Spiral_Matrix_II:solution}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Starting from the top left of the matrix.

\item {} 
\sphinxAtStartPar
Going along the spiral direction.

\item {} 
\sphinxAtStartPar
Put the value to the matrix, starting from \sphinxcode{\sphinxupquote{1}}.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{Array/59_Spiral_Matrix_II:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{enum}\PYG{+w}{ }\PYG{n+nc}{Direction}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{n}{RIGHT}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{DOWN}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{LEFT}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{UP}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{generateMatrix}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{bottom}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{top}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{col}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{Direction}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RIGHT}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{top}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{bottom}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{right}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{[}\PYG{n}{col}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{switch}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{d}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{case}\PYG{+w}{ }\PYG{n+no}{RIGHT}\PYG{p}{:}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{col}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{right}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{top}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{DOWN}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{row}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{col}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{case}\PYG{+w}{ }\PYG{n+no}{DOWN}\PYG{p}{:}\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{row}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{bottom}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{right}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{LEFT}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{col}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{row}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{case}\PYG{+w}{ }\PYG{n+no}{LEFT}\PYG{p}{:}\PYG{+w}{  }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{col}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{left}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{bottom}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{UP}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{col}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{case}\PYG{+w}{ }\PYG{n+no}{UP}\PYG{p}{:}\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{row}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{top}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{left}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{RIGHT}\PYG{p}{;}
\PYG{+w}{                            }\PYG{n}{col}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                            }\PYG{n}{row}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                        }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{r}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{r}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{generateMatrix}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{generateMatrix}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{m}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[[1,2,3,][8,9,4,][7,6,5,]]
[[1,]]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses a \sphinxcode{\sphinxupquote{Direction}} \sphinxcode{\sphinxupquote{enum}} and boundary variables to iteratively fill the matrix in a spiral pattern. Updating the direction of movement based on the current position and boundaries efficiently populates the matrix with sequential values, traversing in a clockwise direction from the outer layer to the inner layer.


\subsubsection{Complexity}
\label{\detokenize{Array/59_Spiral_Matrix_II:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n x n}} is the size of the matrix.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Array/59_Spiral_Matrix_II:key-takeaway}}
\sphinxAtStartPar
Enumerating directions with an enum (like \sphinxcode{\sphinxupquote{Direction}}) can enhance code readability and maintainability, especially in algorithms involving traversal or movement. It aids in clearly defining and referencing the possible directions within the problem domain.


\subsection{Exercise}
\label{\detokenize{Array/59_Spiral_Matrix_II:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/spiral-matrix/}{Spiral Matrix}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Daily Temperatures}
\label{\detokenize{Array/739_Daily_Temperatures:daily-temperatures}}\label{\detokenize{Array/739_Daily_Temperatures::doc}}

\subsection{Problem statement}
\label{\detokenize{Array/739_Daily_Temperatures:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/daily\sphinxhyphen{}temperatures/
%
\end{footnote}You are given an array of integers \sphinxcode{\sphinxupquote{temperatures}}, which represents the daily temperatures. Your task is to create an array \sphinxcode{\sphinxupquote{answer}} such that \sphinxcode{\sphinxupquote{answer{[}i{]}}} represents the number of days you need to wait after the i\sphinxhyphen{}th day to experience a warmer temperature. If there is no future day with a warmer temperature, then \sphinxcode{\sphinxupquote{answer{[}i{]}}} should be set to \sphinxcode{\sphinxupquote{0}}.


\subsubsection{Example 1}
\label{\detokenize{Array/739_Daily_Temperatures:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Array/739_Daily_Temperatures:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Array/739_Daily_Temperatures:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: temperatures = [30,60,90]
Output: [1,1,0]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Array/739_Daily_Temperatures:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= temperatures.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{30 \textless{}= temperatures{[}i{]} \textless{}= 100}}.

\end{itemize}


\subsection{Solution 1: Starting from the first day}
\label{\detokenize{Array/739_Daily_Temperatures:solution-1-starting-from-the-first-day}}
\sphinxAtStartPar
For each \sphinxcode{\sphinxupquote{temperatures{[}i{]}}}, find the closest \sphinxcode{\sphinxupquote{temperatures{[}j{]}}} with \sphinxcode{\sphinxupquote{j \textgreater{} i}} such that \sphinxcode{\sphinxupquote{temperatures{[}j{]} \textgreater{} temperatures{[}i{]}}}, then \sphinxcode{\sphinxupquote{answer{[}i{]} = j \sphinxhyphen{} i}}. If not found, \sphinxcode{\sphinxupquote{answer{[}i{]} = 0}}.


\subsubsection{Example 1}
\label{\detokenize{Array/739_Daily_Temperatures:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{temperatures = {[}73,74,75,71,69,72,76,73{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{answer{[}0{]} = 1}} since the next day is warmer (\sphinxcode{\sphinxupquote{74 \textgreater{} 73}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{answer{[}1{]} = 1}} since the next day is warmer (\sphinxcode{\sphinxupquote{75 \textgreater{} 74}}).

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{answer{[}2{]} = 4}} since only after \sphinxcode{\sphinxupquote{4}} days it is warmer (\sphinxcode{\sphinxupquote{76 \textgreater{} 75}}).

\item {} 
\sphinxAtStartPar
And so on.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Array/739_Daily_Temperatures:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{73}\PYG{p}{,}\PYG{l+m+mi}{74}\PYG{p}{,}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{l+m+mi}{71}\PYG{p}{,}\PYG{l+m+mi}{69}\PYG{p}{,}\PYG{l+m+mi}{72}\PYG{p}{,}\PYG{l+m+mi}{76}\PYG{p}{,}\PYG{l+m+mi}{73}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{temperatures}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{temperatures}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,1,4,2,1,1,0,0,]
[1,1,1,0,]
[1,1,0,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution iterates through the \sphinxcode{\sphinxupquote{temperatures}} array and, for each temperature, iterates through the remaining temperatures to find the next higher temperature. Storing the time difference between the current day and the next higher temperature day constructs the resulting array representing the number of days until warmer temperatures.


\subsubsection{Complexity}
\label{\detokenize{Array/739_Daily_Temperatures:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{N = temperatures.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Starting from the last day}
\label{\detokenize{Array/739_Daily_Temperatures:solution-2-starting-from-the-last-day}}
\sphinxAtStartPar
The straightforward solution above is easy to understand, but the complexity is \sphinxcode{\sphinxupquote{O(N\textasciicircum{}2)}}.

\sphinxAtStartPar
The way starting from the first day to the last day does not make use of the knowledge of the \sphinxcode{\sphinxupquote{answer{[}i{]}}} values.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The value \sphinxcode{\sphinxupquote{answer{[}i{]} \textgreater{} 0}} tells you that \sphinxcode{\sphinxupquote{temperatures{[}i + answer{[}i{]}{]}}} is the next temperature that is warmer than \sphinxcode{\sphinxupquote{temperatures{[}i{]}}}.

\item {} 
\sphinxAtStartPar
The value \sphinxcode{\sphinxupquote{answer{[}i{]} = 0}} tells you that there is no warmer temperature than \sphinxcode{\sphinxupquote{temperatures{[}i{]}}}.

\end{itemize}

\sphinxAtStartPar
When computing \sphinxcode{\sphinxupquote{answer{[}i{]}}} in the reversed order, you can use that knowledge more efficiently.

\sphinxAtStartPar
Suppose you already know the future values \sphinxcode{\sphinxupquote{answer{[}j{]}}}. To compute an older value \sphinxcode{\sphinxupquote{answer{[}i{]}}} with \sphinxcode{\sphinxupquote{i \textless{} j}}, you need only to compare \sphinxcode{\sphinxupquote{temperatures{[}i{]}}} with \sphinxcode{\sphinxupquote{temperatures{[}i + 1{]}}} and its \sphinxstylestrong{chain} of warmer temperatures.


\subsubsection{Example 1}
\label{\detokenize{Array/739_Daily_Temperatures:id3}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{temperatures = {[}73,74,75,71,69,72,76,73{]}}}.

\sphinxAtStartPar
Suppose you have computed all \sphinxcode{\sphinxupquote{answer{[}j{]}}} with \sphinxcode{\sphinxupquote{j \textgreater{} 2}}, \sphinxcode{\sphinxupquote{answer = {[}?,?,?,2,1,1,0,0{]}}}.

\sphinxAtStartPar
To compute \sphinxcode{\sphinxupquote{answer{[}i = 2{]}}} for \sphinxcode{\sphinxupquote{temperatures{[}2{]} = 75}}, you need to compare it with
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{temperatures{[}3{]} = 71 (\textless{} 75)}}. Go to the next warmer temperature than \sphinxcode{\sphinxupquote{temperatures{[}3{]}}}, which is \sphinxcode{\sphinxupquote{temperatures{[}3 + answer{[}3{]}{]} = temperatures{[}3 + 2{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{temperatures{[}5{]} = 72 (\textless{} 75)}}. Go to the next warmer temperature than \sphinxcode{\sphinxupquote{temperatures{[}5{]}}}, which is \sphinxcode{\sphinxupquote{temperatures{[}5 + answer{[}5{]}{]} = temperatures{[}5 + 1{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{temperatures{[}6{]} = 76 (\textgreater{} 75)}}. Stop.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{answer{[}i = 2{]} = j \sphinxhyphen{} i = 6 \sphinxhyphen{} 2 = 4}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Array/739_Daily_Temperatures:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }
\PYG{+w}{               }\PYG{n}{temperatures}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// some temperature is bigger than temperatures[j], }
\PYG{+w}{            }\PYG{c+c1}{// go to that value }
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{answer}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{                }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{temperatures}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{73}\PYG{p}{,}\PYG{l+m+mi}{74}\PYG{p}{,}\PYG{l+m+mi}{75}\PYG{p}{,}\PYG{l+m+mi}{71}\PYG{p}{,}\PYG{l+m+mi}{69}\PYG{p}{,}\PYG{l+m+mi}{72}\PYG{p}{,}\PYG{l+m+mi}{76}\PYG{p}{,}\PYG{l+m+mi}{73}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{temperatures}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{temperatures}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{l+m+mi}{60}\PYG{p}{,}\PYG{l+m+mi}{90}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dailyTemperatures}\PYG{p}{(}\PYG{n}{temperatures}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,1,4,2,1,1,0,0,]
[1,1,1,0,]
[1,1,0,]
\end{sphinxVerbatim}

\sphinxAtStartPar
The key to this solution lies in its optimized approach to finding the next higher temperature. It utilizes a \sphinxcode{\sphinxupquote{while}} loop to traverse the \sphinxcode{\sphinxupquote{temperatures}} array efficiently, skipping elements if they are not potential candidates for a higher temperature. Updating the index based on previously calculated values stored in the \sphinxcode{\sphinxupquote{answer}} array avoids unnecessary iterations, resulting in improved performance compared to the straightforward nested loop approach.

\sphinxAtStartPar
This improved solution reduces the time complexity to \sphinxcode{\sphinxupquote{O(N)}} as it iterates through the \sphinxcode{\sphinxupquote{temperatures}} vector only once, resulting in a more efficient algorithm for finding the waiting periods for each day.


\subsubsection{Complexity}
\label{\detokenize{Array/739_Daily_Temperatures:id5}}
\sphinxAtStartPar
Worse cases for the \sphinxcode{\sphinxupquote{while}} loop are when most \sphinxcode{\sphinxupquote{temperatures{[}j{]}}} in their chain are cooler than \sphinxcode{\sphinxupquote{temperatures{[}i{]}}}.

\sphinxAtStartPar
In these cases, the resulting \sphinxcode{\sphinxupquote{answer{[}i{]}}} will be either \sphinxcode{\sphinxupquote{0}} or a big value \sphinxcode{\sphinxupquote{j \sphinxhyphen{} i}}. Those extreme values give you a huge knowledge when computing \sphinxcode{\sphinxupquote{answer{[}i{]}}} for other older days \sphinxcode{\sphinxupquote{i}}.

\sphinxAtStartPar
The value \sphinxcode{\sphinxupquote{0}} would help the \sphinxcode{\sphinxupquote{while}} loop terminates very soon. On the other hand, the big value \sphinxcode{\sphinxupquote{j \sphinxhyphen{} i}} would help the \sphinxcode{\sphinxupquote{while}} loop skips the days \sphinxcode{\sphinxupquote{j}} very quickly.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = temperatures.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Tips}
\label{\detokenize{Array/739_Daily_Temperatures:tips}}
\sphinxAtStartPar
In some computations, you could improve the performance by using the knowledge of the results you have computed.

\sphinxAtStartPar
In this particular problem, it can be achieved by doing it in the reversed order.


\subsection{Exercise}
\label{\detokenize{Array/739_Daily_Temperatures:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/next-greater-element-i/description/}{Next Greater Element I}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Linked List}
\label{\detokenize{Linked_List/index:linked-list}}\label{\detokenize{Linked_List/index::doc}}
\sphinxAtStartPar
In this chapter, we’ll learn about \sphinxstylestrong{linked list} \sphinxhyphen{} a unique and dynamic data structure that challenges our understanding of sequential data.

\sphinxAtStartPar
Unlike \sphinxstyleemphasis{arrays}, linked lists do not impose a fixed size or continuous memory block. Rather, they consist of nodes that contain data and a reference to the next node. This seemingly simple concept unlocks many possibilities, from creating efficient insertions and deletions to creatively solving problems that may seem specifically designed for linked list manipulation.

\sphinxAtStartPar
Our exploration of linked lists will encompass a variety of variations and intricacies, including singly linked lists. By delving into these lists, you’ll discover how they empower us to tackle problems that may initially appear complicated.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Linked Lists:} Gain a comprehensive understanding of linked lists, their advantages, and their role in problem\sphinxhyphen{}solving.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Singly Linked Lists:} Explore the mechanics of singly linked lists, mastering the art of traversal, insertion, and deletion.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Advanced Linked List Concepts:} Learn about sentinel nodes, dummy nodes, and techniques to handle common challenges like detecting cycles and reversing lists.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving Strategies:} Develop strategies to approach linked list problems systematically, including strategies for merging lists, detecting intersections, and more.

\end{enumerate}

\sphinxstepscope


\section{Merge Two Sorted Lists}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:merge-two-sorted-lists}}\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists::doc}}

\subsection{Problem statement}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/merge\sphinxhyphen{}two\sphinxhyphen{}sorted\sphinxhyphen{}lists/
%
\end{footnote}Given the starting nodes of two sorted linked lists, \sphinxcode{\sphinxupquote{list1}} and \sphinxcode{\sphinxupquote{list2}}, your task is to combine these lists into a single sorted linked list.

\sphinxAtStartPar
This merged list should be created by connecting the nodes from both \sphinxcode{\sphinxupquote{list1}} and \sphinxcode{\sphinxupquote{list2}}. Finally, you should return the starting node of the resulting merged linked list.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{21_merge_ex1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: list1 = [], list2 = []
Output: []
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: list1 = [], list2 = [0]
Output: [0]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in both lists is in the range \sphinxcode{\sphinxupquote{{[}0, 50{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}100 \textless{}= Node.val \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
Both \sphinxcode{\sphinxupquote{list1}} and \sphinxcode{\sphinxupquote{list2}} are sorted in non\sphinxhyphen{}decreasing order.

\end{itemize}


\subsection{Solution: Constructing a new list}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:solution-constructing-a-new-list}}
\sphinxAtStartPar
For each pair of nodes between the two lists, pick the node having smaller value to append to the new list.


\subsubsection{Code}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{ }
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{mergeTwoLists}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list1}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list2}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{list1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// identify which list is head of the merged one}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{list2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{list1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list1}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// pick the smaller node to append to the new list.}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{list2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list1}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{list1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{list2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{list1}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list2}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{list1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two1}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four2}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{newOne}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mergeTwoLists}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{newOne}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{empty}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mergeTwoLists}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{empty}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{zero}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{mergeTwoLists}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{zero}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,1,2,3,4,4,]
[]
[0,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = list1.length + list2.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Linked_List/21_Merge_Two_Sorted_Lists:key-takeaway}}
\sphinxAtStartPar
This solution merges two sorted linked lists efficiently without using extra space.

\sphinxAtStartPar
It identifies the head of the merged list by comparing the values of the first nodes of the input lists. Then, it iterates through both lists, linking nodes in ascending order until one list is exhausted.

\sphinxAtStartPar
Finally, it appends the remaining nodes from the non\sphinxhyphen{}empty list to the merged list, ensuring the resulting list remains sorted.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Remove Linked List Elements}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:remove-linked-list-elements}}\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements::doc}}

\subsection{Problem statement}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/remove\sphinxhyphen{}linked\sphinxhyphen{}list\sphinxhyphen{}elements/
%
\end{footnote}You are given the starting node, \sphinxcode{\sphinxupquote{head}}, of a linked list, and an integer \sphinxcode{\sphinxupquote{val}}. Your task is to eliminate all nodes from the linked list that have a value equal to \sphinxcode{\sphinxupquote{val}}. After removing these nodes, return the new starting node of the modified linked list.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{203_removelinked-list}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [], val = 1
Output: []
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [7,7,7,7], val = 7
Output: []
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in the list is in the range \sphinxcode{\sphinxupquote{{[}0, 10\textasciicircum{}4{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= Node.val \textless{}= 50}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= val \textless{}= 50}}.

\end{itemize}


\subsubsection{Linked list data structure}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:linked-list-data-structure}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}


\subsection{Solution 1: Consider the special case for head}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:solution-1-consider-the-special-case-for-head}}
\sphinxAtStartPar
Removing a node \sphinxcode{\sphinxupquote{A}} in a linked list means instead of connecting the previous node \sphinxcode{\sphinxupquote{A.pre}} to \sphinxcode{\sphinxupquote{A}}, you connect \sphinxcode{\sphinxupquote{A.pre}} to \sphinxcode{\sphinxupquote{A.next}}.


\subsubsection{Code}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{removeElements}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// remove head if its value matches val}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// remove pre\PYGZhy{}\PYGZgt{}next}
\PYG{+w}{            }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{sixb}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{sixb}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{sixa}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{sixa}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven4}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven3}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven2}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven1}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{seven1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,3,4,5,]
[]
[]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently removes nodes with a specified value \sphinxcode{\sphinxupquote{val}} from a linked list by using two pointers (\sphinxcode{\sphinxupquote{head}} and \sphinxcode{\sphinxupquote{pre}}) to traverse the list and update the \sphinxcode{\sphinxupquote{next}} pointers to bypass nodes with the specified value.


\subsubsection{Complexity}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes.

\item {} 
\sphinxAtStartPar
Memory: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Create a previous dummy node for head}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:solution-2-create-a-previous-dummy-node-for-head}}\index{dummy node@\spxentry{dummy node}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{head}} has no \sphinxcode{\sphinxupquote{pre}}. You can create a dummy node for \sphinxcode{\sphinxupquote{head.pre}} whose values is out of the contraints.


\subsubsection{Code}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{removeElements}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{    }\PYG{c+c1}{// create a new head of value 2023 \PYGZgt{} 50}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{preHead}\PYG{p}{(}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{preHead}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{preHead}\PYG{p}{.}\PYG{n}{next}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{sixb}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{sixb}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{sixa}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{sixa}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven4}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven3}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven2}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{seven1}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{seven2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{newHead}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeElements}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{seven1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{newHead}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,3,4,5,]
[]
[]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution creates a \sphinxcode{\sphinxupquote{preHead}} node with a value of \sphinxcode{\sphinxupquote{2023}} (an arbitrary value larger than \sphinxcode{\sphinxupquote{50}}) and sets its \sphinxcode{\sphinxupquote{next}} pointer to point to the original \sphinxcode{\sphinxupquote{head}} of the linked list.

\sphinxAtStartPar
The purpose of this \sphinxcode{\sphinxupquote{preHead}} node is to serve as the dummy or sentinel node at the beginning of the linked list. Having a \sphinxcode{\sphinxupquote{preHead}} node simplifies the code because it eliminates the need to handle the special case of removing nodes from the beginning of the list separately.

\sphinxAtStartPar
The remaining code is the same.


\subsubsection{Complexity}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes.

\item {} 
\sphinxAtStartPar
Memory: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsubsection{Attention!}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:attention}}
\sphinxAtStartPar
Depending on your real situation, in practice, you might need to deallocate memory for the removed nodes; especially when they were allocated by the \sphinxcode{\sphinxupquote{new}} operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{removeElements}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{preHead}\PYG{p}{(}\PYG{l+m+mi}{2022}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{preHead}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{delete}\PYG{+w}{ }\PYG{n}{node}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{preHead}\PYG{p}{.}\PYG{n}{next}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}


\subsection{Key takeaway}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:key-takeaway}}\begin{itemize}
\item {} 
\sphinxAtStartPar
In some linked list problems where \sphinxcode{\sphinxupquote{head}} needs to be treated as a special case, you can create a previous dummy node for it to adapt the general algorithm.

\item {} 
\sphinxAtStartPar
Be careful with memory leak when removing nodes of the linked list containing pointers.

\end{itemize}


\subsection{Exercise}
\label{\detokenize{Linked_List/203_Remove_Linked_List_Elements:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/delete-node-in-a-linked-list/}{Delete Node in a Linked List}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Intersection of Two Linked Lists}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:intersection-of-two-linked-lists}}\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists::doc}}

\subsection{Problem statement}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/intersection\sphinxhyphen{}of\sphinxhyphen{}two\sphinxhyphen{}linked\sphinxhyphen{}lists/
%
\end{footnote}You are provided with the starting nodes of two singly linked lists, \sphinxcode{\sphinxupquote{headA}} and \sphinxcode{\sphinxupquote{headB}}. Your task is to find the node where these two lists intersect. If there is no point of intersection, return \sphinxcode{\sphinxupquote{null}}.

\sphinxAtStartPar
For example, the following two linked lists begin to intersect at node \sphinxcode{\sphinxupquote{c1}}:

\sphinxAtStartPar
\sphinxincludegraphics{{160_statement}.png}

\sphinxAtStartPar
Note that the linked lists do not have any cycles, and you must ensure that the original structure of the linked lists remains unchanged after solving this problem.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{160_example_1_1}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: listA = [4,1,8,4,5], listB = [5,6,1,8,4,5].
Output: Intersected at \PYGZsq{}8\PYGZsq{}
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:example-2}}
\sphinxAtStartPar
\sphinxincludegraphics{{160_example_2}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: listA = [1,9,1,2,4], listB = [3,2,4]
Output: Intersected at \PYGZsq{}2\PYGZsq{}
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:example-3}}
\sphinxAtStartPar
\sphinxincludegraphics{{160_example_3}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: listA = [2,6,4], listB = [1,5]
Output: No intersection.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes of \sphinxcode{\sphinxupquote{listA}} is in the \sphinxcode{\sphinxupquote{m}}.

\item {} 
\sphinxAtStartPar
The number of nodes of \sphinxcode{\sphinxupquote{listB}} is in the \sphinxcode{\sphinxupquote{n}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m, n \textless{}= 3 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= Node.val \textless{}= 10\textasciicircum{}5}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you write a solution that runs in \sphinxcode{\sphinxupquote{O(m + n)}} time and use only \sphinxcode{\sphinxupquote{O(1)}} memory?

\end{itemize}


\subsection{Solution 1: Store the nodes}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:solution-1-store-the-nodes}}
\sphinxAtStartPar
You can store all nodes of \sphinxcode{\sphinxupquote{listA}} then iterate \sphinxcode{\sphinxupquote{listB}} to determine which node is the intersection. If none is found, the two lists have no intersection.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Store all nodes of \sphinxcode{\sphinxupquote{listA = {[}4,1,8,4,5{]}}} in a map.

\item {} 
\sphinxAtStartPar
Iterate \sphinxcode{\sphinxupquote{listB}} and found node \sphinxcode{\sphinxupquote{\textquotesingle{}8\textquotesingle{}}} was stored.

\item {} 
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{\textquotesingle{}8\textquotesingle{}}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n+nf}{getIntersectionNode}\PYG{p}{(}\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{headA}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{headB}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{n}{ListNode}\PYG{o}{*}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headA}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{p}{[}\PYG{n}{node}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headB}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{node}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 1}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{eight}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{eight}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one1}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six2}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{six2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one2}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{five2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six2}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{four1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 2}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one12}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one12}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine1}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nine1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one12}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one11}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one11}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine1}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{three2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one11}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 3}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{six}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This code uses an unordered map to store the nodes of \sphinxcode{\sphinxupquote{headA}} while traversing it. Then, it traverses \sphinxcode{\sphinxupquote{headB}} and checks if each node in \sphinxcode{\sphinxupquote{headB}} exists in the map of nodes from \sphinxcode{\sphinxupquote{headA}}. If a common node is found, it returns that node as the intersection point; otherwise, it returns \sphinxcode{\sphinxupquote{nullptr}} to indicate no intersection.


\subsubsection{Complexity}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m + n)}}, where \sphinxcode{\sphinxupquote{m}}, \sphinxcode{\sphinxupquote{n}} are the number of nodes of \sphinxcode{\sphinxupquote{listA}} and \sphinxcode{\sphinxupquote{listB}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(m)}}.

\end{itemize}


\subsection{Solution 2: Reiterating the two lists at the same time}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:solution-2-reiterating-the-two-lists-at-the-same-time}}
\sphinxAtStartPar
If the two lists do not share the same tail, they have no intersection. Otherwise, they must intersect at some node.

\sphinxAtStartPar
After iterating to find the tail node, you know the length of the two lists. That information gives you a hint of how to reiterate to find the intersection node.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
After iterating \sphinxcode{\sphinxupquote{listA = {[}4,1,8,4,5{]}}}, you find the tail node is \sphinxcode{\sphinxupquote{\textquotesingle{}5\textquotesingle{}}} and \sphinxcode{\sphinxupquote{listA.length = 5}}.

\item {} 
\sphinxAtStartPar
After iterating \sphinxcode{\sphinxupquote{listB = {[}5,6,1,8,4,5{]}}}, you find the tail node is the last \sphinxcode{\sphinxupquote{\textquotesingle{}5\textquotesingle{}}} and \sphinxcode{\sphinxupquote{listB.length = 6}}.

\item {} 
\sphinxAtStartPar
The two lists share the same tail. They must intersect at some node.

\item {} 
\sphinxAtStartPar
To find that intersection node, you have to reiterate the two lists.

\item {} 
\sphinxAtStartPar
Since \sphinxcode{\sphinxupquote{listB.length = 6 \textgreater{} 5 = listA.length}}, you can start iterating \sphinxcode{\sphinxupquote{listB}} first until the number of its remaining nodes is the same as \sphinxcode{\sphinxupquote{listA}}. In this case, it is the node \sphinxcode{\sphinxupquote{\textquotesingle{}6\textquotesingle{}}} of \sphinxcode{\sphinxupquote{listB}}.

\item {} 
\sphinxAtStartPar
Now you can iterate them at the same time to find which node is shared.

\item {} 
\sphinxAtStartPar
Found and return the intersection node \sphinxcode{\sphinxupquote{\textquotesingle{}8\textquotesingle{}}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n+nf}{getIntersectionNode}\PYG{p}{(}\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{headA}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{headB}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lengthA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headA}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nodeA}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{lengthA}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeA}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{lengthB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{nodeB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headB}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nodeB}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{lengthB}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nodeB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeB}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// not the same tail \PYGZhy{}\PYGZgt{} no intersection}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeB}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headA}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nodeB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{headB}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// find the nodeA in listA and nodeB in listB}
\PYG{+w}{    }\PYG{c+c1}{// that make two lists have the same length }
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{lengthA}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{lengthB}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeA}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{lengthA}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{lengthB}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{lengthA}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{nodeB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeB}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{lengthB}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// find the intersection}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeB}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{nodeA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeA}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nodeB}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodeB}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nodeA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 1}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{eight}\PYG{p}{(}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{eight}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one1}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one1}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one2}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six2}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{six2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one2}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five2}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{five2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six2}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{four1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{eight}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 2}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one12}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one12}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine1}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nine1}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one12}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one11}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one11}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine1}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three2}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{three2}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one11}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// Example 3}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{six}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six}\PYG{p}{;}

\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{getIntersectionNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This improved solution finds the intersection of two linked lists by first determining their lengths and adjusting the pointers so that they start from the same relative position to the intersection point. Then, it iterates through both linked lists until it finds the common intersection node.


\subsubsection{Complexity}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m + n)}}, where \sphinxcode{\sphinxupquote{m}}, \sphinxcode{\sphinxupquote{n}} are the number of nodes of \sphinxcode{\sphinxupquote{listA}} and \sphinxcode{\sphinxupquote{listB}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Implementation tip}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:implementation-tip}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The technique used in Solution 2 is known as the \sphinxstyleemphasis{Two\sphinxhyphen{}pointer} technique since you use two pointers to iterate the list at the same time.

\end{itemize}


\subsection{Exercise}
\label{\detokenize{Linked_List/160_Intersection_of_Two_Linked_Lists:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-index-sum-of-two-lists/}{Minimum Index Sum of Two Lists}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Swap Nodes in Pairs}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:swap-nodes-in-pairs}}\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs::doc}}

\subsection{Problem statement}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/swap\sphinxhyphen{}nodes\sphinxhyphen{}in\sphinxhyphen{}pairs/
%
\end{footnote}You are provided with a linked list. Your goal is to exchange every two adjacent nodes in the list and then return the head of the modified list.

\sphinxAtStartPar
You must solve this problem without altering the values within the nodes; you should only modify the arrangement of the nodes themselves.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{24_swap_ex1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2,3,4]
Output: [2,1,4,3]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = []
Output: []
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1]
Output: [1]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in the list is in the range \sphinxcode{\sphinxupquote{{[}0, 100{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= Node.val \textless{}= 100}}.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:solution}}
\sphinxAtStartPar
Draw a picture of the swapping to identify the correct order of the update.

\sphinxAtStartPar
\sphinxincludegraphics{{24_drawing_1}.png}

\sphinxAtStartPar
Denote \sphinxcode{\sphinxupquote{(cur, next)}} the pair of nodes you want to swap and \sphinxcode{\sphinxupquote{prev}} be the previous node that links to \sphinxcode{\sphinxupquote{cur}}. Here are the steps you need to perform for the swapping.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Update the links between nodes.

\item {} 
\sphinxAtStartPar
Go to the next pair.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{swapPairs}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// the list does not have enough nodes to swap}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{preNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{curNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{nextNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{    }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nextNode}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{curNode}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nextNode}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{        }\PYG{c+c1}{// swap curNode and nextNode}
\PYG{+w}{        }\PYG{n}{curNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nextNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{nextNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{curNode}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// update links/pointers after swap}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{preNode}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{preNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nextNode}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}

\PYG{+w}{        }\PYG{c+c1}{// update nodes for next step}
\PYG{+w}{        }\PYG{n}{preNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{curNode}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{curNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{curNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}\PYG{+w}{       }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{curNode}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{nextNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{curNode}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{swapPairs}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{swapPairs}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{swapPairs}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[2,1,4,3,]
[]
[5,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:key-takeaway}}
\sphinxAtStartPar
This solution swaps pairs of nodes in a linked list by adjusting the pointers accordingly.

\sphinxAtStartPar
It initializes pointers to the current node (\sphinxcode{\sphinxupquote{curNode}}), its next node (\sphinxcode{\sphinxupquote{nextNode}}), and the previous node (\sphinxcode{\sphinxupquote{preNode}}). Then, it iterates through the list, swapping pairs of nodes by adjusting their \sphinxcode{\sphinxupquote{next}} pointers and updating the \sphinxcode{\sphinxupquote{preNode}} pointer.

\sphinxAtStartPar
This approach efficiently swaps adjacent nodes in the list without requiring additional space, effectively transforming the list by rearranging pointers.


\subsection{Exercise}
\label{\detokenize{Linked_List/24_Swap_Nodes_in_Pairs:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/swapping-nodes-in-a-linked-list/}{Swapping Nodes in a Linked List}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Add Two Numbers}
\label{\detokenize{Linked_List/2_add_two_numbers:add-two-numbers}}\label{\detokenize{Linked_List/2_add_two_numbers::doc}}

\subsection{Problem statement}
\label{\detokenize{Linked_List/2_add_two_numbers:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/add\sphinxhyphen{}two\sphinxhyphen{}numbers/
%
\end{footnote}You have two linked lists that represent non\sphinxhyphen{}negative integers. The digits of these numbers are stored in reverse order, with each node containing a single digit.

\sphinxAtStartPar
Your task is to add the two numbers represented by these linked lists and return the result as a new linked list.

\sphinxAtStartPar
You can assume that the two numbers don’t have leading zeros, except for the number 0 itself.


\subsubsection{Example 1}
\label{\detokenize{Linked_List/2_add_two_numbers:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{2_addtwonumber1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Linked_List/2_add_two_numbers:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: l1 = [0], l2 = [0]
Output: [0]
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Linked_List/2_add_two_numbers:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Linked_List/2_add_two_numbers:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in each linked list is in the range \sphinxcode{\sphinxupquote{{[}1, 100{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= Node.val \textless{}= 9}}.

\item {} 
\sphinxAtStartPar
It is guaranteed that the list represents a number that does not have leading zeros.

\end{itemize}


\subsection{Solution: Addition With Remember}
\label{\detokenize{Linked_List/2_add_two_numbers:solution-addition-with-remember}}
\sphinxAtStartPar
Perform the school addition calculation and store the result in one of the lists.

\sphinxAtStartPar
Without loss of generality, let us store the result in \sphinxcode{\sphinxupquote{l1}}. Then you might need to extend it when \sphinxcode{\sphinxupquote{l2}} is longer than \sphinxcode{\sphinxupquote{l1}} and when the result requires one additional node (Example 3).


\subsubsection{Code}
\label{\detokenize{Linked_List/2_add_two_numbers:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{addTwoNumbers}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{l1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{l2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// dummy node to hook the head of the list}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{prehead}\PYG{p}{;}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{c+c1}{// let\PYGZsq{}s use l1\PYGZsq{}s nodes to store result}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l1}\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{    }\PYG{n}{prehead}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{        }\PYG{c+c1}{// perform the addition}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{l1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l1}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{l2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l2}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// keep track the carry}
\PYG{+w}{        }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{/}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{l1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{      }\PYG{c+c1}{// l1 ends        }
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }\PYG{c+c1}{// l1 is shorter than l2}
\PYG{+w}{                }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l2}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{  }
\PYG{+w}{                }\PYG{c+c1}{// both l1 and l2 end but the remember is not zero }
\PYG{+w}{                }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{newNode}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{new}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{p}{(}\PYG{n}{sum}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{newNode}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{prehead}\PYG{p}{.}\PYG{n}{next}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{l}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{l}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{l}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four1}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four2}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{addTwoNumbers}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{zero1}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{zero2}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{addTwoNumbers}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{zero1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{zero2}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine0}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine1}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine2}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine3}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine4}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine5}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine6}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine7}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine8}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine7}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine9}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine8}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{nine10}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine9}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{addTwoNumbers}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{nine6}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{nine10}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[7,0,8,]
[0,]
[8,9,9,9,0,0,0,1,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Linked_List/2_add_two_numbers:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = max(l1.length, l2.length)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Linked_List/2_add_two_numbers:key-takeaway}}
\sphinxAtStartPar
This solution leverages a dummy node (\sphinxcode{\sphinxupquote{prehead}}) to simplify the handling of edge cases and to hook the head of the resulting list.

\sphinxAtStartPar
By iterating through both input lists simultaneously and performing addition digit by digit while keeping track of carry, it efficiently computes the sum without the need for additional checks for the head of the resulting list.

\sphinxAtStartPar
This approach streamlines the addition process, resulting in a concise and straightforward implementation.


\subsection{Exercise}
\label{\detokenize{Linked_List/2_add_two_numbers:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/}{Double a Number Represented as a Linked List}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Hash Table}
\label{\detokenize{Hash_Table/index:hash-table}}\label{\detokenize{Hash_Table/index::doc}}
\sphinxAtStartPar
This chapter is about the C++ Standard Template Library’s \sphinxcode{\sphinxupquote{std::unordered\_map}} and how it can help your programming.

\sphinxAtStartPar
With hash\sphinxhyphen{}based data structures, you can store and retrieve information quickly, like a well\sphinxhyphen{}organized library. Hash tables allow you to efficiently manage data by inserting, locating, and removing elements, even from large datasets. C++’s \sphinxcode{\sphinxupquote{std::unordered\_map}} makes it easy to use hash tables without manual implementation.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exploring std::unordered\_map:} Dive into the C++ Standard Template Library’s \sphinxtitleref{std::unordered\_map} container, learning how to use it effectively for mapping keys to values.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Hash Tables:} Learn strategies for solving many problems using hash tables, including frequency counting, anagram detection, and more.

\end{enumerate}

\sphinxstepscope


\section{Roman to Integer}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:roman-to-integer}}\label{\detokenize{Hash_Table/13_Roman_to_Integer::doc}}

\subsection{Problem statement}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/roman\sphinxhyphen{}to\sphinxhyphen{}integer/
%
\end{footnote}Roman numerals utilize seven symbols: \sphinxcode{\sphinxupquote{I}}, \sphinxcode{\sphinxupquote{V}}, \sphinxcode{\sphinxupquote{X}}, \sphinxcode{\sphinxupquote{L}}, \sphinxcode{\sphinxupquote{C}}, \sphinxcode{\sphinxupquote{D}}, and \sphinxcode{\sphinxupquote{M}} to represent numbers.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
\end{sphinxVerbatim}

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{2}} is denoted as \sphinxcode{\sphinxupquote{II}}, which is essentially two ones added together. Similarly, \sphinxcode{\sphinxupquote{12}} is represented as \sphinxcode{\sphinxupquote{XII}}, indicating \sphinxcode{\sphinxupquote{X + II}}. The number \sphinxcode{\sphinxupquote{27}} is written as \sphinxcode{\sphinxupquote{XXVII}}, which stands for \sphinxcode{\sphinxupquote{XX + V + II}}.

\sphinxAtStartPar
Roman numerals are generally written from the largest value to the smallest value, moving from left to right. However, there are exceptions to this pattern. For instance, the numeral for \sphinxcode{\sphinxupquote{4}} is \sphinxcode{\sphinxupquote{IV}} instead of \sphinxcode{\sphinxupquote{IIII}}, where \sphinxcode{\sphinxupquote{I}} is placed before \sphinxcode{\sphinxupquote{V}} to subtract \sphinxcode{\sphinxupquote{1}} from \sphinxcode{\sphinxupquote{5}}. Similarly, \sphinxcode{\sphinxupquote{9}} is \sphinxcode{\sphinxupquote{IX}}, representing the subtraction of \sphinxcode{\sphinxupquote{1}} from \sphinxcode{\sphinxupquote{10}}. There are six such subtraction instances:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{I}} before \sphinxcode{\sphinxupquote{V}} (\sphinxcode{\sphinxupquote{5}}) or \sphinxcode{\sphinxupquote{X}} (\sphinxcode{\sphinxupquote{10}}) forms \sphinxcode{\sphinxupquote{4}} and \sphinxcode{\sphinxupquote{9}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{X}} before \sphinxcode{\sphinxupquote{L}} (\sphinxcode{\sphinxupquote{50}}) or \sphinxcode{\sphinxupquote{C}} (\sphinxcode{\sphinxupquote{100}}) forms \sphinxcode{\sphinxupquote{40}} and \sphinxcode{\sphinxupquote{90}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{C}} before \sphinxcode{\sphinxupquote{D}} (\sphinxcode{\sphinxupquote{500}}) or \sphinxcode{\sphinxupquote{M}} (\sphinxcode{\sphinxupquote{1000}}) forms \sphinxcode{\sphinxupquote{400}} and \sphinxcode{\sphinxupquote{900}}.

\end{itemize}

\sphinxAtStartPar
Your task is to convert a given Roman numeral into its equivalent integer value.


\subsubsection{Example 1}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}III\PYGZdq{}
Output: 3
Explanation: III = 3.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}LVIII\PYGZdq{}
Output: 58
Explanation: L = 50, V= 5, III = 3.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}MCMXCIV\PYGZdq{}
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length \textless{}= 15}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} contains only the characters \sphinxcode{\sphinxupquote{\textquotesingle{}I\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}V\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}X\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}L\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}C\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}D\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}M\textquotesingle{}}}.

\item {} 
\sphinxAtStartPar
It is guaranteed that \sphinxcode{\sphinxupquote{s}} is a valid Roman numeral in the range \sphinxcode{\sphinxupquote{{[}1, 3999{]}}}.

\end{itemize}


\subsection{Solution: Mapping and summing the values}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:solution-mapping-and-summing-the-values}}
\sphinxAtStartPar
To treat the subtraction cases easier you can iterate the string \sphinxcode{\sphinxupquote{s}} backward.


\subsubsection{Code}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{value}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{I}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{   }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{V}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{X}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{  }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{L}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{50}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{C}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{100}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{D}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{500}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{M}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1000}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{romanToInt}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{    }\PYG{c+c1}{// starting from the end character of the string s}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// In cases of subtraction}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{value}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{value}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{romanToInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{III}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{romanToInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{LVIII}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{romanToInt}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{MCMXCIV}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
58
1994
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}} where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:key-takeaway}}
\sphinxAtStartPar
This problem can be solved using a map to store the values of each Roman numeral character. This solution iterates through the string from right to left, accumulating the integer value based on the corresponding Roman numeral characters.

\sphinxAtStartPar
By comparing the current character’s value with the previous one, the solution handles cases of subtraction (e.g., IV, IX, etc.) by subtracting the value if it’s smaller and adding it otherwise.


\subsection{Exercise}
\label{\detokenize{Hash_Table/13_Roman_to_Integer:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/integer-to-roman/}{Integer to Roman}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Maximum Erasure Value}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:maximum-erasure-value}}\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value::doc}}

\subsection{Problem statement}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/maximum\sphinxhyphen{}erasure\sphinxhyphen{}value/
%
\end{footnote}You have an array of positive integers called \sphinxcode{\sphinxupquote{nums}}, and you wish to remove a subarray from it that consists of distinct elements. The score you achieve by removing this subarray is the sum of its elements.

\sphinxAtStartPar
Your goal is to determine the highest possible score attainable by erasing exactly one subarray from the provided array.

\sphinxAtStartPar
A subarray, denoted as \sphinxcode{\sphinxupquote{b}}, is considered part of another array, \sphinxcode{\sphinxupquote{a}}, if it appears consecutively within \sphinxcode{\sphinxupquote{a}}, i.e., if it is equivalent to \sphinxcode{\sphinxupquote{a{[}l{]}, a{[}l+1{]}, ..., a{[}r{]}}} for some indices \sphinxcode{\sphinxupquote{(l, r)}}.


\subsubsection{Example 1}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution: Store the position of the visited elements}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:solution-store-the-position-of-the-visited-elements}}
\sphinxAtStartPar
You can use a map to store the position of the elements of \sphinxcode{\sphinxupquote{nums}}. Then when iterating \sphinxcode{\sphinxupquote{nums}} you can identify if an element has been visited before. That helps you to decide if a subarray contains unique elements.


\subsubsection{Code}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maximumUniqueSubarray}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// sum stores the running sum of nums}
\PYG{+w}{    }\PYG{c+c1}{// i.e., sum[i] = nums[0] + ... + nums[i]}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sum}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// store the maximum sum of the maximum subarray}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// position[a] keeps track of latest index i whose nums[i] = a}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{position}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// the starting index of the current subarray}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{sum}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// check if the current subarray\PYGZsq{}s elements are still distinct}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }
\PYG{+w}{        }\PYG{c+c1}{// found the value nums[i] in the map position}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// a new subarray now starts from i}
\PYG{+w}{            }\PYG{n}{start}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{c+c1}{// clear the latest index of the value nums[i]}
\PYG{+w}{            }\PYG{c+c1}{// by updating it to i }
\PYG{+w}{            }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// current subarray continues with nums[i]}
\PYG{+w}{            }\PYG{n}{position}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{            }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{start}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// still on the first subarray nums[0]..nums[i]}
\PYG{+w}{            }\PYG{n}{maxSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// update maxSum with the sum of subarray nums[start]..nums[i]}
\PYG{+w}{            }\PYG{n}{maxSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxSum}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{start}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxSum}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maximumUniqueSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maximumUniqueSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
17
8
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Hash_Table/1695_Maximum_Erasure_Value:key-takeaway}}
\sphinxAtStartPar
This solution computes the maximum sum of a subarray containing unique elements.

\sphinxAtStartPar
It uses a \index{sliding window@\spxentry{sliding window}}sliding window approach to maintain a running sum of the elements encountered so far and a hashmap to keep track of the positions of previously seen elements. By updating the starting index of the window when a repeated element is encountered, it ensures that the current subarray contains only unique elements.

\sphinxAtStartPar
This approach optimizes the computation of the maximum sum by handling the sliding window and updating the sum accordingly, resulting in an overall efficient solution.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Find and Replace Pattern}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:find-and-replace-pattern}}\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern::doc}}

\subsection{Problem statement}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/find\sphinxhyphen{}and\sphinxhyphen{}replace\sphinxhyphen{}pattern/
%
\end{footnote}You are provided with a list of strings named \sphinxcode{\sphinxupquote{words}} and a string named \sphinxcode{\sphinxupquote{pattern}}. Your task is to find the strings from \sphinxcode{\sphinxupquote{words}} that match the given \sphinxcode{\sphinxupquote{pattern}}. The order in which you return the answers does not matter.

\sphinxAtStartPar
A word is considered to match the pattern if there is a mapping \sphinxcode{\sphinxupquote{p}} of the letters such that, when each letter \sphinxcode{\sphinxupquote{x}} in the pattern is replaced with \sphinxcode{\sphinxupquote{p(x)}}, the word is formed.

\sphinxAtStartPar
Keep in mind that a permutation of letters is a one\sphinxhyphen{}to\sphinxhyphen{}one correspondence from letters to letters, where each letter is mapped to a distinct letter, and no two letters are mapped to the same letter.


\subsubsection{Example 1}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}abc\PYGZdq{},\PYGZdq{}deq\PYGZdq{},\PYGZdq{}mee\PYGZdq{},\PYGZdq{}aqq\PYGZdq{},\PYGZdq{}dkd\PYGZdq{},\PYGZdq{}ccc\PYGZdq{}], pattern = \PYGZdq{}abb\PYGZdq{}
Output: [\PYGZdq{}mee\PYGZdq{},\PYGZdq{}aqq\PYGZdq{}]
Explanation: \PYGZdq{}mee\PYGZdq{} matches the pattern because there is a permutation \PYGZob{}a \PYGZhy{}\PYGZgt{} m, b \PYGZhy{}\PYGZgt{} e, ...\PYGZcb{}. 
\PYGZdq{}ccc\PYGZdq{} does not match the pattern because \PYGZob{}a \PYGZhy{}\PYGZgt{} c, b \PYGZhy{}\PYGZgt{} c, ...\PYGZcb{} is not a permutation, since a and b map to the same letter.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}a\PYGZdq{},\PYGZdq{}b\PYGZdq{},\PYGZdq{}c\PYGZdq{}], pattern = \PYGZdq{}a\PYGZdq{}
Output: [\PYGZdq{}a\PYGZdq{},\PYGZdq{}b\PYGZdq{},\PYGZdq{}c\PYGZdq{}]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= pattern.length \textless{}= 20}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= words.length \textless{}= 50}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{words{[}i{]}.length == pattern.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pattern}} and \sphinxcode{\sphinxupquote{words{[}i{]}}} are lowercase English letters.

\end{itemize}


\subsection{Solution: Construct the bijection and check the condition}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:solution-construct-the-bijection-and-check-the-condition}}

\subsubsection{Code}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{findAndReplacePattern}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{pattern}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{    }\PYG{c+c1}{// need two maps for the bijection}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{p\PYGZus{}to\PYGZus{}w}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{p\PYGZus{}to\PYGZus{}w}\PYG{p}{.}\PYG{n}{clear}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// w[i] was mapped to some letter x}
\PYG{+w}{                }\PYG{c+c1}{// but x != pattern[i]}
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{[}\PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pattern}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{p\PYGZus{}to\PYGZus{}w}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{pattern}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{p\PYGZus{}to\PYGZus{}w}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{c+c1}{// w[i] was not mapped to any letter yet}
\PYG{+w}{                    }\PYG{c+c1}{// but pattern[i] was already mapped to some letter}
\PYG{+w}{                    }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{                }\PYG{c+c1}{// build the bijection w[i] \PYGZlt{}\PYGZhy{}\PYGZgt{} pattern[i]}
\PYG{+w}{                }\PYG{n}{w\PYGZus{}to\PYGZus{}p}\PYG{p}{[}\PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pattern}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{p\PYGZus{}to\PYGZus{}w}\PYG{p}{[}\PYG{n}{pattern}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deq}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{mee}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aqq}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{dkd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ccc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findAndReplacePattern}\PYG{p}{(}\PYG{n}{words}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{findAndReplacePattern}\PYG{p}{(}\PYG{n}{words}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[mee,aqq,]
[a,b,c,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(NL)}}, where \sphinxcode{\sphinxupquote{N = words.length}} and \sphinxcode{\sphinxupquote{L = pattern.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}. The maps \sphinxcode{\sphinxupquote{w\_to\_p}} and \sphinxcode{\sphinxupquote{p\_to\_w}} just map between 26 lowercase English letters.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Hash_Table/890_Find_and_Replace_Pattern:key-takeaway}}
\sphinxAtStartPar
This solution efficiently finds and returns words from a vector of strings that match a given pattern in terms of character bijection. It uses two unordered maps to establish and maintain the bijection while iterating through the characters of the words and the pattern.


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{String}
\label{\detokenize{String/index:string}}\label{\detokenize{String/index::doc}}
\sphinxAtStartPar
In this chapter, we’ll learn about the importance of \sphinxstylestrong{strings} in programming. Strings help us work with text and are essential for many tasks, from processing data to creating better communication between programs and people. By understanding strings, you’ll be better equipped to solve problems and make things easier for users.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Understanding Strings:} Lay the groundwork by comprehending the nature of strings, character encoding schemes, and the basics of representing and storing textual data.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{String Manipulation:} Explore the art of string manipulation, covering operations like concatenation, slicing, reversing, and converting cases.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{String Searching and Pattern Matching:} Delve into strategies for finding substrings, detecting patterns, and performing advanced search operations within strings.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Anagrams and Palindromes:} Tackle challenges related to anagrams and palindromes, honing your ability to discern permutations and symmetric constructs.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Strings:} Learn how to approach coding problems that involve string manipulation, from simple tasks to intricate algorithms.

\end{enumerate}

\sphinxstepscope


\section{Valid Anagram}
\label{\detokenize{String/242_Valid_Anagram:valid-anagram}}\label{\detokenize{String/242_Valid_Anagram::doc}}

\subsection{Problem statement}
\label{\detokenize{String/242_Valid_Anagram:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/valid\sphinxhyphen{}anagram/
%
\end{footnote}You are given two strings, \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}}. Your task is to determine whether \sphinxcode{\sphinxupquote{t}} is an anagram of \sphinxcode{\sphinxupquote{s}}. If \sphinxcode{\sphinxupquote{t}} is an anagram of \sphinxcode{\sphinxupquote{s}}, return \sphinxcode{\sphinxupquote{true}}; otherwise, return \sphinxcode{\sphinxupquote{false}}.

\sphinxAtStartPar
An \sphinxstylestrong{anagram} is a term that describes a word or phrase formed by rearranging the letters of another word or phrase, typically using all the original letters exactly once.


\subsubsection{Example 1}
\label{\detokenize{String/242_Valid_Anagram:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}anagram\PYGZdq{}, t = \PYGZdq{}nagaram\PYGZdq{}
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/242_Valid_Anagram:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}rat\PYGZdq{}, t = \PYGZdq{}car\PYGZdq{}
Output: false
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/242_Valid_Anagram:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length, t.length \textless{}= 5 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}} consist of lowercase English letters.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{String/242_Valid_Anagram:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

\end{itemize}


\subsection{Solution 1: Rearrange both \sphinxstyleliteralintitle{\sphinxupquote{s}} and \sphinxstyleliteralintitle{\sphinxupquote{t}} into a sorted string}
\label{\detokenize{String/242_Valid_Anagram:solution-1-rearrange-both-s-and-t-into-a-sorted-string}}

\subsubsection{Code}
\label{\detokenize{String/242_Valid_Anagram:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isAnagram}\PYG{p}{(}\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// anagrams must have the same length}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{t}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{anagram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nagaram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{car}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution determines if two strings are anagrams by comparing their sorted versions. If the sorted versions are equal, the original strings are anagrams, and the function returns \sphinxcode{\sphinxupquote{true}}. Otherwise, it returns \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Complexity}
\label{\detokenize{String/242_Valid_Anagram:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(NlogN)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Count the appearances of each letter}
\label{\detokenize{String/242_Valid_Anagram:solution-2-count-the-appearances-of-each-letter}}

\subsubsection{Code}
\label{\detokenize{String/242_Valid_Anagram:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isAnagram}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// s and t consist of only lowercase English letters}
\PYG{+w}{    }\PYG{c+c1}{// you can encode 0: \PYGZsq{}a\PYGZsq{}, 1: \PYGZsq{}b\PYGZsq{}, .., 25: \PYGZsq{}z\PYGZsq{}.}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{alphabet}\PYG{p}{[}\PYG{l+m+mi}{26}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{26}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// count the frequency of each letter in s}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// if s and t have the same length but are not anagrams,}
\PYG{+w}{        }\PYG{c+c1}{// there must be some letter in t having higher frequency than s }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}\PYG{+w}{    }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{anagram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nagaram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{car}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently determines if two strings are anagrams by counting the frequency of each character in both strings using an array. If the character frequencies match for both strings, they are anagrams.


\subsubsection{Complexity}
\label{\detokenize{String/242_Valid_Anagram:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 3: If the inputs contain Unicode characters}
\label{\detokenize{String/242_Valid_Anagram:solution-3-if-the-inputs-contain-unicode-characters}}
\sphinxAtStartPar
Replace the array \sphinxcode{\sphinxupquote{alphabet}} in Solution 2 with a map.


\subsubsection{Code}
\label{\detokenize{String/242_Valid_Anagram:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isAnagram}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// this alphabet can store all UTF\PYGZhy{}8 characters}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{alphabet}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{alphabet}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}\PYG{+w}{    }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{anagram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{nagaram}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isAnagram}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{rat}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{car}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/242_Valid_Anagram:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(c)}} where \sphinxcode{\sphinxupquote{c}} represents the number of unique characters present in both strings \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{String/242_Valid_Anagram:key-takeaway}}
\sphinxAtStartPar
Instead of relying on a fixed\sphinxhyphen{}size array like the ASCII\sphinxhyphen{}based solutions, Solution 3 uses an \sphinxcode{\sphinxupquote{unordered\_map}} to store character frequencies. Each character is used as a key in the map, and the count of occurrences is stored as the associated value.

\sphinxAtStartPar
Unicode characters values are not restricted to a specific range. The \sphinxcode{\sphinxupquote{unordered\_map}} approach accommodates this variability by allowing any character to be a key.


\subsection{Exercise}
\label{\detokenize{String/242_Valid_Anagram:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/}{Find Resultant Array After Removing Anagrams}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Detect Capital}
\label{\detokenize{String/520_Detect_Capital:detect-capital}}\label{\detokenize{String/520_Detect_Capital::doc}}

\subsection{Problem statement}
\label{\detokenize{String/520_Detect_Capital:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/detect\sphinxhyphen{}capital/
%
\end{footnote}The task is to determine if the usage of capital letters in a given string, \sphinxcode{\sphinxupquote{word}}, is correct according to the following rules:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
All letters in the word are capital, like “USA”.

\item {} 
\sphinxAtStartPar
All letters in the word are not capital, like “leetcode”.

\item {} 
\sphinxAtStartPar
Only the first letter in the word is capital, like “Google”.

\end{enumerate}

\sphinxAtStartPar
If the capitalization in the given word adheres to these rules, the function should return \sphinxcode{\sphinxupquote{true}}; otherwise, it should return \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Example 1}
\label{\detokenize{String/520_Detect_Capital:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: word = \PYGZdq{}USA\PYGZdq{}
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/520_Detect_Capital:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: word = \PYGZdq{}FlaG\PYGZdq{}
Output: false
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/520_Detect_Capital:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= word.length \textless{}= 100}},

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{word}} consists of lowercase and uppercase English letters.

\end{itemize}


\subsection{Solution}
\label{\detokenize{String/520_Detect_Capital:solution}}
\sphinxAtStartPar
Only when the first two characters of the \sphinxcode{\sphinxupquote{word}} are uppercase, the rest must be the same.
Otherwise, the rest is always lowercase.


\subsubsection{Code}
\label{\detokenize{String/520_Detect_Capital:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{c+c1}{//! @return true if (c is lowercase and isLower is true) }
\PYG{c+c1}{//!                 or (c is uppercase and isLower is false).}
\PYG{c+c1}{//!         false, otherwise. }
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isValidCase}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{char}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{isLower}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isLower}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{A}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{Z}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{detectCapitalUse}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{word}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{isLower}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{c+c1}{// if the first two characters are uppercase,}
\PYG{+w}{    }\PYG{c+c1}{// the rest must be uppercase, too.}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isValidCase}\PYG{p}{(}\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{isValidCase}\PYG{p}{(}\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{isLower}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{isValidCase}\PYG{p}{(}\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{isLower}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{detectCapitalUse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{USA}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{detectCapitalUse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{FlaG}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{detectCapitalUse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leetcode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{detectCapitalUse}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Google}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/520_Detect_Capital:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = word.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{String/520_Detect_Capital:key-takeaway}}
\sphinxAtStartPar
This solution efficiently checks whether a given word follows one of the specified capitalization rules by iterating through the characters of the word and using the \sphinxcode{\sphinxupquote{isValidCase}} function to validate each character’s capitalization based on the current capitalization type (\sphinxcode{\sphinxupquote{isLower}}). If no violations are found, the word is considered valid, and the function returns \sphinxcode{\sphinxupquote{true}}.


\subsection{Exercise}
\label{\detokenize{String/520_Detect_Capital:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/capitalize-the-title/}{Capitalize the Title}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Unique Morse Code Words}
\label{\detokenize{String/804_Unique_Morse_Code_Words:unique-morse-code-words}}\label{\detokenize{String/804_Unique_Morse_Code_Words::doc}}\index{Morse Code@\spxentry{Morse Code}}

\subsection{Problem statement}
\label{\detokenize{String/804_Unique_Morse_Code_Words:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/unique\sphinxhyphen{}morse\sphinxhyphen{}code\sphinxhyphen{}words/
%
\end{footnote}The problem involves the International Morse Code, which defines a standard way to encode letters with dots and dashes. Each English letter corresponds to a specific sequence in Morse Code, and a full table mapping each letter is provided.

\sphinxAtStartPar
For instance, \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}} is encoded as \sphinxcode{\sphinxupquote{".\sphinxhyphen{}"}}, \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}} as \sphinxcode{\sphinxupquote{"\sphinxhyphen{}..."}}, and so on.

\sphinxAtStartPar
The full table for the \sphinxcode{\sphinxupquote{26}} letters of the English alphabet is given below:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZdq{}.\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}...\PYGZdq{}, \PYGZdq{}\PYGZhy{}.\PYGZhy{}.\PYGZdq{}, \PYGZdq{}\PYGZhy{}..\PYGZdq{}, \PYGZdq{}.\PYGZdq{}, \PYGZdq{}..\PYGZhy{}.\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}.\PYGZdq{},
\PYGZdq{}....\PYGZdq{}, \PYGZdq{}..\PYGZdq{}, \PYGZdq{}.\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}.\PYGZhy{}\PYGZdq{}, \PYGZdq{}.\PYGZhy{}..\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}.\PYGZdq{},
\PYGZdq{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}.\PYGZhy{}\PYGZhy{}.\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}.\PYGZhy{}\PYGZdq{}, \PYGZdq{}.\PYGZhy{}.\PYGZdq{}, \PYGZdq{}...\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}..\PYGZhy{}\PYGZdq{},
\PYGZdq{}...\PYGZhy{}\PYGZdq{}, \PYGZdq{}.\PYGZhy{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}..\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}.\PYGZhy{}\PYGZhy{}\PYGZdq{}, \PYGZdq{}\PYGZhy{}\PYGZhy{}..\PYGZdq{}]
\end{sphinxVerbatim}

\sphinxAtStartPar
You are given an array of strings named \sphinxcode{\sphinxupquote{words}}, where each word can be represented as a concatenation of the Morse code for each of its letters. For example, the word \sphinxcode{\sphinxupquote{"cab"}} can be represented as \sphinxcode{\sphinxupquote{"\sphinxhyphen{}.\sphinxhyphen{}..\sphinxhyphen{}\sphinxhyphen{}..."}}, which is the concatenation of \sphinxcode{\sphinxupquote{"\sphinxhyphen{}.\sphinxhyphen{}."}}, \sphinxcode{\sphinxupquote{".\sphinxhyphen{}"}}, and \sphinxcode{\sphinxupquote{"\sphinxhyphen{}..."}}. This concatenated Morse code representation is referred to as the “transformation” of a word.

\sphinxAtStartPar
Your task is to count the number of different transformations that can be obtained from all the words in the given array.


\subsubsection{Example 1}
\label{\detokenize{String/804_Unique_Morse_Code_Words:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}gin\PYGZdq{},\PYGZdq{}zen\PYGZdq{},\PYGZdq{}gig\PYGZdq{},\PYGZdq{}msg\PYGZdq{}]
Output: 2
Explanation: The transformation of each word is:
\PYGZdq{}gin\PYGZdq{} \PYGZhy{}\PYGZgt{} \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}.\PYGZdq{}
\PYGZdq{}zen\PYGZdq{} \PYGZhy{}\PYGZgt{} \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}.\PYGZdq{}
\PYGZdq{}gig\PYGZdq{} \PYGZhy{}\PYGZgt{} \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}\PYGZhy{}.\PYGZdq{}
\PYGZdq{}msg\PYGZdq{} \PYGZhy{}\PYGZgt{} \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}\PYGZhy{}.\PYGZdq{}
There are 2 different transformations: \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}.\PYGZdq{} and \PYGZdq{}\PYGZhy{}\PYGZhy{}...\PYGZhy{}\PYGZhy{}.\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/804_Unique_Morse_Code_Words:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}a\PYGZdq{}]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/804_Unique_Morse_Code_Words:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= words.length \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= words{[}i{]}.length \textless{}= 12}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{words{[}i{]}}} consists of lowercase English letters.

\end{itemize}


\subsection{Solution: Store the transformations in a set}
\label{\detokenize{String/804_Unique_Morse_Code_Words:solution-store-the-transformations-in-a-set}}

\subsubsection{Code}
\label{\detokenize{String/804_Unique_Morse_Code_Words:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}set\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{morse}\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}.\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}..}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{..\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{....}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{..}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}.\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}..}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}.\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}.}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{..\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{    }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{...\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{.\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}..\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}.\PYGZhy{}\PYGZhy{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}\PYGZhy{}..}\PYG{l+s}{\PYGZdq{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{uniqueMorseRepresentations}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}set}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{transformations}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{w}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{string}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{w}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// concatnate the letter c\PYGZsq{}s Morse code}
\PYG{+w}{            }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{morse}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// only insert the transformation s to the set }
\PYG{+w}{        }\PYG{c+c1}{// if the set did not consist s yet.}
\PYG{+w}{        }\PYG{n}{transformations}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{transformations}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gin}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{zen}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{gig}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{msg}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniqueMorseRepresentations}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniqueMorseRepresentations}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/804_Unique_Morse_Code_Words:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*M)}}, where \sphinxcode{\sphinxupquote{N = words.length}} and \sphinxcode{\sphinxupquote{M = words{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{String/804_Unique_Morse_Code_Words:key-takeaway}}
\sphinxAtStartPar
This solution converts each word into Morse code based on a predefined mapping and uses an unordered set to keep track of unique representations. By inserting each representation into the set, it automatically filters out duplicates. The final result is the size of the set, which represents the number of unique Morse code representations among the input words.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Unique Email Addresses}
\label{\detokenize{String/929_Unique_Email_Addresses:unique-email-addresses}}\label{\detokenize{String/929_Unique_Email_Addresses::doc}}

\subsection{Problem statement}
\label{\detokenize{String/929_Unique_Email_Addresses:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/unique\sphinxhyphen{}email\sphinxhyphen{}addresses/
%
\end{footnote}Each valid email address is composed of a local name and a domain name, separated by the \sphinxcode{\sphinxupquote{\textquotesingle{}@\textquotesingle{}}} sign. The local name may contain lowercase letters, one or more \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}} characters, and a plus \sphinxcode{\sphinxupquote{\textquotesingle{}+\textquotesingle{}}} sign. However, the rules for dots and the plus sign do not apply to the domain name.

\sphinxAtStartPar
For example, in the email \sphinxcode{\sphinxupquote{"alice@leetcode.com"}}, \sphinxcode{\sphinxupquote{"alice"}} is the local name, and \sphinxcode{\sphinxupquote{"leetcode.com"}} is the domain name.

\sphinxAtStartPar
If you insert periods \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}} between certain characters in the local name, the email will still be forwarded to the same address without the dots in the local name. This rule does not apply to the domain name.

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{"alice.z@leetcode.com"}} and \sphinxcode{\sphinxupquote{"alicez@leetcode.com"}} both forward to the same email address.

\sphinxAtStartPar
If you include a plus \sphinxcode{\sphinxupquote{\textquotesingle{}+\textquotesingle{}}} sign in the local name, everything after the first plus sign is ignored, allowing for email filtering. This rule also does not apply to the domain name.

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{"m.y+name@email.com"}} will be forwarded to \sphinxcode{\sphinxupquote{"my@email.com"}}.

\sphinxAtStartPar
It is possible to use both of these rules at the same time.

\sphinxAtStartPar
Given an array of strings \sphinxcode{\sphinxupquote{emails}}, where each element is an email address to which an email is sent, your task is to determine the number of different addresses that will actually receive the emails after applying the rules described above.


\subsubsection{Example 1}
\label{\detokenize{String/929_Unique_Email_Addresses:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: emails = [\PYGZdq{}test.email+alex@leetcode.com\PYGZdq{},\PYGZdq{}test.e.mail+bob.cathy@leetcode.com\PYGZdq{},\PYGZdq{}testemail+david@lee.tcode.com\PYGZdq{}]
Output: 2
Explanation: \PYGZdq{}testemail@leetcode.com\PYGZdq{} and \PYGZdq{}testemail@lee.tcode.com\PYGZdq{} actually receive mails.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/929_Unique_Email_Addresses:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: emails = [\PYGZdq{}a@leetcode.com\PYGZdq{},\PYGZdq{}b@leetcode.com\PYGZdq{},\PYGZdq{}c@leetcode.com\PYGZdq{}]
Output: 3
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/929_Unique_Email_Addresses:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= emails.length \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= emails{[}i{]}.length \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{emails{[}i{]}}} consist of lowercase English letters, \sphinxcode{\sphinxupquote{\textquotesingle{}+\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}} and \sphinxcode{\sphinxupquote{\textquotesingle{}@\textquotesingle{}}}.

\item {} 
\sphinxAtStartPar
Each \sphinxcode{\sphinxupquote{emails{[}i{]}}} contains exactly one \sphinxcode{\sphinxupquote{\textquotesingle{}@\textquotesingle{}}} character.

\item {} 
\sphinxAtStartPar
All local and domain names are non\sphinxhyphen{}empty.

\item {} 
\sphinxAtStartPar
Local names do not start with a \sphinxcode{\sphinxupquote{\textquotesingle{}+\textquotesingle{}}} character.

\item {} 
\sphinxAtStartPar
Domain names end with the \sphinxcode{\sphinxupquote{".com"}} suffix.

\end{itemize}


\subsection{Solution 1: Removing the ignored characters}
\label{\detokenize{String/929_Unique_Email_Addresses:solution-1-removing-the-ignored-characters}}
\sphinxAtStartPar
Do exactly the steps the problem describes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Extract the local name.

\item {} 
\sphinxAtStartPar
Ignore all characters after \sphinxcode{\sphinxupquote{\textquotesingle{}+\textquotesingle{}}} in it.

\item {} 
\sphinxAtStartPar
Ignore all \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}} in it.

\item {} 
\sphinxAtStartPar
Combine the local name with the domain one to form the clean email address.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{String/929_Unique_Email_Addresses:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}set\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{numUniqueEmails}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}set}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{e}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{apos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{@}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// extract the local name}
\PYG{+w}{        }\PYG{n}{string}\PYG{+w}{ }\PYG{n}{local}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{apos}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// ignore all characters after \PYGZsq{}+\PYGZsq{}}
\PYG{+w}{        }\PYG{n}{local}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{local}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{local}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{+}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{local}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{:}\PYG{o}{:}\PYG{n}{npos}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// remove each \PYGZsq{}.\PYGZsq{} found in local}
\PYG{+w}{            }\PYG{n}{local}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{it}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{local}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// combine local name with domain one}
\PYG{+w}{        }\PYG{n}{s}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{local}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{apos}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email+alex@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                        }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.e.mail+bob.cathy@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                        }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{testemail+david@lee.tcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{emails}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{emails}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email+alex@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email.leet+alex@code.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution parses a list of email addresses, normalizes each email address by removing periods and ignoring characters after the plus sign in the local name, and then counts the number of unique email addresses. The use of an unordered set ensures that only unique email addresses are counted.


\subsubsection{Complexity}
\label{\detokenize{String/929_Unique_Email_Addresses:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*M\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{N = emails.length}} and \sphinxcode{\sphinxupquote{M = max(emails{[}i{]}.length)}}. Explanation: you loop over \sphinxcode{\sphinxupquote{N}} emails. Then you might loop over the length of each email, \sphinxcode{\sphinxupquote{O(M)}}, to remove the character \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}}. The removal might cost \sphinxcode{\sphinxupquote{O(M)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N*M)}} (the set of emails).

\end{itemize}


\subsection{Solution 2: Building the clean email addresses from scratch}
\label{\detokenize{String/929_Unique_Email_Addresses:solution-2-building-the-clean-email-addresses-from-scratch}}
\sphinxAtStartPar
The runtime of removing characters in \sphinxcode{\sphinxupquote{std::string}} is not constant. To avoid that complexity you can build up the clean email addresses from scratch.


\subsubsection{Code}
\label{\detokenize{String/929_Unique_Email_Addresses:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}set\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{numUniqueEmails}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}set}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{e}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{string}\PYG{+w}{ }\PYG{n}{address}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// the local name ends here}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{@}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{+}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// ignore each \PYGZsq{}.\PYGZsq{} found}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{k}{continue}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{c+c1}{// add valid characters to local name}
\PYG{+w}{            }\PYG{n}{address}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{                  }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// combine local name with domain one}
\PYG{+w}{        }\PYG{n}{address}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{@}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{        }\PYG{n}{s}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{address}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{        }
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{emails}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email+alex@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                        }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.e.mail+bob.cathy@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
\PYG{+w}{                        }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{testemail+david@lee.tcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{emails}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{emails}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email+alex@leetcode.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{test.email.leet+alex@code.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numUniqueEmails}\PYG{p}{(}\PYG{n}{emails}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
3
2
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/929_Unique_Email_Addresses:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*M)}}, where \sphinxcode{\sphinxupquote{N = emails.length}} and \sphinxcode{\sphinxupquote{M = max(emails{[}i{]}.length)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N*M)}}.

\end{itemize}


\subsection{C++ Notes}
\label{\detokenize{String/929_Unique_Email_Addresses:c-notes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
A \sphinxcode{\sphinxupquote{string}} can be concatenated with a \sphinxcode{\sphinxupquote{char}} and another \sphinxcode{\sphinxupquote{string}} by \sphinxcode{\sphinxupquote{+}} operator.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{address}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{address}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{@}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}\PYG{+w}{             }\PYG{c+c1}{// \PYGZdq{}name@\PYGZdq{}}
\PYG{n}{address}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{domain.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}\PYG{+w}{    }\PYG{c+c1}{// \PYGZdq{}name@domain.com\PYGZdq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://en.cppreference.com/w/cpp/string/basic\_string/substr}{string::substr(pos = 0, count = npos)} returns the substring of length \sphinxcode{\sphinxupquote{count}} starting from the position \sphinxcode{\sphinxupquote{pos}} of the string \sphinxcode{\sphinxupquote{string}}.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}\PYG{+w}{ }\PYG{n}{address}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{name@domain.com}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{address}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{n}{address}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{      }\PYG{c+c1}{// \PYGZdq{}.com\PYGZdq{}}
\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{address}\PYG{p}{.}\PYG{n}{substr}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{address}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{@}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{   }\PYG{c+c1}{// \PYGZdq{}name\PYGZdq{}}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://en.cppreference.com/w/cpp/string/basic\_string/find}{string::find(char, pos=0)} returns the position of the first \sphinxcode{\sphinxupquote{char}} which appears in the string \sphinxcode{\sphinxupquote{string}} starting from \sphinxcode{\sphinxupquote{pos}}.

\end{itemize}


\subsection{High\sphinxhyphen{}performance C++}
\label{\detokenize{String/929_Unique_Email_Addresses:high-performance-c}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Do not use \sphinxcode{\sphinxupquote{std::set}} or \sphinxcode{\sphinxupquote{std::map}} unless you want the keys to be \sphinxstyleemphasis{in order} (\sphinxstyleemphasis{sorted}). Use \sphinxstyleemphasis{unordered containers} like \sphinxhref{https://en.cppreference.com/w/cpp/container/unordered\_set}{std::unordered\_set} or \sphinxhref{https://en.cppreference.com/w/cpp/container/unordered\_map}{std::unordered\_map} instead. They use hashed keys for faster lookup.

\item {} 
\sphinxAtStartPar
Do not blindly/lazily use \sphinxcode{\sphinxupquote{string.find(something)}}. If you know where to start the search, use \sphinxcode{\sphinxupquote{string.find(something, pos)}} with a \sphinxstylestrong{specific} \sphinxcode{\sphinxupquote{pos}}.

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Longest Substring Without Repeating Characters}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:longest-substring-without-repeating-characters}}\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters::doc}}

\subsection{Problem statement}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/longest\sphinxhyphen{}substring\sphinxhyphen{}without\sphinxhyphen{}repeating\sphinxhyphen{}characters/
%
\end{footnote}Given a string \sphinxcode{\sphinxupquote{s}}, your task is to determine the length of the longest substring within \sphinxcode{\sphinxupquote{s}} that does not contain any repeating characters.


\subsubsection{Example 1}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}abcabcbb\PYGZdq{}
Output: 3
Explanation: The answer is \PYGZdq{}abc\PYGZdq{}, with a length of 3.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}bbbbb\PYGZdq{}
Output: 1
Explanation: The answer is \PYGZdq{}b\PYGZdq{}, with the length of 1.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}pwwkew\PYGZdq{}
Output: 3
Explanation: The answer is \PYGZdq{}wke\PYGZdq{}, with a length of 3.
Notice that the answer must be a substring, \PYGZdq{}pwke\PYGZdq{} is a subsequence and not a substring.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= s.length \textless{}= 5 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} consists of English letters, digits, symbols and spaces.

\end{itemize}


\subsection{Solution: Store the position of the visited characters}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:solution-store-the-position-of-the-visited-characters}}
\sphinxAtStartPar
Whenever you meet a visited character \sphinxcode{\sphinxupquote{s{[}i{]} == s{[}j{]}}} for some \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{} j \textless{} s.length}}, the substring \sphinxcode{\sphinxupquote{"s{[}i{]}...s{[}j \sphinxhyphen{} 1{]}"}} might be valid, i.e., it consists of only nonrepeating characters.

\sphinxAtStartPar
But in case you meet another visited character \sphinxcode{\sphinxupquote{s{[}x{]} == s{[}y{]}}} where \sphinxcode{\sphinxupquote{x \textless{} i \textless{} j \textless{} y}}, the substring \sphinxcode{\sphinxupquote{"s{[}x{]}...s{[}y \sphinxhyphen{} 1{]}"}} is not valid because it consists of repeated character \sphinxcode{\sphinxupquote{s{[}i{]} == s{[}j{]}}}.

\sphinxAtStartPar
That shows the substring \sphinxcode{\sphinxupquote{"s{[}i{]}...s{[}j \sphinxhyphen{} 1{]}"}} is not always a valid one. You might need to find the right starting position \sphinxcode{\sphinxupquote{start \textgreater{}= i}} for the valid substring \sphinxcode{\sphinxupquote{"s{[}start{]}...s{[}j \sphinxhyphen{} 1{]}"}}.


\subsubsection{Example 4}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:example-4}}
\sphinxAtStartPar
For the string \sphinxcode{\sphinxupquote{s = "babba"}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
When you visit the second letter \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}}, the substring \sphinxcode{\sphinxupquote{"ba"}} is a valid one.

\item {} 
\sphinxAtStartPar
When you visit the third letter \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}}, the substring of interest should be started by the second letter \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}}. It gives you the substring \sphinxcode{\sphinxupquote{"b"}}.

\item {} 
\sphinxAtStartPar
When you visit the second letter \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}}, the substring \sphinxcode{\sphinxupquote{"abb"}} is not a valid one since \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}} is repeated. To ensure no repetition, the starting position for this substring should be the latter \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}}, which leads to the valid substring \sphinxcode{\sphinxupquote{"b"}}.

\item {} 
\sphinxAtStartPar
The final longest valid substring is \sphinxcode{\sphinxupquote{"ba"}} with length 2.

\end{itemize}

\sphinxAtStartPar
Example 4 shows the starting position \sphinxcode{\sphinxupquote{start}} for the substring of interest \sphinxcode{\sphinxupquote{"s{[}i{]}...s{[}j \sphinxhyphen{} 1{]}"}} should be:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
this\PYGZus{}start = max(previous\PYGZus{}start, i).
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{lengthOfLongestSubstring}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// keep track latest index of a character in s}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// posible maximum length of the longest substring}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxLen}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// starting index of current substring}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{s}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// found this s[i] has appeared in the map}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{position}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// start a new substring from this index i}
\PYG{+w}{            }\PYG{n}{start}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{c+c1}{// update latest found position of character s[i] to be i}
\PYG{+w}{            }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{            }\PYG{c+c1}{// keep track index of s[i] in the map}
\PYG{+w}{            }\PYG{n}{position}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{s}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// update the maximum length}
\PYG{+w}{        }\PYG{n}{maxLen}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxLen}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxLen}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lengthOfLongestSubstring}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcabcbb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lengthOfLongestSubstring}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bbbbb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lengthOfLongestSubstring}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pwwkew}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
1
3
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:key-takeaway}}
\sphinxAtStartPar
This solution utilizes a \index{sliding window@\spxentry{sliding window}}sliding window approach to track the starting index of the current substring and an unordered map to store the position of the characters encountered so far. By updating the starting index when a repeating character is encountered, it ensures that the current substring contains only unique characters.

\sphinxAtStartPar
This approach optimizes the computation of the length of the longest substring by handling the sliding window and updating the length accordingly, resulting in an overall efficient solution.


\subsection{Exercise}
\label{\detokenize{String/3_Longest_Substring_Without_Repeating_Characters:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/optimal-partition-of-string/}{Optimal Partition of String}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Compare Version Numbers}
\label{\detokenize{String/165_Compare_Version_Numbers:compare-version-numbers}}\label{\detokenize{String/165_Compare_Version_Numbers::doc}}

\subsection{Problem statement}
\label{\detokenize{String/165_Compare_Version_Numbers:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/compare\sphinxhyphen{}version\sphinxhyphen{}numbers/
%
\end{footnote}Given two version numbers, \sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}}, your task is to compare them.

\sphinxAtStartPar
Version numbers consist of one or more revisions joined by a dot \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}}. Each revision is composed of digits and may contain leading zeros. Each revision has at least one character. Revisions are indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on.

\sphinxAtStartPar
For instance, \sphinxcode{\sphinxupquote{2.5.33}} and \sphinxcode{\sphinxupquote{0.1}} are valid version numbers.

\sphinxAtStartPar
To compare version numbers, you should compare their revisions in left\sphinxhyphen{}to\sphinxhyphen{}right order. Revisions are compared using their integer value, ignoring any leading zeros. This means that revisions \sphinxcode{\sphinxupquote{1}} and \sphinxcode{\sphinxupquote{001}} are considered equal. If a version number does not specify a revision at a particular index, treat that revision as \sphinxcode{\sphinxupquote{0}}. For example, version \sphinxcode{\sphinxupquote{1.0}} is less than version \sphinxcode{\sphinxupquote{1.1}} because their revision 0s are the same, but their revision 1s are \sphinxcode{\sphinxupquote{0}} and \sphinxcode{\sphinxupquote{1}} respectively, and \sphinxcode{\sphinxupquote{0}} is less than \sphinxcode{\sphinxupquote{1}}.

\sphinxAtStartPar
The function should return the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{version1}} is less than \sphinxcode{\sphinxupquote{version2}}, return \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}.

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{version1}} is greater than \sphinxcode{\sphinxupquote{version2}}, return \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}} are equal, return \sphinxcode{\sphinxupquote{0}}.

\end{itemize}


\subsubsection{Example 1}
\label{\detokenize{String/165_Compare_Version_Numbers:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: version1 = \PYGZdq{}1.01\PYGZdq{}, version2 = \PYGZdq{}1.001\PYGZdq{}
Output: 0
Explanation: Ignoring leading zeroes, both \PYGZdq{}01\PYGZdq{} and \PYGZdq{}001\PYGZdq{} represent the same integer \PYGZdq{}1\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{String/165_Compare_Version_Numbers:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: version1 = \PYGZdq{}1.0\PYGZdq{}, version2 = \PYGZdq{}1.0.0\PYGZdq{}
Output: 0
Explanation: version1 does not specify revision 2, which means it is treated as \PYGZdq{}0\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{String/165_Compare_Version_Numbers:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: version1 = \PYGZdq{}0.1\PYGZdq{}, version2 = \PYGZdq{}1.1\PYGZdq{}
Output: \PYGZhy{}1
Explanation: version1\PYGZsq{}s revision 0 is \PYGZdq{}0\PYGZdq{}, while version2\PYGZsq{}s revision 0 is \PYGZdq{}1\PYGZdq{}. 0 \PYGZlt{} 1, so version1 \PYGZlt{} version2.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{String/165_Compare_Version_Numbers:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= version1.length, version2.length \textless{}= 500}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}} only contain digits and \sphinxcode{\sphinxupquote{\textquotesingle{}.\textquotesingle{}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}} are valid version numbers.

\item {} 
\sphinxAtStartPar
All the given revisions in \sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}} can be stored in a 32\sphinxhyphen{}bit integer.

\end{itemize}


\subsection{Solution}
\label{\detokenize{String/165_Compare_Version_Numbers:solution}}
\sphinxAtStartPar
Each version can be considered as an array of revisions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
version = revisions[0].revisions[1].revisions[2]....
\end{sphinxVerbatim}

\sphinxAtStartPar
The problem is to compare each \sphinxcode{\sphinxupquote{revisions{[}i{]}}} between two versions.

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{revisions{[}0{]}}} of \sphinxcode{\sphinxupquote{version1}} is less than of \sphinxcode{\sphinxupquote{version2}} in Example 3. So the result is \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}.

\sphinxAtStartPar
All \sphinxcode{\sphinxupquote{revisions{[}i{]}}} of \sphinxcode{\sphinxupquote{version1}} and \sphinxcode{\sphinxupquote{version2}} are equal in Example 1. So the result is \sphinxcode{\sphinxupquote{0}}.

\sphinxAtStartPar
The number of revisions between the versions might not be equal (like in Example 2).

\sphinxAtStartPar
If all revisions of the shorter version are equal to the corresponding revisions of the longer one, the version having extra revisions and there exists a non\sphinxhyphen{}zero revision among them is the bigger one. Otherwise, the two versions are equal.


\subsubsection{Code}
\label{\detokenize{String/165_Compare_Version_Numbers:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{c+c1}{//! @return the vector of revisions of the version }
\PYG{c+c1}{//! @example if version = \PYGZdq{}1.02.11\PYGZdq{}, return \PYGZob{}1,2,11\PYGZcb{}}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{toVector}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{version}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{revisions}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{string}\PYG{+w}{ }\PYG{n}{revision}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{version}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{.}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// continue to build current revision }
\PYG{+w}{            }\PYG{n}{revision}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// current revision completes}
\PYG{+w}{            }\PYG{c+c1}{// uses stoi() to ignore leading zeros}
\PYG{+w}{            }\PYG{n}{revisions}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{revision}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{c+c1}{// start a new revision}
\PYG{+w}{            }\PYG{n}{revision}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{revisions}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{revision}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{revisions}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{compareVersion}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{version1}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{version2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{toVector}\PYG{p}{(}\PYG{n}{version1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{toVector}\PYG{p}{(}\PYG{n}{version2}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// perform the comparison on the revisions}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{r2}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{r2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{r1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{r2}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// if version1 is not longer than version2}
\PYG{+w}{        }\PYG{c+c1}{// and version2 still has some valid revisions remain}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{r2}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r2}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{r1}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{r1}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// if version2 is not longer than version1}
\PYG{+w}{        }\PYG{c+c1}{// and version1 still has some valid revisions remain}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{compareVersion}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.01}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.001}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{compareVersion}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.0.0}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{compareVersion}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{0.1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{1.1}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
0
0
\PYGZhy{}1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{String/165_Compare_Version_Numbers:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}} where \sphinxcode{\sphinxupquote{N = max(version1.length, version2.length)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{String/165_Compare_Version_Numbers:key-takeaway}}
\sphinxAtStartPar
This solution first converts the version strings into vectors of integers representing the individual components of the version numbers. This conversion is done by iterating through each character of the version string, accumulating digits until encountering a dot, at which point the accumulated integer is added to the revisions vector.

\sphinxAtStartPar
Once both version strings are converted into vectors, the function iterates through the vectors, comparing corresponding elements to determine the relationship between the versions. Additionally, it accounts for any remaining digits in the longer version string after the common components by summing them up and comparing the totals.

\sphinxAtStartPar
This approach simplifies the comparison process by breaking down the version strings into easily comparable components.


\subsubsection{C++ Notes}
\label{\detokenize{String/165_Compare_Version_Numbers:c-notes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\index{std::stoi@\spxentry{std::stoi}}std::stoi%
\begin{footnote}[2]\sphinxAtStartFootnote
https://en.cppreference.com/w/cpp/string/basic\_string/stol
%
\end{footnote} is used to convert a \sphinxcode{\sphinxupquote{string}} to an \sphinxcode{\sphinxupquote{int}}. It ignores the leading zeros for you.

\item {} 
\sphinxAtStartPar
\index{std::accumulate@\spxentry{std::accumulate}}std::accumulate%
\begin{footnote}[3]\sphinxAtStartFootnote
https://en.cppreference.com/w/cpp/algorithm/accumulate
%
\end{footnote} is used to compute the sum of a container.

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Stack}
\label{\detokenize{Stack/index:stack}}\label{\detokenize{Stack/index::doc}}
\sphinxAtStartPar
This chapter explores the \sphinxstylestrong{stack} data structure, a useful tool for managing data in a Last\sphinxhyphen{}In\sphinxhyphen{}First\sphinxhyphen{}Out (LIFO) way. We’ll investigate the basics of stacks and examine how they work using C++’s \sphinxtitleref{std::stack\textasciigrave{}} and \sphinxcode{\sphinxupquote{std::vector}} from the Standard Template Library (STL).

\sphinxAtStartPar
Stacks in programming are like a stack of books where you add and remove books from the top. They provide a structured way to manage data, making them ideal for handling temporary information, tracking function calls, and solving various algorithmic challenges.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Stacks:} Begin by understanding the core principles of stacks, their fundamental operations, and their real\sphinxhyphen{}world applications.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Leveraging \textasciigrave{}std::stack\textasciigrave{}:} Dive into the STL’s powerful \sphinxtitleref{std::stack} container, mastering its usage and versatility for stack\sphinxhyphen{}based operations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exploring \textasciigrave{}std::vector\textasciigrave{}:} Discover the capabilities of \sphinxtitleref{std::vector} in context with stacks, exploiting its dynamic array nature to create flexible stack structures.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stack Operations:} Explore operations such as \sphinxstylestrong{push} and \sphinxstylestrong{pop}, understanding their impact on the stack’s state and memory usage.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Balancing Parentheses:} Tackle the classic problem of parentheses balancing using stacks, a prime example of their utility in parsing and validation.

\end{enumerate}

\sphinxAtStartPar
As you progress through this chapter, you’ll learn about the importance of stacks and how \sphinxtitleref{std::stack} and \sphinxtitleref{std::vector} can help you solve problems more efficiently. By the end of the chapter, you’ll thoroughly understand the stack data structure’s Last\sphinxhyphen{}In\sphinxhyphen{}First\sphinxhyphen{}Out (LIFO) principle and how you can leverage \sphinxtitleref{std::stack} and \sphinxtitleref{std::vector} to manage data effectively. Let’s embark on this enlightening journey through stacks and uncover their potential for simplifying complex operations and algorithmic problems!

\sphinxstepscope


\section{Baseball Game}
\label{\detokenize{Stack/682_Baseball_Game:baseball-game}}\label{\detokenize{Stack/682_Baseball_Game::doc}}

\subsection{Problem statement}
\label{\detokenize{Stack/682_Baseball_Game:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/baseball\sphinxhyphen{}game/
%
\end{footnote}You are responsible for keeping score in a unique baseball game with special rules. The game involves multiple rounds where the scores of previous rounds can influence the scores of future rounds.

\sphinxAtStartPar
At the beginning of the game, your record is empty. You are given a list of operations called \sphinxcode{\sphinxupquote{ops}}, where each \sphinxcode{\sphinxupquote{ops{[}i{]}}} is one of the following:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
An integer \sphinxcode{\sphinxupquote{x}} \sphinxhyphen{} This represents recording a new score of \sphinxcode{\sphinxupquote{x}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"+"}} \sphinxhyphen{} This represents recording a new score that is the sum of the previous two scores. It is guaranteed that there will always be two previous scores.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"D"}} \sphinxhyphen{} This represents recording a new score that is double the previous score. It is guaranteed that there will always be a previous score.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"C"}} \sphinxhyphen{} This represents invalidating the previous score, removing it from the record. It is guaranteed that there will always be a previous score.

\end{enumerate}

\sphinxAtStartPar
Your task is to calculate and return the sum of all the scores in the record after performing all the operations.


\subsubsection{Example 1}
\label{\detokenize{Stack/682_Baseball_Game:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: ops = [\PYGZdq{}5\PYGZdq{},\PYGZdq{}2\PYGZdq{},\PYGZdq{}C\PYGZdq{},\PYGZdq{}D\PYGZdq{},\PYGZdq{}+\PYGZdq{}]
Output: 30
Explanation:
\PYGZdq{}5\PYGZdq{} \PYGZhy{} Add 5 to the record; the record is now [5].
\PYGZdq{}2\PYGZdq{} \PYGZhy{} Add 2 to the record; the record is now [5, 2].
\PYGZdq{}C\PYGZdq{} \PYGZhy{} Invalidate and remove the previous score; the record is now [5].
\PYGZdq{}D\PYGZdq{} \PYGZhy{} Add 2 * 5 = 10 to the record; the record is now [5, 10].
\PYGZdq{}+\PYGZdq{} \PYGZhy{} Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Stack/682_Baseball_Game:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: ops = [\PYGZdq{}5\PYGZdq{},\PYGZdq{}\PYGZhy{}2\PYGZdq{},\PYGZdq{}4\PYGZdq{},\PYGZdq{}C\PYGZdq{},\PYGZdq{}D\PYGZdq{},\PYGZdq{}9\PYGZdq{},\PYGZdq{}+\PYGZdq{},\PYGZdq{}+\PYGZdq{}]
Output: 27
Explanation:
\PYGZdq{}5\PYGZdq{} \PYGZhy{} Add 5 to the record; the record is now [5].
\PYGZdq{}\PYGZhy{}2\PYGZdq{} \PYGZhy{} Add \PYGZhy{}2 to the record; the record is now [5, \PYGZhy{}2].
\PYGZdq{}4\PYGZdq{} \PYGZhy{} Add 4 to the record; the record is now [5, \PYGZhy{}2, 4].
\PYGZdq{}C\PYGZdq{} \PYGZhy{} Invalidate and remove the previous score; the record is now [5, \PYGZhy{}2].
\PYGZdq{}D\PYGZdq{} \PYGZhy{} Add 2 * \PYGZhy{}2 = \PYGZhy{}4 to the record; the record is now [5, \PYGZhy{}2, \PYGZhy{}4].
\PYGZdq{}9\PYGZdq{} \PYGZhy{} Add 9 to the record; the record is now [5, \PYGZhy{}2, \PYGZhy{}4, 9].
\PYGZdq{}+\PYGZdq{} \PYGZhy{} Add \PYGZhy{}4 + 9 = 5 to the record, record is now [5, \PYGZhy{}2, \PYGZhy{}4, 9, 5].
\PYGZdq{}+\PYGZdq{} \PYGZhy{} Add 9 + 5 = 14 to the record, record is now [5, \PYGZhy{}2, \PYGZhy{}4, 9, 5, 14].
The total sum is 5 + \PYGZhy{}2 + \PYGZhy{}4 + 9 + 5 + 14 = 27.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Stack/682_Baseball_Game:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: ops = [\PYGZdq{}1\PYGZdq{}]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Stack/682_Baseball_Game:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= ops.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{ops{[}i{]}}} is \sphinxcode{\sphinxupquote{"C"}}, \sphinxcode{\sphinxupquote{"D"}}, \sphinxcode{\sphinxupquote{"+"}}, or a string representing an integer in the range \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}3 * 10\textasciicircum{}4, 3 * 10\textasciicircum{}4{]}}}.

\item {} 
\sphinxAtStartPar
For operation \sphinxcode{\sphinxupquote{"+"}}, there will always be at least two previous scores on the record.

\item {} 
\sphinxAtStartPar
For operations \sphinxcode{\sphinxupquote{"C"}} and \sphinxcode{\sphinxupquote{"D"}}, there will always be at least one previous score on the record.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Stack/682_Baseball_Game:solution}}

\subsubsection{Code}
\label{\detokenize{Stack/682_Baseball_Game:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{calPoints}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{ops}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{ops}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stk}\PYG{p}{[}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{[}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }\PYG{c+c1}{// s is an integer}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{stoi}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// compute the sum}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ops}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{calPoints}\PYG{p}{(}\PYG{n}{ops}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ops}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{5}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZhy{}2}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{4}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{C}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{D}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{9}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{+}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{calPoints}\PYG{p}{(}\PYG{n}{ops}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
30
27
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution simulates the baseball game by processing each round’s operation and maintaining a stack of valid points. It accurately calculates the final sum of valid points based on the given operations.


\subsubsection{Complexity}
\label{\detokenize{Stack/682_Baseball_Game:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = ops.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Implementation tips}
\label{\detokenize{Stack/682_Baseball_Game:implementation-tips}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The data structure \sphinxcode{\sphinxupquote{stk}} you might need to solve this problem is a stack. But here are the reasons you had better use \sphinxhref{https://en.cppreference.com/w/cpp/container/vector}{\sphinxcode{\sphinxupquote{std::vector}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{std::vector}} has also methods \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/push\_back}{\sphinxcode{\sphinxupquote{push\_back(value)}}} and \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/pop\_back}{\sphinxcode{\sphinxupquote{pop\_back()}}} like the ones in stack.

\item {} 
\sphinxAtStartPar
On the other hand, a stack does not give easy access to the second last element for the operator \sphinxcode{\sphinxupquote{"+"}} in this problem.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://en.cppreference.com/w/cpp/algorithm/accumulate}{\sphinxcode{\sphinxupquote{accumulate(stk.begin(), stk.end(), 0)}}} computes the sum of the vector \sphinxcode{\sphinxupquote{stk}}.

\end{enumerate}


\subsection{Exercise}
\label{\detokenize{Stack/682_Baseball_Game:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/crawler-log-folder/}{Crawler Log Folder}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Valid Parentheses}
\label{\detokenize{Stack/20_Valid_Parentheses:valid-parentheses}}\label{\detokenize{Stack/20_Valid_Parentheses::doc}}

\subsection{Problem statement}
\label{\detokenize{Stack/20_Valid_Parentheses:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/valid\sphinxhyphen{}parentheses/
%
\end{footnote}You are given a string \sphinxcode{\sphinxupquote{s}} containing only the characters \sphinxcode{\sphinxupquote{\textquotesingle{}(\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{})\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}\{\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}\}\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}{[}\textquotesingle{}}}, and \sphinxcode{\sphinxupquote{\textquotesingle{}{]}\textquotesingle{}}}. Your task is to check if the input string is valid.

\sphinxAtStartPar
A string is considered valid if the following conditions are satisfied:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Opening brackets must be closed by the same type of brackets.

\item {} 
\sphinxAtStartPar
Opening brackets must be closed in the correct order, meaning that the innermost opening bracket should be closed before its surrounding brackets.

\end{enumerate}


\subsubsection{Example 1}
\label{\detokenize{Stack/20_Valid_Parentheses:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}()\PYGZdq{}
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Stack/20_Valid_Parentheses:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}()[]\PYGZob{}\PYGZcb{}\PYGZdq{}
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Stack/20_Valid_Parentheses:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}(]\PYGZdq{}
Output: false
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Stack/20_Valid_Parentheses:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} consists of parentheses only \sphinxcode{\sphinxupquote{\textquotesingle{}(){[}{]}\{\}\textquotesingle{}}}.

\end{itemize}


\subsection{Solution: Using a stack}
\label{\detokenize{Stack/20_Valid_Parentheses:solution-using-a-stack}}
\sphinxAtStartPar
For each character \sphinxcode{\sphinxupquote{c}} of \sphinxcode{\sphinxupquote{s}}:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If it is an open parenthesis (\sphinxcode{\sphinxupquote{\textquotesingle{}(\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}\{\textquotesingle{}}}, or \sphinxcode{\sphinxupquote{\textquotesingle{}{[}\textquotesingle{}}}), push it into the stack.

\item {} 
\sphinxAtStartPar
If it is a closed parenthesis (\sphinxcode{\sphinxupquote{\textquotesingle{})\textquotesingle{}}}, \sphinxcode{\sphinxupquote{\textquotesingle{}\}\textquotesingle{}}}, or \sphinxcode{\sphinxupquote{\textquotesingle{}{]}\textquotesingle{}}}) but its previous character is not the corresponding open one, return \sphinxcode{\sphinxupquote{false}}. End.

\item {} 
\sphinxAtStartPar
Otherwise (i.e. match open\sphinxhyphen{}closed), erase the pair.

\item {} 
\sphinxAtStartPar
Continue the process until all characters of \sphinxcode{\sphinxupquote{s}} are visited.

\item {} 
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{true}} if the stack is empty, i.e. all valid pairs are erased.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{Stack/20_Valid_Parentheses:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stack\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isValid}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{stack}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// start with a non\PYGZhy{}open parenthesis is invalid}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{)}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{(}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }
\PYG{+w}{              }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{]}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{[}\PYG{l+s+sc}{\PYGZsq{}}
\PYG{+w}{              }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZcb{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZob{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// the last open parenthesis does not match this closed one}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// open\PYGZhy{}close match}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isValid}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{()}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isValid}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{()\PYGZob{}\PYGZcb{}[]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isValid}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{(]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isValid}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{([)]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
0
0
\end{sphinxVerbatim}


\subsubsection{Complexity:}
\label{\detokenize{Stack/20_Valid_Parentheses:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Stack/20_Valid_Parentheses:key-takeaway}}
\sphinxAtStartPar
This solution efficiently checks the validity of a string of parentheses, brackets, and curly braces by using a stack to ensure that each opening bracket is correctly matched with its corresponding closing bracket.


\subsection{Exercise}
\label{\detokenize{Stack/20_Valid_Parentheses:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/}{Check If Word Is Valid After Substitutions}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Backspace String Compare}
\label{\detokenize{Stack/844_Backspace_String_Compare:backspace-string-compare}}\label{\detokenize{Stack/844_Backspace_String_Compare::doc}}

\subsection{Problem statement}
\label{\detokenize{Stack/844_Backspace_String_Compare:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/backspace\sphinxhyphen{}string\sphinxhyphen{}compare/
%
\end{footnote}You are provided with two strings, \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}}. Your task is to determine if these two strings are equal when typed into an empty text editor, where the character \sphinxcode{\sphinxupquote{\textquotesingle{}\#\textquotesingle{}}} represents a backspace action.

\sphinxAtStartPar
Note that applying a backspace action to an empty text does not change the text; it remains empty. Your function should return \sphinxcode{\sphinxupquote{true}} if the two strings become equal after considering the backspace actions, otherwise return \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Example 1}
\label{\detokenize{Stack/844_Backspace_String_Compare:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}ab\PYGZsh{}c\PYGZdq{}, t = \PYGZdq{}ad\PYGZsh{}c\PYGZdq{}
Output: true
Explanation: Both s and t become \PYGZdq{}ac\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Stack/844_Backspace_String_Compare:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}ab\PYGZsh{}\PYGZsh{}\PYGZdq{}, t = \PYGZdq{}c\PYGZsh{}d\PYGZsh{}\PYGZdq{}
Output: true
Explanation: Both s and t become \PYGZdq{}\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Stack/844_Backspace_String_Compare:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}a\PYGZsh{}c\PYGZdq{}, t = \PYGZdq{}b\PYGZdq{}
Output: false
Explanation: s becomes \PYGZdq{}c\PYGZdq{} while t becomes \PYGZdq{}b\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Stack/844_Backspace_String_Compare:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length, t.length \textless{}= 200}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}} only contain lowercase letters and \sphinxcode{\sphinxupquote{\textquotesingle{}\#\textquotesingle{}}} characters.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Stack/844_Backspace_String_Compare:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Can you solve it in \sphinxcode{\sphinxupquote{O(n)}} time and \sphinxcode{\sphinxupquote{O(1)}} space?

\end{itemize}


\subsection{Solution: Build and clean the string using the \sphinxstyleliteralintitle{\sphinxupquote{stack}}’s behaviors}
\label{\detokenize{Stack/844_Backspace_String_Compare:solution-build-and-clean-the-string-using-the-stacks-behaviors}}

\subsubsection{Code}
\label{\detokenize{Stack/844_Backspace_String_Compare:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n+nf}{cleanString}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{\PYGZsh{}}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// s[i] is a normal letter}
\PYG{+w}{            }\PYG{n}{v}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{v}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// perform the backspace}
\PYG{+w}{                }\PYG{n}{v}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// create a string from a vector of char}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{string}\PYG{p}{(}\PYG{n}{v}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{v}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{backspaceCompare}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{t}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{cleanString}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{cleanString}\PYG{p}{(}\PYG{n}{t}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{backspaceCompare}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ab\PYGZsh{}c}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ad\PYGZsh{}c}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{backspaceCompare}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ab\PYGZsh{}\PYGZsh{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{c\PYGZsh{}d\PYGZsh{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{backspaceCompare}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a\PYGZsh{}c}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{b}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution effectively handles backspace characters (\sphinxcode{\sphinxupquote{\textquotesingle{}\#\textquotesingle{}}}) in input strings \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}} by constructing cleaned versions of the strings and then comparing the cleaned strings for equality.


\subsubsection{Complexity}
\label{\detokenize{Stack/844_Backspace_String_Compare:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = max(s.length, t.length)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Implementation notes}
\label{\detokenize{Stack/844_Backspace_String_Compare:implementation-notes}}

\subsubsection{Why \sphinxstyleliteralintitle{\sphinxupquote{vector }} instead of \sphinxstyleliteralintitle{\sphinxupquote{stack}}?}
\label{\detokenize{Stack/844_Backspace_String_Compare:why-vector-instead-of-stack}}
\sphinxAtStartPar
You can use the methods \sphinxhref{https://en.cppreference.com/w/cpp/container/stack/push}{\sphinxcode{\sphinxupquote{push}}} and \sphinxhref{https://en.cppreference.com/w/cpp/container/stack/pop}{\sphinxcode{\sphinxupquote{pop}}} of the data structure \sphinxhref{https://en.cppreference.com/w/cpp/container/stack}{\sphinxcode{\sphinxupquote{stack}}} to build and clean the strings.

\sphinxAtStartPar
But \sphinxhref{https://en.cppreference.com/w/cpp/container/vector}{\sphinxcode{\sphinxupquote{vector}}} has also such methods: \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/push\_back}{\sphinxcode{\sphinxupquote{push\_back}}} and \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/pop\_back}{\sphinxcode{\sphinxupquote{pop\_back}}}.

\sphinxAtStartPar
On the other hand, using \sphinxcode{\sphinxupquote{vector}} it is easier to construct a \sphinxcode{\sphinxupquote{string}} by constructor than using \sphinxcode{\sphinxupquote{stack}} after cleaning.


\subsubsection{Can you solve it in \sphinxstyleliteralintitle{\sphinxupquote{O(n)}} time and \sphinxstyleliteralintitle{\sphinxupquote{O(1)}} space?}
\label{\detokenize{Stack/844_Backspace_String_Compare:can-you-solve-it-in-o-n-time-and-o-1-space}}
\sphinxAtStartPar
Yes, you can.

\sphinxAtStartPar
The simplest way is just to perform the erasure directly on strings \sphinxcode{\sphinxupquote{s}} and \sphinxcode{\sphinxupquote{t}}. But the run time complexity of \sphinxhref{https://en.cppreference.com/w/cpp/string/basic\_string/erase}{\sphinxcode{\sphinxupquote{string::erase}}}  is not constant.


\subsection{Exercise}
\label{\detokenize{Stack/844_Backspace_String_Compare:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/removing-stars-from-a-string/}{Removing Stars From a String}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Remove All Adjacent Duplicates in String II}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:remove-all-adjacent-duplicates-in-string-ii}}\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II::doc}}

\subsection{Problem statement}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/remove\sphinxhyphen{}all\sphinxhyphen{}adjacent\sphinxhyphen{}duplicates\sphinxhyphen{}in\sphinxhyphen{}string\sphinxhyphen{}ii/
%
\end{footnote}You are given a string \sphinxcode{\sphinxupquote{s}} and an integer \sphinxcode{\sphinxupquote{k}}. A \sphinxcode{\sphinxupquote{k}} duplicate removal operation involves selecting \sphinxcode{\sphinxupquote{k}} adjacent and identical letters from \sphinxcode{\sphinxupquote{s}} and removing them, causing the remaining portions on the left and right of the removed substring to join together.

\sphinxAtStartPar
You need to perform the \sphinxcode{\sphinxupquote{k}} duplicate removal operation on \sphinxcode{\sphinxupquote{s}} repeatedly until it is no longer possible. After completing all such operations, return the resulting string. It is guaranteed that the answer will be unique.


\subsubsection{Example 1}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}abcd\PYGZdq{}, k = 2
Output: \PYGZdq{}abcd\PYGZdq{}
Explanation: There is nothing to delete.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}deeedbbcccbdaa\PYGZdq{}, k = 3
Output: \PYGZdq{}aa\PYGZdq{}
Explanation: 
First delete \PYGZdq{}eee\PYGZdq{} and \PYGZdq{}ccc\PYGZdq{}, get \PYGZdq{}ddbbbdaa\PYGZdq{}
Then delete \PYGZdq{}bbb\PYGZdq{}, get \PYGZdq{}dddaa\PYGZdq{}
Finally delete \PYGZdq{}ddd\PYGZdq{}, get \PYGZdq{}aa\PYGZdq{}
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}pbbcggttciiippooaais\PYGZdq{}, k = 2
Output: \PYGZdq{}ps\PYGZdq{}
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2 \textless{}= k \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} only contains lower case English letters.

\end{itemize}


\subsection{Solution: Strings of adjacent equal letters}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:solution-strings-of-adjacent-equal-letters}}
\sphinxAtStartPar
Construct a stack of strings that has adjacent equal letters and perform the removal during building those strings.


\subsubsection{Example 2}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{s = "deeedbbcccbdaa"}} and \sphinxcode{\sphinxupquote{k = 3}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first built string is \sphinxcode{\sphinxupquote{"d"}}.

\item {} 
\sphinxAtStartPar
Then \sphinxcode{\sphinxupquote{"eee"}} with the exact length \sphinxcode{\sphinxupquote{k}}, remove this string.

\item {} 
\sphinxAtStartPar
The next character is \sphinxcode{\sphinxupquote{\textquotesingle{}d\textquotesingle{}}}, which equals the last character of the last string \sphinxcode{\sphinxupquote{"d"}}, merge them together. The first string becomes \sphinxcode{\sphinxupquote{"dd"}}.

\item {} 
\sphinxAtStartPar
The next string is \sphinxcode{\sphinxupquote{"bb"}}.

\item {} 
\sphinxAtStartPar
Then \sphinxcode{\sphinxupquote{"ccc"}} is removed.

\item {} 
\sphinxAtStartPar
The next character \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}} is merged with the last string (\sphinxcode{\sphinxupquote{"bb"}}) to become \sphinxcode{\sphinxupquote{"bbb"}} and be removed.

\item {} 
\sphinxAtStartPar
The next character \sphinxcode{\sphinxupquote{\textquotesingle{}d\textquotesingle{}}} is merged with the last string (\sphinxcode{\sphinxupquote{"dd"}}) to become \sphinxcode{\sphinxupquote{"ddd"}} and be removed.

\item {} 
\sphinxAtStartPar
The remaining string is \sphinxcode{\sphinxupquote{"aa"}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{string}\PYG{+w}{ }\PYG{n+nf}{removeDuplicates}\PYG{p}{(}\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// stk is used as a stack}
\PYG{+w}{    }\PYG{c+c1}{// all letters in each string a of stk are equal }
\PYG{+w}{    }\PYG{c+c1}{// every a\PYGZsq{}s length is less than k}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// a represents the current string with duplicate letters}
\PYG{+w}{        }\PYG{n}{string}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}\PYG{+w}{   }
\PYG{+w}{        }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// let a be the latest string in stk}
\PYG{+w}{            }\PYG{c+c1}{// because its letters are equal to s[i]}
\PYG{+w}{            }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{move}\PYG{p}{(}\PYG{n}{stk}\PYG{p}{.}\PYG{n}{back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{pop\PYGZus{}back}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// iterate all adjacent duplicates of s[i]}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{c+c1}{// remove the k\PYGZhy{}duplicate}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// after the loop, the number of duplicates in a is less than k}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{a}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{            }
\PYG{+w}{            }\PYG{n}{stk}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// create the final result from stk}
\PYG{+w}{    }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{str}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{stk}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{str}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{deeedbbcccbdaa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{pbbcggttciiippooaais}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
abcd
aa
ps
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently removes substrings of consecutive duplicate characters of length \sphinxcode{\sphinxupquote{k}} from a given string by using a stack to keep track of the adjacent characters.


\subsubsection{Complexity}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Implementation tips}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:implementation-tips}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The data structure \sphinxcode{\sphinxupquote{stk}} you might need to solve this problem is a stack. But here are the reasons you had better use \sphinxhref{https://en.cppreference.com/w/cpp/container/vector}{\sphinxcode{\sphinxupquote{std::vector}}}:

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{std::vector}} also has methods \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/push\_back}{\sphinxcode{\sphinxupquote{push\_back(value)}}} and \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/pop\_back}{\sphinxcode{\sphinxupquote{pop\_back()}}} like the ones in a stack.

\item {} 
\sphinxAtStartPar
On the other hand, it is faster for a vector to perform the string concatenation at the end.

\item {} 
\sphinxAtStartPar
In the expression \sphinxcode{\sphinxupquote{stk.back().back()}}: \sphinxcode{\sphinxupquote{stk.back()}} is the latest string \sphinxcode{\sphinxupquote{a}} of \sphinxcode{\sphinxupquote{stk}}. Then \sphinxcode{\sphinxupquote{stk.back().back() = a.back()}} is the last character of \sphinxcode{\sphinxupquote{a}}.

\end{itemize}


\subsection{Exercise}
\label{\detokenize{Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/}{Remove All Adjacent Duplicates In String}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Priority Queue (Heap)}
\label{\detokenize{Priority_Queue/index:priority-queue-heap}}\label{\detokenize{Priority_Queue/index::doc}}
\sphinxAtStartPar
This chapter explores \sphinxstylestrong{priority queues} (or \sphinxstylestrong{heaps}), the fascinating data structures designed to manage elements with distinct levels of importance. In this chapter, we’ll focus on harnessing the capabilities of C++’s \sphinxcode{\sphinxupquote{std::priority\_queue}} from the Standard Template Library (STL).

\sphinxAtStartPar
Think of a priority queue as a line at a theme park, where individuals with priority passes are served before others. Similarly, a priority queue ensures that elements with higher priority are processed ahead of those with lower priority, enabling us to address a wide range of problems that involve ordering and selection.

\sphinxAtStartPar
\sphinxstylestrong{What this chapter covers:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Understanding Priority Queues:} Begin by grasping the essence of priority queues, their underlying mechanisms, and the significance of their unique ordering.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Leveraging std::priority\_queue:} Dive into the versatile \sphinxcode{\sphinxupquote{std::priority\_queue}} container provided by the STL, mastering its usage for managing priorities effectively.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Operations and Methods:} Explore the operations available in \sphinxcode{\sphinxupquote{std::priority\_queue}}, including insertion, and extraction while maintaining optimal order.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Custom Comparators:} Customize the behavior of your priority queue by utilizing custom comparators, tailoring it to handle diverse data types and priority criteria.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Priority Queues:} Learn strategies for tackling problems where prioritization is key, from scheduling tasks to efficient data retrieval.

\end{enumerate}

\sphinxstepscope


\section{Last Stone Weight}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:last-stone-weight}}\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight::doc}}

\subsection{Problem statement}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/last\sphinxhyphen{}stone\sphinxhyphen{}weight/
%
\end{footnote}You are given an array of integers called \sphinxcode{\sphinxupquote{stones}}, where each \sphinxcode{\sphinxupquote{stones{[}i{]}}} represents the weight of the \sphinxcode{\sphinxupquote{i\sphinxhyphen{}th}} stone.

\sphinxAtStartPar
A game is played with these stones as follows: In each turn, we choose the two heaviest stones and smash them together. Let us say the weights of the two heaviest stones are \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}, where \sphinxcode{\sphinxupquote{x \textless{}= y}}. The outcome of this smash operation is:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{x}} is equal to \sphinxcode{\sphinxupquote{y}}, both stones are destroyed.

\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{x}} is not equal to \sphinxcode{\sphinxupquote{y}}, the stone with weight \sphinxcode{\sphinxupquote{x}} is destroyed, and the stone with weight \sphinxcode{\sphinxupquote{y}} now has a new weight of \sphinxcode{\sphinxupquote{y \sphinxhyphen{} x}}.

\end{enumerate}

\sphinxAtStartPar
The game continues until there is at most one stone left. Your task is to determine the smallest possible weight of the remaining stone after the game ends. If there are no stones left, return \sphinxcode{\sphinxupquote{0}}.


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1, so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2, so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0, so the array converts to [1] then that\PYGZsq{}s the value of the last stone.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: stones = [1]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= stones.length \textless{}= 30}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= stones{[}i{]} \textless{}= 1000}}.

\end{itemize}


\subsection{Solution: Keeping the heaviest stones on top}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:solution-keeping-the-heaviest-stones-on-top}}
\sphinxAtStartPar
The only things you want at any time are the two heaviest stones. One way of keeping this condition is by using \index{std::priority\_queue@\spxentry{std::priority\_queue}}std::priority\_queue.


\subsubsection{Code}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{lastStoneWeight}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{stones}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{(}\PYG{n}{stones}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{stones}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{q}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// compare two heaviest stones}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{y}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{empty}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{stones}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lastStoneWeight}\PYG{p}{(}\PYG{n}{stones}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{stones}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{lastStoneWeight}\PYG{p}{(}\PYG{n}{stones}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*logn)}}, where \sphinxcode{\sphinxupquote{n = stones.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Priority_Queue/1046_Last_Stone_Weight:key-takeaway}}
\sphinxAtStartPar
This solution efficiently simulates the process of smashing stones and finding the last remaining stone by using a max\sphinxhyphen{}heap (priority queue) to always select the heaviest stones to smash together.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Kth Largest Element in a Stream}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:kth-largest-element-in-a-stream}}\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream::doc}}

\subsection{Problem statement}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/kth\sphinxhyphen{}largest\sphinxhyphen{}element\sphinxhyphen{}in\sphinxhyphen{}a\sphinxhyphen{}stream/
%
\end{footnote}Create a class that can find the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} largest element in a stream of integers. This is the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} largest element when the elements are arranged in sorted order, not the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} distinct element.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{KthLargest}} class needs to support the following operations:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{KthLargest(int k, int{[}{]} nums)}}: This initializes the object with an integer \sphinxcode{\sphinxupquote{k}} and a stream of integers \sphinxcode{\sphinxupquote{nums}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{int add(int val)}}: This method adds the integer \sphinxcode{\sphinxupquote{val}} to the stream and returns the element representing the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} largest element in the stream.

\end{enumerate}


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input
[\PYGZdq{}KthLargest\PYGZdq{}, \PYGZdq{}add\PYGZdq{}, \PYGZdq{}add\PYGZdq{}, \PYGZdq{}add\PYGZdq{}, \PYGZdq{}add\PYGZdq{}, \PYGZdq{}add\PYGZdq{}]
[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]
Output
[null, 4, 5, 5, 8, 8]

Explanation
KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);
kthLargest.add(3);   // return 4
kthLargest.add(5);   // return 5
kthLargest.add(10);  // return 5
kthLargest.add(9);   // return 8
kthLargest.add(4);   // return 8
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= k \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= nums.length \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}4 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}4 \textless{}= val \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
At most \sphinxcode{\sphinxupquote{10\textasciicircum{}4}} calls will be made to add.

\item {} 
\sphinxAtStartPar
It is guaranteed that there will be at least \sphinxcode{\sphinxupquote{k}} elements in the array when you search for the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} element.

\end{itemize}


\subsection{Solution 1: Sort and Append}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:solution-1-sort-and-append}}
\sphinxAtStartPar
Sort the stream when initialization. And keep it sorted whenever you append a new value.


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}4, 5, 8, 2{]}}} and \sphinxcode{\sphinxupquote{k = 3}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Sort \sphinxcode{\sphinxupquote{nums = {[}8, 5, 4, 2{]}}}.

\item {} 
\sphinxAtStartPar
Adding \sphinxcode{\sphinxupquote{3}} to \sphinxcode{\sphinxupquote{nums}}. It becomes \sphinxcode{\sphinxupquote{{[}8, 5, 4, 3, 2{]}}}. The third largest element is \sphinxcode{\sphinxupquote{4}}.

\item {} 
\sphinxAtStartPar
Adding \sphinxcode{\sphinxupquote{5}} to \sphinxcode{\sphinxupquote{nums}}. It becomes \sphinxcode{\sphinxupquote{{[}8, 5, 5, 4, 3, 2{]}}}. The third largest element is \sphinxcode{\sphinxupquote{5}}.

\item {} 
\sphinxAtStartPar
Adding \sphinxcode{\sphinxupquote{10}} to \sphinxcode{\sphinxupquote{nums}}. It becomes \sphinxcode{\sphinxupquote{{[}10, 8, 5, 5, 4, 3, 2{]}}}. The third largest element is \sphinxcode{\sphinxupquote{5}}.

\item {} 
\sphinxAtStartPar
So on and so on.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{KthLargest}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}nums}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{KthLargest}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{\PYGZus{}nums}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{   }
\PYG{+w}{        }\PYG{c+c1}{// sort the nums when constructed}
\PYG{+w}{        }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{greater}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{add}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// find the position to insert val}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{  }\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{it}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{it}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{it}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// return the k\PYGZhy{}th largest element}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{(}\PYG{n}{\PYGZus{}nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{KthLargest}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
4
5
5
8
8
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution maintains a sorted vector \sphinxcode{\sphinxupquote{\_nums}} in non\sphinxhyphen{}ascending order upon initialization, which stores the elements. When adding a new element \sphinxcode{\sphinxupquote{val}}, it inserts it into \sphinxcode{\sphinxupquote{\_nums}} while maintaining the sorted order.

\sphinxAtStartPar
Since \sphinxcode{\sphinxupquote{\_nums}} is sorted in non\sphinxhyphen{}ascending order, the \sphinxcode{\sphinxupquote{k}}\sphinxhyphen{}th largest element is always at index \sphinxcode{\sphinxupquote{\_k \sphinxhyphen{} 1}}. Thus, upon adding a new element, it returns the value at index \sphinxcode{\sphinxupquote{\_k \sphinxhyphen{} 1}} as the \sphinxcode{\sphinxupquote{k}}\sphinxhyphen{}th largest element in the collection.

\sphinxAtStartPar
This approach optimizes the \sphinxcode{\sphinxupquote{add}} operation by leveraging the sorted nature of the data structure, resulting in efficient retrieval of the \sphinxcode{\sphinxupquote{k}}\sphinxhyphen{}th largest element.


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: for the constructor \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N = nums.length}}. For the \sphinxcode{\sphinxupquote{add}} method, \sphinxcode{\sphinxupquote{O(N)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Priority queue}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:solution-2-priority-queue}}
\sphinxAtStartPar
There is a data structure that has the property you want in this problem.

\sphinxAtStartPar
It is \sphinxhref{https://en.cppreference.com/w/cpp/container/priority\_queue}{\sphinxcode{\sphinxupquote{std::priority\_queue}}}, which keeps its top element is always the largest one according to the comparison you define for the queue.

\sphinxAtStartPar
By default, the “less than” comparison is used for \index{std::priority\_queue@\spxentry{std::priority\_queue}}std::priority\_queue (heap) and the top one is always the biggest element.

\sphinxAtStartPar
If you want the top one is always the smallest element, you can use the comparison “greater than” for your heap.


\subsubsection{Code}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{KthLargest}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}q}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{KthLargest}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}
\PYG{+w}{    }\PYG{c+c1}{// create the heap when constructed }
\PYG{+w}{    }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{\PYGZus{}q}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{p}{(}\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{add}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{\PYGZus{}q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{val}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{        }\PYG{c+c1}{// remove elements until \PYGZus{}q remains k elements}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{\PYGZus{}q}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{\PYGZus{}q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{\PYGZus{}q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{KthLargest}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{9}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{.}\PYG{n}{add}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
4
5
5
8
8
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: for the constructor, \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N = nums.length}}. For the \sphinxcode{\sphinxupquote{add}} method, \sphinxcode{\sphinxupquote{O(logN)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:key-takeaway}}
\sphinxAtStartPar
The key insight of Solution 2 is utilizing a min\sphinxhyphen{}heap (priority queue with the \sphinxcode{\sphinxupquote{greater}} comparator) to find the kth largest element in a collection.

\sphinxAtStartPar
Upon initialization, the constructor populates the priority queue with the elements from the input vector \sphinxcode{\sphinxupquote{nums}}. When adding a new element \sphinxcode{\sphinxupquote{val}}, it inserts it into the priority queue and then removes elements until the size of the priority queue is reduced to \sphinxcode{\sphinxupquote{\_k}}, ensuring that only the k largest elements are retained in the queue.

\sphinxAtStartPar
Finally, it returns the top element of the priority queue, which represents the kth largest element. This approach leverages the properties of a min\sphinxhyphen{}heap to track the kth largest element in the collection, resulting in an overall efficient solution.


\subsection{Exercise}
\label{\detokenize{Priority_Queue/703_Kth_Largest_Element_in_a_Stream:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/kth-largest-element-in-an-array/}{Kth Largest Element in an Array}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Kth Smallest Element in a Sorted Matrix}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:kth-smallest-element-in-a-sorted-matrix}}\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix::doc}}

\subsection{Problem statement}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/kth\sphinxhyphen{}smallest\sphinxhyphen{}element\sphinxhyphen{}in\sphinxhyphen{}a\sphinxhyphen{}sorted\sphinxhyphen{}matrix/
%
\end{footnote}You are given an \sphinxcode{\sphinxupquote{n x n}} matrix where each row and column is sorted in ascending order. Your task is to find the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} smallest element in this matrix.

\sphinxAtStartPar
Please note that we are looking for the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} smallest element based on its position in the sorted order, and not counting distinct elements.

\sphinxAtStartPar
Additionally, it is required to find a solution with a memory complexity better than \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}.


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: matrix = [[\PYGZhy{}5]], k = 1
Output: \PYGZhy{}5
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == matrix.length == matrix{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 300}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}9 \textless{}= matrix{[}i{]}{[}j{]} \textless{}= 10\textasciicircum{}9}}.

\item {} 
\sphinxAtStartPar
All the rows and columns of \sphinxcode{\sphinxupquote{matrix}} are guaranteed to be sorted in non\sphinxhyphen{}decreasing order.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= k \textless{}= n\textasciicircum{}2}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you solve the problem with a constant memory (i.e., \sphinxcode{\sphinxupquote{O(1)}} memory complexity)?

\item {} 
\sphinxAtStartPar
Could you solve the problem in \sphinxcode{\sphinxupquote{O(n)}} time complexity? The solution may be too advanced for an interview but you may find reading \sphinxhref{http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf}{this paper} fun.

\end{itemize}


\subsection{Solution 1: Transform the 2\sphinxhyphen{}D matrix into a 1\sphinxhyphen{}D vector then sort}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:solution-1-transform-the-2-d-matrix-into-a-1-d-vector-then-sort}}
\sphinxAtStartPar
You can implement exactly what Example 1 has explained.


\subsubsection{Code}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{kthSmallest}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// transform the 2D matrix into a 1D array m}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// sort the array m}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{m}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{kthSmallest}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{kthSmallest}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
13
\PYGZhy{}5
\end{sphinxVerbatim}

\sphinxAtStartPar
The core idea behind this solution is to transform the 2D matrix into a 1D sorted array, making it easier to find the \sphinxcode{\sphinxupquote{k}}\sphinxhyphen{}th smallest element efficiently. The time complexity of this solution is dominated by the sorting step, which is \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N}} is the total number of elements in the matrix.


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N = n\textasciicircum{}2}} is the total number of elements in the matrix.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Solution 2: Build the max heap and keep it ungrown}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:solution-2-build-the-max-heap-and-keep-it-ungrown}}
\sphinxAtStartPar
Instead of sorting after building the vector in Solution 1, you can do the other way around. It means building up the vector from scratch and keeping it sorted.

\sphinxAtStartPar
Since you need only the \sphinxcode{\sphinxupquote{k\sphinxhyphen{}th}} smallest element, \index{std::priority\_queue@\spxentry{std::priority\_queue}}std::priority\_queue\sphinxhref{https://en.cppreference.com/w/cpp/container/priority\_queue}{} can be used for this purpose.


\subsubsection{Code}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{kthSmallest}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{row}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{col}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{col}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{col}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{[}\PYG{n}{row}\PYG{p}{]}\PYG{p}{[}\PYG{n}{col}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{c+c1}{// maintain q\PYGZsq{}s size does not exceed k}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{q}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{matrix}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{kthSmallest}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{matrix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{kthSmallest}\PYG{p}{(}\PYG{n}{matrix}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
13
\PYGZhy{}5
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*logk)}}, where \sphinxcode{\sphinxupquote{N = n\textasciicircum{}2}} is the total number of elements of the matrix.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(k)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:key-takeaway}}
\sphinxAtStartPar
Solution 2 maintains a priority queue of size \sphinxcode{\sphinxupquote{k}}, allowing it to efficiently keep track of the \sphinxcode{\sphinxupquote{k}}\sphinxhyphen{}th smallest element encountered while iterating through the matrix.

\sphinxAtStartPar
This approach is handy for large matrices, as it doesn’t require sorting the entire matrix.




\subsection{Exercise}
\label{\detokenize{Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/find-k-pairs-with-smallest-sums/}{Find K Pairs with Smallest Sums}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Construct Target Array With Multiple Sums}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:construct-target-array-with-multiple-sums}}\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums::doc}}

\subsection{Problem statement}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/construct\sphinxhyphen{}target\sphinxhyphen{}array\sphinxhyphen{}with\sphinxhyphen{}multiple\sphinxhyphen{}sums/
%
\end{footnote}You are provided with an array of integers called \sphinxcode{\sphinxupquote{target}} with \sphinxcode{\sphinxupquote{n}} elements. You start with another array, \sphinxcode{\sphinxupquote{arr}}, consisting of \sphinxcode{\sphinxupquote{n}} elements, all initialized to \sphinxcode{\sphinxupquote{1}}. You have the ability to perform the following operation:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Calculate the sum of all elements in your current array \sphinxcode{\sphinxupquote{arr}}, let’s call it \sphinxcode{\sphinxupquote{x}}.

\item {} 
\sphinxAtStartPar
Choose an index \sphinxcode{\sphinxupquote{i}} where \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{} n}}, and update the value at index \sphinxcode{\sphinxupquote{i}} in \sphinxcode{\sphinxupquote{arr}} to be \sphinxcode{\sphinxupquote{x}}.

\end{enumerate}

\sphinxAtStartPar
You can repeat this operation as many times as needed. Your task is to determine whether it’s possible to transform the initial array \sphinxcode{\sphinxupquote{arr}} into the given \sphinxcode{\sphinxupquote{target}} array using this operation. If it’s possible, return \sphinxcode{\sphinxupquote{true}}; otherwise, return \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: target = [9,3,5]
Output: true
Explanation: Start with arr = [1, 1, 1] 
[1, 1, 1], sum = 3 choose index 1
[1, 3, 1], sum = 5 choose index 2
[1, 3, 5], sum = 9 choose index 0
[9, 3, 5] Done
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: target = [1,1,1,2]
Output: false
Explanation: Impossible to create target array from [1,1,1,1].
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: target = [8,5]
Output: true
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == target.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 5 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= target{[}i{]} \textless{}= 10\textasciicircum{}9}}.

\end{itemize}


\subsection{Solution 1: Going backward}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:solution-1-going-backward}}
\sphinxAtStartPar
If you start from \sphinxcode{\sphinxupquote{arr = {[}1,1,...,1{]}}} and follow the required procedure, the new element \sphinxcode{\sphinxupquote{x}} you get for the next state is always the max element of \sphinxcode{\sphinxupquote{arr}}.

\sphinxAtStartPar
To solve this problem, you can start from the max element of the given \sphinxcode{\sphinxupquote{target}} to compute its previous state until you get the \sphinxcode{\sphinxupquote{arr = {[}1,1,...,1{]}}}.


\subsubsection{Example 1}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{target = {[}9,3,5{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The max element is \sphinxcode{\sphinxupquote{9}}, subtract it from the remaining sum: \sphinxcode{\sphinxupquote{9 \sphinxhyphen{} (3 + 5) = 1}}, you get \sphinxcode{\sphinxupquote{target = {[}1,3,5{]}}}.

\item {} 
\sphinxAtStartPar
The max element is \sphinxcode{\sphinxupquote{5}}, subtract it from the remaining sum: \sphinxcode{\sphinxupquote{5 \sphinxhyphen{} (1 + 3) = 1}}, you get \sphinxcode{\sphinxupquote{target = {[}1,3,1{]}}}.

\item {} 
\sphinxAtStartPar
The max element is \sphinxcode{\sphinxupquote{3}}, subtract it from the remaining sum: \sphinxcode{\sphinxupquote{3 \sphinxhyphen{} (1 + 1) = 1}}, you get \sphinxcode{\sphinxupquote{target = {[}1,1,1{]}}}.

\item {} 
\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{true}}.

\end{itemize}


\subsubsection{Notes}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:notes}}\begin{itemize}
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{target = {[}m,1{]}}} or \sphinxcode{\sphinxupquote{target = {[}1,m{]}}} for any \sphinxcode{\sphinxupquote{m \textgreater{}= 1}}, you can always turn it to \sphinxcode{\sphinxupquote{arr = {[}1,1{]}}}.

\item {} 
\sphinxAtStartPar
If the changed value after the subtraction is still the max element of the previous state, you need to redo the subtraction at the same position. In this case, the modulo might be used instead of subtraction.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPossible}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// compute sum of all target\PYGZsq{}s elements}
\PYG{+w}{    }\PYG{k+kt}{unsigned}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{target}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{                                   }\PYG{n}{target}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{                                   }\PYG{p}{(}\PYG{k+kt}{unsigned}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{p}{)}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// find the max element in the target}
\PYG{+w}{    }\PYG{c+c1}{// pmax is the pointer to the max element,}
\PYG{+w}{    }\PYG{c+c1}{// *pmax is the value that pointer points to}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{target}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// compute the remaining sum}
\PYG{+w}{        }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pmax}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// This is the case target = [m,1], }
\PYG{+w}{            }\PYG{c+c1}{// which you can always turn it to [1,1].}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{        }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// the next subtraction leads to non\PYGZhy{}positive values}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// cannot change target}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// perform the subtraction as much as possible}
\PYG{+w}{        }\PYG{c+c1}{// and update new value for the pointer pmax}
\PYG{+w}{        }\PYG{o}{*}\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{*}\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// compute the sum of the subtracted target}
\PYG{+w}{        }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{pmax}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// find the max element in the subtracted target}
\PYG{+w}{        }\PYG{n}{pmax}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{target}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// if the final target = [1, .., 1],}
\PYG{+w}{    }\PYG{c+c1}{// its sum equals to its length}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{target}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{target}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution iteratively reduces the maximum element in the \sphinxcode{\sphinxupquote{target}} array while keeping track of the total sum. It checks various conditions to determine whether it’s possible to reach an array consisting of only 1s. If all conditions are satisfied, it returns \sphinxcode{\sphinxupquote{true}}; otherwise, it returns \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(log N)}}, where \sphinxcode{\sphinxupquote{N = max(target)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Using priority\_queue}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:solution-2-using-priority-queue}}
\sphinxAtStartPar
In the solution above, the position of the max element in each state is not so important as long as you update exactly it, not the other ones.

\sphinxAtStartPar
That might lead to the usage of the \index{std::priority\_queue@\spxentry{std::priority\_queue}}std::priority\_queue.


\subsubsection{Code}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}numeric\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}queue\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPossible}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// create a heap from the target}
\PYG{+w}{    }\PYG{n}{priority\PYGZus{}queue}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{(}\PYG{n}{target}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// compute the sum of all elements}
\PYG{+w}{    }\PYG{k+kt}{unsigned}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{accumulate}\PYG{p}{(}\PYG{n}{target}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{                                   }\PYG{n}{target}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{                                   }\PYG{p}{(}\PYG{k+kt}{unsigned}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{p}{)}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// compute the remaining sum}
\PYG{+w}{        }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// perform the subtraction as much as possible}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{q}\PYG{p}{.}\PYG{n}{top}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// remove the old max element}
\PYG{+w}{        }\PYG{n}{q}\PYG{p}{.}\PYG{n}{pop}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// add subtracted element to the heap}
\PYG{+w}{        }\PYG{n}{q}\PYG{p}{.}\PYG{n}{push}\PYG{p}{(}\PYG{n}{pre}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// compute the sum of the subtracted target}
\PYG{+w}{        }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{target}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{target}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{target}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPossible}\PYG{p}{(}\PYG{n}{target}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(logN)}}, where \sphinxcode{\sphinxupquote{N = max(target)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = target.length}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:key-takeaway}}
\sphinxAtStartPar
Solution 2 uses a max heap (\sphinxcode{\sphinxupquote{priority\_queue}}) to efficiently find and process the maximum element in the \sphinxcode{\sphinxupquote{target}} array while keeping track of the total sum. It checks various conditions to determine whether it’s possible to reach an array consisting of only 1s.


\subsection{Exercise}
\label{\detokenize{Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-amount-of-time-to-fill-cups/}{Minimum Amount of Time to Fill Cups}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Bit Manipulation}
\label{\detokenize{Bit_Manipulation/index:bit-manipulation}}\label{\detokenize{Bit_Manipulation/index::doc}}
\sphinxAtStartPar
In this chapter, we’re diving deep into \sphinxstylestrong{Bit Manipulation}, a fascinating computer science and programming area that manipulates individual bits within data.

\sphinxAtStartPar
Bit Manipulation is crucial in various programming tasks, from optimizing algorithms to working with hardware\sphinxhyphen{}level data. Whether you’re a seasoned programmer looking to expand your skill set or a newcomer eager to delve into the intricacies of bits and bytes, this chapter has something valuable for you.

\sphinxAtStartPar
Here’s what you can expect to explore in this chapter:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Understanding the Basics}: We’ll start by demystifying bits and binary numbers, ensuring you’re comfortable with the fundamentals. You’ll learn to convert between decimal and binary, perform basic bit operations, and understand two’s complement representation.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bitwise Operators}: We’ll delve into the world of bitwise operators in programming languages like C++. You’ll get hands\sphinxhyphen{}on experience with AND, OR, XOR, and other essential operators, seeing how they can be applied to practical coding problems.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bit Hacks}: Discover the art of Bit Hacks \textendash{} clever and often elegant tricks programmers use to solve specific problems efficiently. You’ll learn to perform tasks like counting bits, finding the rightmost set bit, and swapping values without temporary variables.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bit Manipulation Techniques}: We’ll explore techniques and patterns for common bit manipulation tasks, such as setting, clearing, or toggling specific bits, checking if a number is a power of two, or extracting subsets of bits from a larger number.

\end{enumerate}

\sphinxAtStartPar
By the end of this chapter, you’ll have a solid foundation in Bit Manipulation and the ability to harness the power of bits to optimize your code and tackle complex problems. So, let’s embark on this exciting journey into the realm of Bit Manipulation and discover how the smallest data units can have a massive impact on your coding skills and efficiency!

\sphinxstepscope


\section{Hamming Distance}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:hamming-distance}}\label{\detokenize{Bit_Manipulation/461_Hamming_Distance::doc}}

\subsection{Problem statement}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/hamming\sphinxhyphen{}distance/
%
\end{footnote}The \sphinxhref{https://en.wikipedia.org/wiki/Hamming\_distance}{Hamming distance} between two integers is the number of positions at which the corresponding bits are different.

\sphinxAtStartPar
Given two integers \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}}, return the \sphinxstylestrong{Hamming distance} between them.


\subsubsection{Example 1}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: x = 1, y = 4
Output: 2
Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       \PYGZca{}   \PYGZca{}
The above arrows point to positions where the corresponding bits are different.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: x = 3, y = 1
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= x, y \textless{}= 2\textasciicircum{}31}}.

\end{itemize}


\subsection{Solution: Using bitwise operator XOR}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:solution-using-bitwise-operator-xor}}
\sphinxAtStartPar
You could use \index{bitwise XOR@\spxentry{bitwise XOR}}bitwise XOR (\sphinxcode{\sphinxupquote{\textasciicircum{}}}) to get the bit positions where \sphinxcode{\sphinxupquote{x}} and \sphinxcode{\sphinxupquote{y}} are different. Then use \index{bitwise AND@\spxentry{bitwise AND}}bitwise AND operator (\sphinxcode{\sphinxupquote{\&}}) at each position to count them.


\subsubsection{Example 1}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
x = 1   (0 0 0 1)
y = 4   (0 1 0 0)
z = x\PYGZca{}y (0 1 0 1)
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{hammingDistance}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// compute the bit difference }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{x}\PYG{+w}{ }\PYG{o}{\PYGZca{}}\PYG{+w}{ }\PYG{n}{y}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{z}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// e.g. \PYGZsq{}0101\PYGZsq{} \PYGZam{} \PYGZsq{}0001\PYGZsq{}}
\PYG{+w}{        }\PYG{c+c1}{// shift z to the right one position}
\PYG{+w}{        }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{z}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// e.g. z = \PYGZsq{}0101\PYGZsq{} \PYGZgt{}\PYGZgt{} \PYGZsq{}0010\PYGZsq{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hammingDistance}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 2}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hammingDistance}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// 1}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(1)}} as the number of bits is at most 32 as constrained.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:key-takeaway}}
\sphinxAtStartPar
Utilizing bitwise operations, such as XOR (\textasciicircum{}) and bitwise AND (\&), allows for efficient computation of the Hamming distance between two integers. This approach provides a straightforward and efficient method for calculating the Hamming distance without the need for complex logic or additional data structures.


\subsection{Exercise}
\label{\detokenize{Bit_Manipulation/461_Hamming_Distance:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/number-of-1-bits/}{Number of 1 Bits}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Power of Four}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:power-of-four}}\label{\detokenize{Bit_Manipulation/342_Power_of_Four::doc}}

\subsection{Problem statement}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/power\sphinxhyphen{}of\sphinxhyphen{}four/
%
\end{footnote}Given an integer \sphinxcode{\sphinxupquote{n}}, return \sphinxcode{\sphinxupquote{true}} if it is a power of four. Otherwise, return \sphinxcode{\sphinxupquote{false}}.

\sphinxAtStartPar
An integer \sphinxcode{\sphinxupquote{n}} is a power of four if there exists an integer \sphinxcode{\sphinxupquote{x}} such that \sphinxcode{\sphinxupquote{n == 4\textasciicircum{}x}}.


\subsubsection{Example 1}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 16
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 5
Output: false
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 1
Output: true
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}2\textasciicircum{}31 \textless{}= n \textless{}= 2\textasciicircum{}31 \sphinxhyphen{} 1}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you solve it without loops/recursion?

\end{itemize}


\subsection{Solution 1: Division by four}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:solution-1-division-by-four}}

\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPowerOfFour}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// perform the divison by 4 repeatedly}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{/}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// if n \PYGZpc{} 4 != 0, then n \PYGZgt{} 1}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution repeatedly divides the given number \sphinxcode{\sphinxupquote{n}} by 4 until \sphinxcode{\sphinxupquote{n}} becomes either 1 or a number that is not divisible by 4. If \sphinxcode{\sphinxupquote{n}} becomes 1 after this process, it means that \sphinxcode{\sphinxupquote{n}} was originally a power of 4.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(logn)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Binary representation}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:solution-2-binary-representation}}
\sphinxAtStartPar
You can write down the binary representation of the powers of four to find the pattern.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
1   : 1
4   : 100
16  : 10000
64  : 1000000
256 : 100000000
...
\end{sphinxVerbatim}

\sphinxAtStartPar
You might notice the patterns are \sphinxstylestrong{n is a positive integer having only one bit \sphinxcode{\sphinxupquote{1}} in its binary representation and it is located at the odd positions} (starting from the right).

\sphinxAtStartPar
How can you formulate those conditions?

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{n}} has only one bit \sphinxcode{\sphinxupquote{1}} in its binary representation \sphinxcode{\sphinxupquote{10...0}}, then \sphinxcode{\sphinxupquote{n \sphinxhyphen{} 1}} has the complete opposite binary representation \sphinxcode{\sphinxupquote{01...1}}.

\sphinxAtStartPar
You can use the bit operator AND to formulate this condition

\begin{sphinxVerbatim}[commandchars=\\\{\}]
n \PYGZam{} (n \PYGZhy{} 1) == 0
\end{sphinxVerbatim}

\sphinxAtStartPar
Let \sphinxcode{\sphinxupquote{A}} be the number whose binary representation has only bits \sphinxcode{\sphinxupquote{1}} at all odd positions, then \sphinxcode{\sphinxupquote{n \& A}} is never \sphinxcode{\sphinxupquote{0}}.

\sphinxAtStartPar
In this problem, \sphinxcode{\sphinxupquote{A \textless{} 2\textasciicircum{}31}}. You can choose\sphinxcode{\sphinxupquote{A = 0x55555555}}, the hexadecimal of \sphinxcode{\sphinxupquote{0101 0101 0101 0101 0101 0101 0101 0101}}.


\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPowerOfFour}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// the condition of the pattern \PYGZdq{}n is a positive integer }
\PYG{+w}{    }\PYG{c+c1}{// having only one bit 1 in its binary representation and }
\PYG{+w}{    }\PYG{c+c1}{// it is located at the odd positions\PYGZdq{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{l+m+mh}{0x55555555}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{16}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfFour}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(1)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:key-takeaway}}
\sphinxAtStartPar
Recognizing the unique properties of powers of four, such as their binary representation, can lead to efficient solutions. Solution 2 leverages bitwise operations to check if a number meets the criteria of being a power of four.

\sphinxAtStartPar
By examining the binary representation and ensuring that the only set bit is located at an odd position, Solution 2 effectively determines whether the number is a power of four in constant time complexity, without the need for division operations.

\sphinxAtStartPar
But in term of readable code, Solution 2 is not easy to understand like Solution 1, where complexity of \sphinxcode{\sphinxupquote{O(logn)}} is not too bad.


\subsection{Exercise}
\label{\detokenize{Bit_Manipulation/342_Power_of_Four:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/power-of-two/}{Power of Two}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Find the Duplicate Number}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:find-the-duplicate-number}}\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number::doc}}

\subsection{Problem statement}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/find\sphinxhyphen{}the\sphinxhyphen{}duplicate\sphinxhyphen{}number/
%
\end{footnote}You have an array of integers called \sphinxcode{\sphinxupquote{nums}} that contains \sphinxcode{\sphinxupquote{n + 1}} integers. Each integer in the array falls within the range \sphinxcode{\sphinxupquote{{[}1, n{]}}} inclusive.

\sphinxAtStartPar
Within this array, there is only one number that appears more than once. Your task is to find and return this repeated number.

\sphinxAtStartPar
Importantly, you must solve this problem without making any modifications to the original array \sphinxcode{\sphinxupquote{nums}}, and you are only allowed to use a constant amount of extra space.


\subsubsection{Example 1}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,3,4,2,2]
Output: 2
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [3,1,3,4,2]
Output: 3
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums.length == n + 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums{[}i{]} \textless{}= n}}.

\item {} 
\sphinxAtStartPar
All the integers in \sphinxcode{\sphinxupquote{nums}} appear only once except for precisely one integer which appears two or more times.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
How can we prove that at least one duplicate number must exist in \sphinxcode{\sphinxupquote{nums}}?

\item {} 
\sphinxAtStartPar
Can you solve the problem in linear runtime complexity?

\end{itemize}


\subsection{Solution 1: Sorting}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:solution-1-sorting}}\index{Sorting@\spxentry{Sorting}}

\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{findDuplicate}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
The code relies on sorting to bring duplicate elements together, making it easy to identify them during the linear pass.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*logn)}} (sorting).

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Follow up}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:id2}}

\subsubsection{How can we prove that at least one duplicate number must exist in \sphinxstyleliteralintitle{\sphinxupquote{nums}}?}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:how-can-we-prove-that-at-least-one-duplicate-number-must-exist-in-nums}}
\sphinxAtStartPar
Due to \sphinxhref{https://en.wikipedia.org/wiki/Pigeonhole\_principle}{Pigeonhole principle}:

\sphinxAtStartPar
Here there are \sphinxcode{\sphinxupquote{n + 1}} pigeons in \sphinxcode{\sphinxupquote{n}} holes. The pigeonhole principle says that at least one hole has more than one pigeon.


\subsubsection{Can you solve the problem in linear runtime complexity?}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:can-you-solve-the-problem-in-linear-runtime-complexity}}
\sphinxAtStartPar
Here are a few solutions.


\subsection{Solution 2: Marking the visited numbers}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:solution-2-marking-the-visited-numbers}}

\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{findDuplicate}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// initialize n + 1 elements false}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{visited}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{        }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{visited}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{a}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{visited}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution utilizes a boolean array \sphinxcode{\sphinxupquote{visited}} to track visited elements.

\sphinxAtStartPar
It iterates through the elements of the input vector \sphinxcode{\sphinxupquote{nums}}, marking each element as visited by setting the corresponding index in the \sphinxcode{\sphinxupquote{visited}} array to true. Upon encountering a visited element, it immediately returns it as the duplicate element.

\sphinxAtStartPar
This approach efficiently identifies the duplicate element in the vector by tracking visited elements without requiring additional space proportional to the size of the input vector.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}.

\item {} 
\sphinxAtStartPar
Extra space: much less than \sphinxcode{\sphinxupquote{O(n)}}. \sphinxhref{https://en.cppreference.com/w/cpp/container/vector\_bool}{\sphinxcode{\sphinxupquote{std::vector\textless{}bool\textgreater{}}}} is optimized for space\sphinxhyphen{}efficient.

\end{itemize}


\subsection{Solution 3: Marking with std::bitset}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:solution-3-marking-with-std-bitset}}\index{std::bitset@\spxentry{std::bitset}}
\sphinxAtStartPar
Since \sphinxcode{\sphinxupquote{n \textless{}= 10\textasciicircum{}5}}, you can use this size for a \sphinxhref{https://en.cppreference.com/w/cpp/utility/bitset}{\sphinxcode{\sphinxupquote{std::bitset}}} to do the marking.


\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}bitset\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{findDuplicate}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// initialize visited = \PYGZsq{}000..0\PYGZsq{} with 100001 bits 0}
\PYG{+w}{    }\PYG{n}{bitset}\PYG{o}{\PYGZlt{}}\PYG{l+m+mi}{100001}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{visited}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{visited}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// set a\PYGZhy{}th bit to 1}
\PYG{+w}{        }\PYG{n}{visited}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findDuplicate}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This code uses a bitset to keep track of visited elements and quickly detects any duplicate element encountered during the iteration.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:key-takeaway}}
\sphinxAtStartPar
Different strategies can be employed to detect duplicates in an array, such as sorting followed by linear search, using a hash set to track visited elements, or utilizing a bitset to mark visited indices.

\sphinxAtStartPar
Each approach has its trade\sphinxhyphen{}offs in terms of time complexity, space complexity, and implementation simplicity. Understanding these trade\sphinxhyphen{}offs is crucial for you to select the most appropriate solution based on the problem constraints and requirements.


\subsection{Exercise}
\label{\detokenize{Bit_Manipulation/287_Find_the_Duplicate_Number:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/missing-number/}{Missing Number}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Maximum Product of Word Lengths}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:maximum-product-of-word-lengths}}\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths::doc}}

\subsection{Problem statement}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/maximum\sphinxhyphen{}product\sphinxhyphen{}of\sphinxhyphen{}word\sphinxhyphen{}lengths/
%
\end{footnote}Given a string array \sphinxcode{\sphinxupquote{words}}, return the maximum value of \sphinxcode{\sphinxupquote{length(word{[}i{]}) * length(word{[}j{]})}} where the two words do not share common letters. If no such two words exist, return \sphinxcode{\sphinxupquote{0}}.


\subsubsection{Example 1}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}abcw\PYGZdq{},\PYGZdq{}baz\PYGZdq{},\PYGZdq{}foo\PYGZdq{},\PYGZdq{}bar\PYGZdq{},\PYGZdq{}xtfn\PYGZdq{},\PYGZdq{}abcdef\PYGZdq{}]
Output: 16
Explanation: The two words can be \PYGZdq{}abcw\PYGZdq{}, \PYGZdq{}xtfn\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}a\PYGZdq{},\PYGZdq{}ab\PYGZdq{},\PYGZdq{}abc\PYGZdq{},\PYGZdq{}d\PYGZdq{},\PYGZdq{}cd\PYGZdq{},\PYGZdq{}bcd\PYGZdq{},\PYGZdq{}abcd\PYGZdq{}]
Output: 4
Explanation: The two words can be \PYGZdq{}ab\PYGZdq{}, \PYGZdq{}cd\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: words = [\PYGZdq{}a\PYGZdq{},\PYGZdq{}aa\PYGZdq{},\PYGZdq{}aaa\PYGZdq{},\PYGZdq{}aaaa\PYGZdq{}]
Output: 0
Explanation: No such pair of words.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2 \textless{}= words.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= words{[}i{]}.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{words{[}i{]}}} consists only of lowercase English letters.

\end{itemize}


\subsection{Solution 1: Bruteforce}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:solution-1-bruteforce}}
\sphinxAtStartPar
For each \sphinxcode{\sphinxupquote{words{[}i{]}}}, for all \sphinxcode{\sphinxupquote{words{[}j{]}}} with \sphinxcode{\sphinxupquote{j \textgreater{} i}}, check if they do not share common letters and compute the product of their lengths.


\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxProduct}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxP}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// visited marks all letters that appear in words[i] }
\PYG{+w}{        }\PYG{c+c1}{// words[i] consists of only 26 lowercase English letters}
\PYG{+w}{        }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{visited}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// map \PYGZsq{}a\PYGZsq{}\PYGZhy{}\PYGZgt{}0, \PYGZsq{}b\PYGZsq{}\PYGZhy{}\PYGZgt{}1, .., \PYGZsq{}z\PYGZsq{}\PYGZhy{}\PYGZgt{}25}
\PYG{+w}{            }\PYG{n}{visited}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// compare with all other words[j]         }
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{              }
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{visited}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{c+c1}{// this words[j] has common letter with words[i]}
\PYG{+w}{                    }\PYG{n}{found}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{                    }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{c+c1}{// if words[j] disjoints words[i]}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{found}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// compute and update max product of their lengths}
\PYG{+w}{                }\PYG{n}{maxP}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxP}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxP}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcw}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{baz}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{foo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xtfn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ab}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaaa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
16
4
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution checks for common characters between pairs of words to determine their product of lengths.

\sphinxAtStartPar
It iterates through each pair of words in the input vector \sphinxcode{\sphinxupquote{words}}, maintaining a boolean array \sphinxcode{\sphinxupquote{visited}} to mark the presence of characters in each word. By comparing the characters of each pair of words, it identifies whether there are any common characters. If no common characters are found, it computes the product of the lengths of the two words and updates the maximum product accordingly.

\sphinxAtStartPar
This approach optimizes the computation of the maximum product by efficiently checking for common characters between pairs of words without requiring additional space proportional to the length of the words.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2 * m)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Checking common letters using bit masking}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:solution-2-checking-common-letters-using-bit-masking}}\index{bit masking@\spxentry{bit masking}}
\sphinxAtStartPar
You can map a \sphinxcode{\sphinxupquote{words{[}i{]}}} to the bit representation of an integer \sphinxcode{\sphinxupquote{n}} by their characters like the following:
\begin{itemize}
\item {} 
\sphinxAtStartPar
If the word \sphinxcode{\sphinxupquote{words{[}i{]}}} contains the letter \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}}, the bit at position \sphinxcode{\sphinxupquote{0}} of \sphinxcode{\sphinxupquote{n}} is \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
If the word \sphinxcode{\sphinxupquote{words{[}i{]}}} contains the letter \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}}, the bit at position \sphinxcode{\sphinxupquote{1}} of \sphinxcode{\sphinxupquote{n}} is \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
…

\item {} 
\sphinxAtStartPar
If the word \sphinxcode{\sphinxupquote{words{[}i{]}}} contains the letter \sphinxcode{\sphinxupquote{\textquotesingle{}z\textquotesingle{}}}, the bit at position \sphinxcode{\sphinxupquote{25}} of \sphinxcode{\sphinxupquote{n}} is \sphinxcode{\sphinxupquote{1}}.

\end{itemize}

\sphinxAtStartPar
Then to check if two words have common letters, you just perform the bitwise operator AND on them.


\subsubsection{Example 1:}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The word \sphinxcode{\sphinxupquote{"abcw"}} is mapped to \sphinxcode{\sphinxupquote{00010000000000000000000111}}.

\item {} 
\sphinxAtStartPar
The word \sphinxcode{\sphinxupquote{"baz"}} is mapped to \sphinxcode{\sphinxupquote{10000000000000000000000011}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{"abcw" \& "baz" = 00000000000000000000000011}}. This value is not zero, which means they have common letters.

\end{itemize}

\sphinxAtStartPar
This technique is called bit masking.


\subsubsection{Code}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxProduct}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxP}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// initialize all elements of mask to 0}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{mask}\PYG{p}{(}\PYG{n}{words}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// mark all characters of word[i]}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// map \PYGZsq{}a\PYGZsq{}\PYGZhy{}\PYGZgt{}0, \PYGZsq{}b\PYGZsq{}\PYGZhy{}\PYGZgt{}1, .., \PYGZsq{}z\PYGZsq{}\PYGZhy{}\PYGZgt{}25}
\PYG{+w}{            }\PYG{c+c1}{// set the bit at that mapped position of mask[i] to 1}
\PYG{+w}{            }\PYG{n}{mask}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{        }
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{mask}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{mask}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// there is no common bit between mask[j] and mask[i]}
\PYG{+w}{                }\PYG{n}{maxP}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxP}\PYG{p}{,}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{words}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxP}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{string}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{words}\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcw}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{baz}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{foo}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bar}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{xtfn}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcdef}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ab}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{d}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{cd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{bcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{abcd}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{words}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaaa}\PYG{l+s}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProduct}\PYG{p}{(}\PYG{n}{words}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
16
4
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution represents each word in the input vector \sphinxcode{\sphinxupquote{words}} as a bitmask, where each bit represents the presence or absence of a character in the word.

\sphinxAtStartPar
By iterating through the words and constructing their corresponding bitmasks, it encodes the character information. Then, by comparing the bitmasks of pairs of words, it identifies whether there are any common characters between them. If no common characters are found, it computes the product of the lengths of the two words and updates the maximum product accordingly.

\sphinxAtStartPar
This approach optimizes the computation of the maximum product by using bitwise operations to efficiently check for common characters between pairs of words without requiring additional space proportional to the length of the words.


\subsubsection{Complexity}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n}} is the number of words in the input vector.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Tips}
\label{\detokenize{Bit_Manipulation/318_Maximum_Product_of_Word_Lengths:tips}}
\sphinxAtStartPar
Utilizing bit manipulation techniques, such as bitmasking, can significantly optimize the comparison process for determining common characters between words.

\sphinxAtStartPar
Solution 2 reduces the time complexity compared to brute force methods, particularly when dealing with large datasets, as it avoids nested loops and unnecessary character comparisons.


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Sorting}
\label{\detokenize{Sorting/index:sorting}}\label{\detokenize{Sorting/index::doc}}
\sphinxAtStartPar
The arrangement of the elements in an array can hold the key to improved efficiency and a deeper understanding of your code, which is explored in this chapter as it delves into the usage of sorting algorithms.

\sphinxAtStartPar
Sorting is similar to putting puzzle pieces to reveal the overall structure. Rearranging elements makes it possible to retrieve data more quickly, conduct searches more quickly, and even discover patterns and linkages that might otherwise go unnoticed.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Sorting:} Establish a strong foundation by understanding the significance of sorting, its impact on algorithmic performance, and the role of ordering in data analysis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stability and Uniqueness:} Learn about the concepts of stability and uniqueness in sorting and how they can impact the integrity and usefulness of sorted data.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Insights through Sorting:} Discover scenarios where sorted data provides valuable insights, such as identifying trends, anomalies, or patterns that inform decision\sphinxhyphen{}making.

\end{enumerate}

\sphinxstepscope


\section{Majority Element}
\label{\detokenize{Sorting/169_Majority_Element:majority-element}}\label{\detokenize{Sorting/169_Majority_Element::doc}}

\subsection{Problem statement}
\label{\detokenize{Sorting/169_Majority_Element:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/majority\sphinxhyphen{}element/
%
\end{footnote}You’re given an array \sphinxcode{\sphinxupquote{nums}} with a total of \sphinxcode{\sphinxupquote{n}} elements. Your task is to find and return the majority element.

\sphinxAtStartPar
The majority element is the element that appears more frequently in the array than any other element, specifically, it appears more than \sphinxcode{\sphinxupquote{n / 2}} times.

\sphinxAtStartPar
You can assume that the majority element always exists in the given array.


\subsubsection{Example 1}
\label{\detokenize{Sorting/169_Majority_Element:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [3,2,3]
Output: 3
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Sorting/169_Majority_Element:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2,2,1,1,1,2,2]
Output: 2
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Sorting/169_Majority_Element:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == nums.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 5 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}2\textasciicircum{}31 \textless{}= nums{[}i{]} \textless{}= 2\textasciicircum{}31 \sphinxhyphen{} 1}}.

\end{itemize}


\subsubsection{Follow\sphinxhyphen{}up:}
\label{\detokenize{Sorting/169_Majority_Element:follow-up}}
\sphinxAtStartPar
Could you solve the problem in linear time and in \sphinxcode{\sphinxupquote{O(1)}} space?


\subsection{Solution 1: Counting the frequency}
\label{\detokenize{Sorting/169_Majority_Element:solution-1-counting-the-frequency}}

\subsubsection{Code}
\label{\detokenize{Sorting/169_Majority_Element:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{majorityElement}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{HALF}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// count a\PYGZsq{}s occurrences}
\PYG{+w}{        }\PYG{n}{freq}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{freq}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{HALF}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
The code effectively counts the occurrences of each integer in the array and checks if any integer appears more than \sphinxcode{\sphinxupquote{n/2}} times. If so, it returns that integer as the majority element; otherwise, it defaults to the first element of the array.


\subsubsection{Complexity}
\label{\detokenize{Sorting/169_Majority_Element:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 2: Sorting and picking the middle element}
\label{\detokenize{Sorting/169_Majority_Element:solution-2-sorting-and-picking-the-middle-element}}

\subsubsection{Code}
\label{\detokenize{Sorting/169_Majority_Element:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{majorityElement}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
This code leverages the property of a majority element, which guarantees that it occupies the middle position in the sorted list of elements. Sorting the array allows us to easily access this middle element.


\subsubsection{Complexity}
\label{\detokenize{Sorting/169_Majority_Element:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*logn)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 3: Partial sort}
\label{\detokenize{Sorting/169_Majority_Element:solution-3-partial-sort}}\index{Partial sort@\spxentry{Partial sort}}
\sphinxAtStartPar
Since you are interested in only the middle element after sorting, the partial sorting algorithm \sphinxhref{https://en.cppreference.com/w/cpp/algorithm/nth\_element}{\sphinxcode{\sphinxupquote{std::nth\_element}}} can be used in this case to reduce the cost of the full sorting.


\subsubsection{Code}
\label{\detokenize{Sorting/169_Majority_Element:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{majorityElement}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{mid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// rearrange nums such that all elements less than or equal nums[mid] }
\PYG{+w}{    }\PYG{c+c1}{// are placed before nums[mid]}
\PYG{+w}{    }\PYG{n}{nth\PYGZus{}element}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{mid}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{majorityElement}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
The code uses the \index{std::nth\_element@\spxentry{std::nth\_element}}std::nth\_element function to rearrange the elements in the \sphinxcode{\sphinxupquote{nums}} vector such that the element at index \sphinxcode{\sphinxupquote{mid}} will be in its correct sorted position, and all elements before it will be less than or equal to it, while all elements after it will be greater than or equal to it.


\subsubsection{Complexity}
\label{\detokenize{Sorting/169_Majority_Element:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Modern C++ tips}
\label{\detokenize{Sorting/169_Majority_Element:modern-c-tips}}
\sphinxAtStartPar
In the code of Solution 3, the partial sorting algorithm \sphinxhref{https://en.cppreference.com/w/cpp/algorithm/nth\_element}{\sphinxcode{\sphinxupquote{std::nth\_element}}} will make sure for all indices \sphinxcode{\sphinxupquote{i}} and \sphinxcode{\sphinxupquote{j}} that satisfy \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{}= mid \textless{}= j \textless{} nums.length}},

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nums[i] \PYGZlt{}= nums[mid] \PYGZlt{}= nums[j].
\end{sphinxVerbatim}

\sphinxAtStartPar
In other words, \sphinxcode{\sphinxupquote{nums{[}mid{]}}} divides the array \sphinxcode{\sphinxupquote{nums}} into two groups: all elements that are less than or equal to \sphinxcode{\sphinxupquote{nums{[}mid{]}}} and the ones that are greater than or equal to \sphinxcode{\sphinxupquote{nums{[}mid{]}}}.

\sphinxAtStartPar
Those two groups are unsorted. That is why the algorithm is called \sphinxstyleemphasis{partial} sorting.


\subsection{Exercise}
\label{\detokenize{Sorting/169_Majority_Element:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/most-frequent-even-element/}{Most Frequent Even Element}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Merge Sorted Array}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:merge-sorted-array}}\label{\detokenize{Sorting/88_Merge_Sorted_Array::doc}}

\subsection{Problem statement}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/merge\sphinxhyphen{}sorted\sphinxhyphen{}array/
%
\end{footnote}You’re given two integer arrays, \sphinxcode{\sphinxupquote{nums1}} and \sphinxcode{\sphinxupquote{nums2}}, both sorted in non\sphinxhyphen{}decreasing order. Additionally, you have two integers, \sphinxcode{\sphinxupquote{m}} and \sphinxcode{\sphinxupquote{n}}, representing the number of elements in \sphinxcode{\sphinxupquote{nums1}} and \sphinxcode{\sphinxupquote{nums2}}, respectively.

\sphinxAtStartPar
Your task is to merge the elements from \sphinxcode{\sphinxupquote{nums2}} into \sphinxcode{\sphinxupquote{nums1}} in a way that the resulting array is sorted in non\sphinxhyphen{}decreasing order.

\sphinxAtStartPar
However, the sorted array should not be returned as a separate result. Instead, the merged elements should be stored inside the \sphinxcode{\sphinxupquote{nums1}} array. Here’s the setup for that purpose:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums1}} has a total length of \sphinxcode{\sphinxupquote{m + n}}, where the first \sphinxcode{\sphinxupquote{m}} elements represent the elements that should be merged, and the last \sphinxcode{\sphinxupquote{n}} elements are initialized to \sphinxcode{\sphinxupquote{0}} and should be ignored.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{nums2}} array has a length of \sphinxcode{\sphinxupquote{n}}, representing the elements to be merged from \sphinxcode{\sphinxupquote{nums2}} into the final \sphinxcode{\sphinxupquote{nums1}} array.

\end{itemize}


\subsubsection{Example 1}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums1.length == m + n}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums2.length == n}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= m, n \textless{}= 200}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m + n \textless{}= 200}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}9 \textless{}= nums1{[}i{]}, nums2{[}j{]} \textless{}= 10\textasciicircum{}9}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Can you come up with an algorithm that runs in \sphinxcode{\sphinxupquote{O(m + n)}} time?

\end{itemize}


\subsection{Solution 1: Store the result in a new container}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:solution-1-store-the-result-in-a-new-container}}

\subsubsection{Code}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{merge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// nums2 is done, only nums1 still runs}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// nums1 is done, only nums2 still runs}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{nums1}\PYG{p}{.}\PYG{n}{swap}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,2,3,5,6,]
[1,]
[1,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution merges two sorted arrays \sphinxcode{\sphinxupquote{nums1}} and \sphinxcode{\sphinxupquote{nums2}} into \sphinxcode{\sphinxupquote{nums1}} while maintaining sorted order. It iterates through both arrays, comparing elements and adding them to a temporary \sphinxcode{\sphinxupquote{result}} vector. After the merging is complete, it replaces the contents of \sphinxcode{\sphinxupquote{nums1}} with the merged result.


\subsubsection{Complexity}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m+n)}}, where \sphinxcode{\sphinxupquote{m = nums1.length}} and \sphinxcode{\sphinxupquote{n = nums2.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(m+n)}}.

\end{itemize}


\subsection{Solution 2: Reassigning \sphinxstyleliteralintitle{\sphinxupquote{nums1}} backward}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:solution-2-reassigning-nums1-backward}}

\subsubsection{Code}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{merge}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }
\PYG{p}{\PYGZob{}}\PYG{+w}{    }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// nums2 is done}
\PYG{+w}{            }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// nums1 is done}
\PYG{+w}{            }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{nums1}\PYG{p}{[}\PYG{n}{k}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{[}\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{merge}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{nums1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,2,3,5,6,]
[1,]
[1,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m+n)}}, where \sphinxcode{\sphinxupquote{m = nums1.length}} and \sphinxcode{\sphinxupquote{n = nums2.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:key-takeaway}}
\sphinxAtStartPar
Solution 2 efficiently merges two sorted arrays, \sphinxcode{\sphinxupquote{nums1}} and \sphinxcode{\sphinxupquote{nums2}}, into \sphinxcode{\sphinxupquote{nums1}} while preserving the sorted order. It uses three pointers (\sphinxcode{\sphinxupquote{k}}, \sphinxcode{\sphinxupquote{i}}, and \sphinxcode{\sphinxupquote{j}}) to perform the merge in reverse order, which helps avoid the need for additional space.


\subsection{Exercise}
\label{\detokenize{Sorting/88_Merge_Sorted_Array:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/squares-of-a-sorted-array/}{Squares of a Sorted Array}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Remove Covered Intervals}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:remove-covered-intervals}}\label{\detokenize{Sorting/1288_Remove_Covered_Intervals::doc}}

\subsection{Problem statement}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/remove\sphinxhyphen{}covered\sphinxhyphen{}intervals/
%
\end{footnote}You’re given an array called \sphinxcode{\sphinxupquote{intervals}}, where each element \sphinxcode{\sphinxupquote{intervals{[}i{]}}} is a pair \sphinxcode{\sphinxupquote{{[}li, ri{]}}} representing a half\sphinxhyphen{}open interval \sphinxcode{\sphinxupquote{{[}li, ri)}}.

\sphinxAtStartPar
Your task is to remove all intervals from the list that are completely covered by another interval. An interval \sphinxcode{\sphinxupquote{{[}a, b)}} is considered covered by the interval \sphinxcode{\sphinxupquote{{[}c, d)}} if and only if \sphinxcode{\sphinxupquote{c}} is less than or equal to \sphinxcode{\sphinxupquote{a}}, and \sphinxcode{\sphinxupquote{b}} is less than or equal to \sphinxcode{\sphinxupquote{d}}.

\sphinxAtStartPar
After removing the covered intervals, you need to return the number of remaining intervals.


\subsubsection{Example 1}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: intervals = [[1,4],[3,6],[2,8]]
Output: 2
Explanation: Interval [3,6] is covered by [2,8], therefore it is removed.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: intervals = [[1,4],[2,3]]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= intervals.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{intervals{[}i{]}.length == 2}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= li \textless{}= ri \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
All the given intervals are unique.

\end{itemize}


\subsection{Solution 1: Bruteforce}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:solution-1-bruteforce}}
\sphinxAtStartPar
For each interval \sphinxcode{\sphinxupquote{i}}, find if any other interval \sphinxcode{\sphinxupquote{j}} such that \sphinxcode{\sphinxupquote{j}} covers \sphinxcode{\sphinxupquote{i}} or \sphinxcode{\sphinxupquote{i}} covers \sphinxcode{\sphinxupquote{j}} then remove the smaller one from \sphinxcode{\sphinxupquote{intervals}}.


\subsubsection{Example 1}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{intervals = {[}{[}1,4{]},{[}3,6{]},{[}2,8{]}{]}}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
With interval \sphinxcode{\sphinxupquote{i = {[}1,4{]}}}, there is no other interval \sphinxcode{\sphinxupquote{j}} such that covers \sphinxcode{\sphinxupquote{i}} or \sphinxcode{\sphinxupquote{j}} covers \sphinxcode{\sphinxupquote{i}}.

\item {} 
\sphinxAtStartPar
With interval \sphinxcode{\sphinxupquote{i = {[}3,6{]}}}, there is interval \sphinxcode{\sphinxupquote{j = {[}2,8{]}}} convering \sphinxcode{\sphinxupquote{i}}. Remove \sphinxcode{\sphinxupquote{{[}3,6{]}}} from \sphinxcode{\sphinxupquote{intervals}}.

\end{itemize}

\sphinxAtStartPar
Final \sphinxcode{\sphinxupquote{intervals = {[}{[}1,4{]},{[}2,8{]}{]}}}.


\subsubsection{Code}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{c+c1}{//! @return true if the interval i is covered by j}
\PYG{k+kr}{inline}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isCovered}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{erase\PYGZus{}i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isCovered}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// remove intervals[i] from intervals}
\PYG{+w}{                }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{erase\PYGZus{}i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{                }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isCovered}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// remove intervals[j] from intervals}
\PYG{+w}{                }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{erase\PYGZus{}i}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{intervals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution effectively removes covered intervals and retains only those that do not have others covering them. The time complexity of this solution is \sphinxcode{\sphinxupquote{O(N\textasciicircum{}3)}}, where \sphinxcode{\sphinxupquote{N}} is the number of intervals, as it involves nested loops and potential removal of intervals from the list.


\subsubsection{Complexity}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N\textasciicircum{}3)}}, where \sphinxcode{\sphinxupquote{N = intervals.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Using dictionary order}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:solution-2-using-dictionary-order}}\index{dictionary order@\spxentry{dictionary order}}
\sphinxAtStartPar
You might know how to look up words in a dictionary.

\sphinxAtStartPar
The word \sphinxcode{\sphinxupquote{apple}} appears before \sphinxcode{\sphinxupquote{candy}} in the dictionary because the starting letter \sphinxcode{\sphinxupquote{a}} of \sphinxcode{\sphinxupquote{apple}} appears before \sphinxcode{\sphinxupquote{c}} of \sphinxcode{\sphinxupquote{candy}} in the English alphabet.

\sphinxAtStartPar
And \sphinxcode{\sphinxupquote{apple}} appears after \sphinxcode{\sphinxupquote{animal}} since the next letter \sphinxcode{\sphinxupquote{p}} appears after \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
The C++ Standard Library uses that dictionary order to compare two \sphinxcode{\sphinxupquote{std::vector}}s.


\subsubsection{Example 1}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:id3}}
\sphinxAtStartPar
Rewriting \sphinxcode{\sphinxupquote{intervals = {[}{[}1,4{]},{[}3,6{]},{[}2,8{]}{]}}} in dictionary order you get \sphinxcode{\sphinxupquote{intervals = {[}{[}1,4{]},{[}2,8{]},{[}3,6{]}{]}}}. In this order, the left bounds of the \sphinxcode{\sphinxupquote{intervals}} are sorted first.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{intervals}} is sorted like that, you can avoid bruteforce in Solution 1 by a simpler algorithm.

\sphinxAtStartPar
\sphinxstylestrong{Check if each interval \sphinxcode{\sphinxupquote{i}} covers or is covered by some of the previous ones.}

\sphinxAtStartPar
Remember that the left bound of interval \sphinxcode{\sphinxupquote{i}} is always bigger than or equal to all left bounds of the previous ones. So,
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{i}} is covered by some previous interval if the right bound of \sphinxcode{\sphinxupquote{i}} is less than some of the right bounds before.

\item {} 
\sphinxAtStartPar
Otherwise \sphinxcode{\sphinxupquote{i}} can only cover its exact previous one that has the same left bound.

\end{enumerate}


\subsubsection{Code}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// sort the intervals using dictionary order}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// count the intervals to be removed }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{      }
\PYG{+w}{    }\PYG{c+c1}{// keep track max right bound of all previous intervals}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxRight}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{    }\PYG{c+c1}{// log the left bound of the previous interval}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{preLeft}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}\PYG{+w}{   }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{maxRight}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// i\PYGZsq{}s right bound is less than some previous one\PYGZsq{}s}
\PYG{+w}{            }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{preLeft}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{            }\PYG{c+c1}{// i\PYGZsq{}s left bound is the same as exact previous one\PYGZsq{}s}
\PYG{+w}{            }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// update previous interval\PYGZsq{}s left bound}
\PYG{+w}{            }\PYG{n}{preLeft}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// update max right bound}
\PYG{+w}{        }\PYG{n}{maxRight}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxRight}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{intervals}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{intervals}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{removeCoveredIntervals}\PYG{p}{(}\PYG{n}{intervals}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N = intervals.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key takeaway}
\label{\detokenize{Sorting/1288_Remove_Covered_Intervals:key-takeaway}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Two \sphinxcode{\sphinxupquote{std::vector}}s can be compared using dictionary order.

\item {} 
\sphinxAtStartPar
Solution 2 first sorts the intervals and then iterates through them while keeping track of whether each interval is covered by others or not. The final result is the count of intervals that are not covered.

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{My Calendar I}
\label{\detokenize{Sorting/729_My_Calendar_I:my-calendar-i}}\label{\detokenize{Sorting/729_My_Calendar_I::doc}}

\subsection{Problem statement}
\label{\detokenize{Sorting/729_My_Calendar_I:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/my\sphinxhyphen{}calendar\sphinxhyphen{}i/
%
\end{footnote}You’re creating a program to use as your calendar. You can add new events to the calendar, but only if adding the event will not lead to a double booking.

\sphinxAtStartPar
A double booking occurs when two events have some time overlap, meaning there’s a shared time period between them.

\sphinxAtStartPar
An event is represented as a pair of integers: \sphinxcode{\sphinxupquote{start}} and \sphinxcode{\sphinxupquote{end}}, which represent the booking on a half\sphinxhyphen{}open interval \sphinxcode{\sphinxupquote{{[}start, end)}}. This interval includes all real numbers \sphinxcode{\sphinxupquote{x}} such that \sphinxcode{\sphinxupquote{start \textless{}= x \textless{} end}}.

\sphinxAtStartPar
You need to implement the \sphinxcode{\sphinxupquote{MyCalendar}} class, which has the following functions:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{MyCalendar()}}: Initializes the calendar object.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{boolean book(int start, int end)}}: This function checks if the event with the given \sphinxcode{\sphinxupquote{start}} and \sphinxcode{\sphinxupquote{end}} can be added to the calendar without causing a double booking. If it’s possible to add the event without a double booking, the function returns \sphinxcode{\sphinxupquote{true}}. Otherwise, it returns \sphinxcode{\sphinxupquote{false}}, and the event is not added to the calendar.

\end{enumerate}


\subsubsection{Example 1}
\label{\detokenize{Sorting/729_My_Calendar_I:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input
[\PYGZdq{}MyCalendar\PYGZdq{}, \PYGZdq{}book\PYGZdq{}, \PYGZdq{}book\PYGZdq{}, \PYGZdq{}book\PYGZdq{}]
[[], [10, 20], [15, 25], [20, 30]]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False. It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Sorting/729_My_Calendar_I:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= start \textless{} end \textless{}= 10\textasciicircum{}9}}.

\item {} 
\sphinxAtStartPar
At most \sphinxcode{\sphinxupquote{1000}} calls will be made to book.

\end{itemize}


\subsection{Solution 1: Vector}
\label{\detokenize{Sorting/729_My_Calendar_I:solution-1-vector}}
\sphinxAtStartPar
You can store the booked events in a vector and check the intersection condition whenever you add a new event.


\subsubsection{Code}
\label{\detokenize{Sorting/729_My_Calendar_I:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyCalendar}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}events}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{MyCalendar}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{book}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{\PYGZus{}events}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// check for overlap}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{second}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{start}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{end}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{.}\PYG{n}{first}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{\PYGZus{}events}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{MyCalendar}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This code essentially maintains a list of events and checks for overlaps when booking a new event. If no overlaps are found, it adds the new event to the list and allows the booking.


\subsubsection{Complexity}
\label{\detokenize{Sorting/729_My_Calendar_I:complexity}}
\sphinxAtStartPar
For the \sphinxcode{\sphinxupquote{book}} method:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n}}= \sphinxcode{\sphinxupquote{\_events.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Set}
\label{\detokenize{Sorting/729_My_Calendar_I:solution-2-set}}
\sphinxAtStartPar
Since the events have no intersection, they can be sorted. You can also consider two events to be the same if they intersect.

\sphinxAtStartPar
With that in mind, you can use \index{std::set@\spxentry{std::set}}std::set\sphinxhref{https://en.cppreference.com/w/cpp/container/set}{} to store the sorted unique events.


\subsubsection{Code}
\label{\detokenize{Sorting/729_My_Calendar_I:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}set\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{n}{Event}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pair}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{;}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{EventCmp}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{operator}\PYG{p}{(}\PYG{p}{)}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Event}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{lhs}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{Event}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{rhs}\PYG{p}{)}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{ }
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{lhs}\PYG{p}{.}\PYG{n}{second}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{rhs}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{class}\PYG{+w}{ }\PYG{n+nc}{MyCalendar}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{private}\PYG{o}{:}
\PYG{+w}{    }\PYG{c+c1}{// declare a set with custom comparison operator}
\PYG{+w}{    }\PYG{n}{set}\PYG{o}{\PYGZlt{}}\PYG{n}{Event}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{EventCmp}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}events}\PYG{p}{;}
\PYG{k}{public}\PYG{o}{:}
\PYG{+w}{    }\PYG{n}{MyCalendar}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n}{book}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}events}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{start}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{end}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// result.second stores a bool indicating }
\PYG{+w}{        }\PYG{c+c1}{// if the insertion was actually performed }
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{.}\PYG{n}{second}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{MyCalendar}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{25}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{.}\PYG{n}{book}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Sorting/729_My_Calendar_I:id3}}
\sphinxAtStartPar
For the \sphinxcode{\sphinxupquote{book}} method:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(logn)}}, where \sphinxcode{\sphinxupquote{n = \_events.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Sorting/729_My_Calendar_I:key-takeaway}}
\sphinxAtStartPar
Solution 2 efficiently handles event bookings by maintaining a sorted set of events based on their end times, allowing for quick overlap checks when booking new events.


\subsection{Exercise}
\label{\detokenize{Sorting/729_My_Calendar_I:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/determine-if-two-events-have-conflict/}{Determine if Two Events Have Conflict}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Remove Duplicates from Sorted Array II}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:remove-duplicates-from-sorted-array-ii}}\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array::doc}}

\subsection{Problem statement}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/remove\sphinxhyphen{}duplicates\sphinxhyphen{}from\sphinxhyphen{}sorted\sphinxhyphen{}array\sphinxhyphen{}ii/
%
\end{footnote}Given an integer array \sphinxcode{\sphinxupquote{nums}} already sorted in non\sphinxhyphen{}decreasing order, you must remove duplicates so that each unique element appears at most twice. The relative order of the elements should remain unchanged.

\sphinxAtStartPar
Since changing the array’s length in some programming languages is impossible, you must place the result in the first part of the \sphinxcode{\sphinxupquote{nums}} array. In other words, if there are \sphinxcode{\sphinxupquote{k}} elements after removing the duplicates, the first \sphinxcode{\sphinxupquote{k}} elements of \sphinxcode{\sphinxupquote{nums}} should contain the final result. Anything beyond the first \sphinxcode{\sphinxupquote{k}} elements is not important.

\sphinxAtStartPar
You should return the value of \sphinxcode{\sphinxupquote{k}} after placing the final result in the first \sphinxcode{\sphinxupquote{k}} slots of the \sphinxcode{\sphinxupquote{nums}} array.

\sphinxAtStartPar
The key requirement is to accomplish this task without using extra space for another array. It must be done by modifying the input array \sphinxcode{\sphinxupquote{nums}} in\sphinxhyphen{}place, using only \sphinxcode{\sphinxupquote{O(1)}} extra memory.


\subsubsection{Example 1}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,\PYGZus{}]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2, and 3, respectively.
What you leave does not matter beyond the returned k (hence, they are underscores).
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,\PYGZus{},\PYGZus{}]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3, and 3, respectively.
What you leave does not matter beyond the returned k (hence, they are underscores).
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 3 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}4 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums}} is sorted in \sphinxstylestrong{non\sphinxhyphen{}decreasing} order.

\end{itemize}


\subsection{Solution 1: Erasing the duplicates}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:solution-1-erasing-the-duplicates}}
\sphinxAtStartPar
In order for each unique element to appear \sphinxstylestrong{at most twice}, you have to erase the further appearances if they exist.

\sphinxAtStartPar
Since the array \sphinxcode{\sphinxupquote{nums}} is sorted, you can determine that existence by checking if \sphinxcode{\sphinxupquote{nums{[}i{]} == nums{[}i\sphinxhyphen{}2{]}}} for \sphinxcode{\sphinxupquote{2 \textless{}= i \textless{} nums.length}}.


\subsubsection{Code}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{removeDuplicates}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// find the element appearing more than twice}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{            }\PYG{c+c1}{// find all duplicates}
\PYG{+w}{            }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{c+c1}{// keep nums[i\PYGZhy{}2] and nums[i\PYGZhy{}1] remove all later duplicates }
\PYG{+w}{            }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{erase}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, [}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5, [1,1,2,2,3,]
7, [0,0,1,1,2,3,3,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently removes duplicates from the sorted array by checking for duplicates and erasing the excess occurrences while preserving two instances of each unique element. It then returns the length of the modified array.


\subsubsection{Complexity}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Worst case: \sphinxcode{\sphinxupquote{O(N\textasciicircum{}2/3)}}, where \sphinxcode{\sphinxupquote{N = nums.size()}}. The complexity of the \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/erase}{\sphinxcode{\sphinxupquote{erase()}}} method is linear in \sphinxcode{\sphinxupquote{N}}. The worst case is when \sphinxcode{\sphinxupquote{erase()}} is called maximum \sphinxcode{\sphinxupquote{N/3}} times.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Example of the worst case:
nums = [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6].
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
On average: \sphinxcode{\sphinxupquote{O(N)}} since the number of \sphinxcode{\sphinxupquote{erase()}} calls is \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Reassigning the satisfying elements}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:solution-2-reassigning-the-satisfying-elements}}
\sphinxAtStartPar
You might need to avoid the \sphinxcode{\sphinxupquote{erase()}} method in the solution above to reduce the complexity. Moreover, after removing the duplicates, the problem only cares about the first \sphinxcode{\sphinxupquote{k}} elements of the array \sphinxcode{\sphinxupquote{nums}}.

\sphinxAtStartPar
If you look at the final result after removing duplication, the \sphinxstylestrong{expected} \sphinxcode{\sphinxupquote{nums}} satisfies

\begin{sphinxVerbatim}[commandchars=\\\{\}]
nums[i] \PYGZgt{} nums[i\PYGZhy{}2] for 2 \PYGZlt{}= i \PYGZlt{} nums.length.
\end{sphinxVerbatim}

\sphinxAtStartPar
You can use this invariant to \sphinxstylestrong{reassign} the array \sphinxcode{\sphinxupquote{nums}} only the satisfied elements.


\subsubsection{Code}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{removeDuplicates}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// make sure nums[k] != nums[k\PYGZhy{}2]}
\PYG{+w}{            }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{k}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{, [}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{removeDuplicates}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
Output:
5, [1,1,2,2,3,]
7, [0,0,1,1,2,3,3,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = nums.size()}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:key-takeaway}}
\sphinxAtStartPar
Solution 2 effectively modifies the input array in\sphinxhyphen{}place, removing duplicates that occur more than twice while maintaining the desired order of unique elements. It does so in a single pass through the array, resulting in a time complexity of \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of elements in the array.


\subsection{Exercise}
\label{\detokenize{Sorting/80_Remove_Duplicates_from_Sorted_Array:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/remove-duplicates-from-sorted-array/}{Remove Duplicates from Sorted Array}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Greedy Algorithm}
\label{\detokenize{Greedy/index:greedy-algorithm}}\label{\detokenize{Greedy/index::doc}}
\sphinxAtStartPar
This chapter will explore a fascinating and highly practical problem\sphinxhyphen{}solving approach known as \sphinxstylestrong{greedy algorithms}. Greedy algorithms are powerful tools for making decisions at each step of an optimization problem, often leading to efficient and near\sphinxhyphen{}optimal solutions.

\sphinxAtStartPar
In this chapter, we’ll dive deep into the world of greedy algorithms, learning how to apply them to a wide range of real\sphinxhyphen{}world scenarios. Here’s what you can look forward to:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Understanding Greedy Algorithms}: We’ll begin by establishing a solid foundation in greedy algorithms. You’ll understand this approach’s key principles, advantages, and limitations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The Greedy Choice Property}: Discover the core characteristic of greedy algorithms—the greedy choice property. Learn how it guides us in making locally optimal decisions at each step.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Greedy for Searching}: Greedy algorithms can also be applied to search problems. We’ll delve into graph traversal algorithms and heuristic search methods.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Exercises and Problems}: Reinforce your understanding of greedy algorithms with exercises and LeetCode problems covering a wide range of greedy\sphinxhyphen{}based challenges. Practice is essential for mastering this problem\sphinxhyphen{}solving technique.

\end{enumerate}

\sphinxAtStartPar
By the end of this chapter, you’ll have a comprehensive understanding of greedy algorithms and the ability to apply them to a wide range of problems, from optimization to search. Greedy algorithms are valuable tools in your problem\sphinxhyphen{}solving toolkit, and this chapter will equip you with the skills needed to confidently tackle complex optimization challenges. So, let’s dive in and explore the world of greedy algorithms!

\sphinxstepscope


\section{Can Place Flowers}
\label{\detokenize{Greedy/605_Can_Place_Flowers:can-place-flowers}}\label{\detokenize{Greedy/605_Can_Place_Flowers::doc}}

\subsection{Problem statement}
\label{\detokenize{Greedy/605_Can_Place_Flowers:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/can\sphinxhyphen{}place\sphinxhyphen{}flowers/
%
\end{footnote}You are presented with a long flowerbed containing plots, some of which are planted with flowers (denoted by \sphinxcode{\sphinxupquote{1}}) and some are empty (denoted by \sphinxcode{\sphinxupquote{0}}). Flowers cannot be planted in \sphinxstylestrong{adjacent} plots. You are given an integer array \sphinxcode{\sphinxupquote{flowerbed}} representing the layout of the flowerbed, and an integer \sphinxcode{\sphinxupquote{n}} representing the number of new flowers you want to plant.

\sphinxAtStartPar
Your task is to determine if it is possible to plant \sphinxcode{\sphinxupquote{n}} new flowers in the \sphinxcode{\sphinxupquote{flowerbed}} without violating the rule of no\sphinxhyphen{}adjacent\sphinxhyphen{}flowers. If it is possible, return \sphinxcode{\sphinxupquote{true}}; otherwise, return \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Example 1}
\label{\detokenize{Greedy/605_Can_Place_Flowers:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Greedy/605_Can_Place_Flowers:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Greedy/605_Can_Place_Flowers:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= flowerbed.length \textless{}= 2 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{flowerbed{[}i{]}}} is \sphinxcode{\sphinxupquote{0}} or \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
There are no two adjacent flowers in \sphinxcode{\sphinxupquote{flowerbed}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= n \textless{}= flowerbed.length}}.

\end{itemize}


\subsection{Solution: Check the no\sphinxhyphen{}adjacent\sphinxhyphen{}flowers rule}
\label{\detokenize{Greedy/605_Can_Place_Flowers:solution-check-the-no-adjacent-flowers-rule}}
\sphinxAtStartPar
A new flower can be planted at position \sphinxcode{\sphinxupquote{i}} only if

\begin{sphinxVerbatim}[commandchars=\\\{\}]
flowerbed[i \PYGZhy{} 1] == 0 \PYGZam{}\PYGZam{} flowerbed[i] == 0 \PYGZam{}\PYGZam{} flowerbed[i + 1] == 0.
\end{sphinxVerbatim}

\sphinxAtStartPar
If the condition is satisfied, the flower can be planted at position \sphinxcode{\sphinxupquote{i}}. \sphinxcode{\sphinxupquote{flowerbed{[}i{]}}} is now assigned to \sphinxcode{\sphinxupquote{1}}. Then you can skip checking the rule for the position \sphinxcode{\sphinxupquote{i + 1}} and go directly to position \sphinxcode{\sphinxupquote{i + 2}}.


\subsubsection{Code}
\label{\detokenize{Greedy/605_Can_Place_Flowers:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{canPlaceFlowers}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{flowerbed}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{flowerbed}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{flowerbed}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{flowerbed}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{flowerbed}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{flowerbed}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{flowerbed}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{flowerbed}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// plant i if it satisfies the no\PYGZhy{}adjacent condition}
\PYG{+w}{            }\PYG{n}{flowerbed}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// have planted all n}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{flowerbed}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{canPlaceFlowers}\PYG{p}{(}\PYG{n}{flowerbed}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{flowerbed}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{canPlaceFlowers}\PYG{p}{(}\PYG{n}{flowerbed}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently iterates through the flowerbed, planting flowers wherever possible while adhering to the constraints. It returns \sphinxcode{\sphinxupquote{true}} if it’s possible to plant all the required flowers and \sphinxcode{\sphinxupquote{false}} otherwise.


\subsubsection{Complexity}
\label{\detokenize{Greedy/605_Can_Place_Flowers:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = flowerbed.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Implementation tips}
\label{\detokenize{Greedy/605_Can_Place_Flowers:implementation-tips}}\begin{itemize}
\item {} 
\sphinxAtStartPar
In this implementation, you could insert element \sphinxcode{\sphinxupquote{0}} to the front and the back of vector \sphinxcode{\sphinxupquote{flowerbed}} to avoid writing extra code for checking the no\sphinxhyphen{}adjacent\sphinxhyphen{}flowers rule at \sphinxcode{\sphinxupquote{i = 0}} and \sphinxcode{\sphinxupquote{i = flowerbed.size() \sphinxhyphen{} 1}}.

\item {} 
\sphinxAtStartPar
There are a few ways to insert an element to a vector. Here you can see an example of using the methods \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/insert}{\sphinxcode{\sphinxupquote{insert}}} and \sphinxhref{https://en.cppreference.com/w/cpp/container/vector/push\_back}{\sphinxcode{\sphinxupquote{push\_back}}} of a \sphinxhref{https://en.cppreference.com/w/cpp/container/vector}{\sphinxcode{\sphinxupquote{std::vector}}}.

\end{itemize}


\subsection{Ecercise}
\label{\detokenize{Greedy/605_Can_Place_Flowers:ecercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/teemo-attacking/}{Teemo Attacking}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Minimum Deletions to Make Character Frequencies Unique}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:minimum-deletions-to-make-character-frequencies-unique}}\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique::doc}}

\subsection{Problem statement}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/minimum\sphinxhyphen{}deletions\sphinxhyphen{}to\sphinxhyphen{}make\sphinxhyphen{}character\sphinxhyphen{}frequencies\sphinxhyphen{}unique/
%
\end{footnote}A string \sphinxcode{\sphinxupquote{s}} is considered “good” if there are no two different characters in the string that have the same frequency, meaning each character appears a unique number of times.

\sphinxAtStartPar
You’re given a string \sphinxcode{\sphinxupquote{s}}, and your task is to determine the minimum number of characters you need to delete from \sphinxcode{\sphinxupquote{s}} to make it a “good” string.

\sphinxAtStartPar
The frequency of a character in a string is the count of times that character appears in the string. For instance, in the string \sphinxcode{\sphinxupquote{"aab"}}, the frequency of \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}} is \sphinxcode{\sphinxupquote{2}}, and the frequency of \sphinxcode{\sphinxupquote{\textquotesingle{}b\textquotesingle{}}} is \sphinxcode{\sphinxupquote{1}}.


\subsubsection{Example 1}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}aab\PYGZdq{}
Output: 0
Explanation: s is already good.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}aaabbbcc\PYGZdq{}
Output: 2
Explanation: You can delete two \PYGZsq{}b\PYGZsq{}s resulting in the good string \PYGZdq{}aaabcc\PYGZdq{}.
Another way is to delete one \PYGZsq{}b\PYGZsq{} and one \PYGZsq{}c\PYGZsq{} resulting in the good string \PYGZdq{}aaabbc\PYGZdq{}.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}ceabaacb\PYGZdq{}
Output: 2
Explanation: You can delete both \PYGZsq{}c\PYGZsq{}s resulting in the good string \PYGZdq{}eabaab\PYGZdq{}.
Note that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} contains only lowercase English letters.

\end{itemize}


\subsection{Solution: Delete the frequencies in sorted order}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:solution-delete-the-frequencies-in-sorted-order}}
\sphinxAtStartPar
Your goal is to make all the frequencies be different.

\sphinxAtStartPar
One way of doing that is by sorting the frequencies and performing the deletion.


\subsubsection{Example 4}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:example-4}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{s = "ceaacbb"}}, the frequencies of the characters are: \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}a\textquotesingle{}{]} = 2, freq{[}\textquotesingle{}b\textquotesingle{}{]} = 2, freq{[}\textquotesingle{}c\textquotesingle{}{]} = 2}} and \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}e\textquotesingle{}{]} = 1}}. They are already in sorted order.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Let the current frequency be the first frequency \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}a\textquotesingle{}{]} = 2}}.

\item {} 
\sphinxAtStartPar
The next frequency is \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}b\textquotesingle{}{]} = 2}}, equal to the current frequency. Delete one appearance to make the current frequency be \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
The next frequency is \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}c\textquotesingle{}{]} = 2}}, bigger than the current frequency. Delete two appearances to make the current frequency be \sphinxcode{\sphinxupquote{0}}.

\item {} 
\sphinxAtStartPar
Because the current frequency is \sphinxcode{\sphinxupquote{0}}, delete all appearances of the remaining frequencies, which is \sphinxcode{\sphinxupquote{freq{[}\textquotesingle{}e\textquotesingle{}{]} = 1}}.

\item {} 
\sphinxAtStartPar
In total, there are \sphinxcode{\sphinxupquote{4}} deletions.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minDeletions}\PYG{p}{(}\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// map \PYGZsq{}a\PYGZsq{}\PYGZhy{}\PYGZgt{}0, \PYGZsq{}b\PYGZsq{}\PYGZhy{}\PYGZgt{}1, ..,\PYGZsq{}z\PYGZsq{}\PYGZhy{}\PYGZgt{}25}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{(}\PYG{l+m+mi}{26}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{char}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// count the frequency of character c}
\PYG{+w}{        }\PYG{n}{freq}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// sort freq in descending order}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{freq}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{greater}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{deletion}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{currentFreq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// start with the max frequency}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{currentFreq}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// delete all remaining characters}
\PYG{+w}{            }\PYG{n}{deletion}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{freq}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{currentFreq}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// delete just enough to make the freq[i] \PYGZlt{} currentFreq}
\PYG{+w}{            }\PYG{n}{deletion}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{currentFreq}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{currentFreq}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// do not delete on freq[i] \PYGZlt{} currentFreq}
\PYG{+w}{            }\PYG{n}{currentFreq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{freq}\PYG{p}{.}\PYG{n}{at}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{deletion}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minDeletions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aab}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minDeletions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aaabbbcc}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minDeletions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ceabaacb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
0
2
2
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = s.length}};

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:key-takeaway}}
\sphinxAtStartPar
The problem of determining the minimum number of deletions required to make character frequencies unique can be efficiently solved by counting the frequencies of characters and iteratively adjusting the frequencies to ensure uniqueness.

\sphinxAtStartPar
This solution achieves this by first counting the frequencies of characters and then sorting them in descending order. By iteratively processing the sorted frequencies, the solution ensures that each character frequency is unique while minimizing the number of deletions required.


\subsection{Exercise}
\label{\detokenize{Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-deletions-to-make-array-beautiful/}{Minimum Deletions to Make Array Beautiful}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Wiggle Subsequence}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:wiggle-subsequence}}\label{\detokenize{Greedy/376_Wiggle_Subsequence::doc}}

\subsection{Problem statement}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/wiggle\sphinxhyphen{}subsequence/
%
\end{footnote}A \sphinxstylestrong{wiggle sequence} is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non\sphinxhyphen{}equal elements are trivially wiggle sequences.
\begin{itemize}
\item {} 
\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{{[}1, 7, 4, 9, 2, 5{]}}} is a wiggle sequence because the differences \sphinxcode{\sphinxupquote{(6, \sphinxhyphen{}3, 5, \sphinxhyphen{}7, 3)}} alternate between positive and negative.

\item {} 
\sphinxAtStartPar
In contrast, \sphinxcode{\sphinxupquote{{[}1, 4, 7, 2, 5{]}}} and \sphinxcode{\sphinxupquote{{[}1, 7, 4, 5, 5{]}}} are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.

\end{itemize}

\sphinxAtStartPar
A \sphinxstylestrong{subsequence} is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.

\sphinxAtStartPar
Given an integer array \sphinxcode{\sphinxupquote{nums}}, return the length of the longest wiggle subsequence of \sphinxcode{\sphinxupquote{nums}}.


\subsubsection{Example 1}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, \PYGZhy{}3, 5, \PYGZhy{}7, 3).
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, \PYGZhy{}7, 3, \PYGZhy{}3, 6, \PYGZhy{}8).
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= nums{[}i{]} \textless{}= 1000}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you solve this in \sphinxcode{\sphinxupquote{O(n)}} time?

\end{itemize}


\subsection{Solution: Counting the local extrema of \sphinxstyleliteralintitle{\sphinxupquote{nums}}}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:solution-counting-the-local-extrema-of-nums}}
\sphinxAtStartPar
First, if you pick all local extrema (minima and maxima) of \sphinxcode{\sphinxupquote{nums}} to form a subsequence \sphinxcode{\sphinxupquote{e}}, then it is wiggle. Let us call it an \sphinxstylestrong{extrema} subsequence.


\subsubsection{Example 2}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}1,17,5,10,13,15,10,5,16,8{]}}}, the local extrema are \sphinxcode{\sphinxupquote{{[}1,17,5,15,5,16,8{]}}}. It is wiggle and called \sphinxstylestrong{extrema} subsequence.

\sphinxAtStartPar
Note that if \sphinxcode{\sphinxupquote{nums.length = n}} then \sphinxcode{\sphinxupquote{nums{[}0{]}}} and \sphinxcode{\sphinxupquote{nums{[}n \sphinxhyphen{} 1{]}}} are always the first and the last extremum.

\sphinxAtStartPar
Second, given any two successive local extrema \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{b}}, you cannot have any wiggle subsequence between them. Because the elements between them are either monotonic increasing or decreasing.

\sphinxAtStartPar
That proves the extrema subsequence is the longest wiggle one.


\subsubsection{Code}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{wiggleMaxLength}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// nums[0] is always the first extremum}
\PYG{+w}{    }\PYG{c+c1}{// start to find the second extremum}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// all nums[i] are equal}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sign}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{sign}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// nums[i] is an extremum}
\PYG{+w}{            }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{sign}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{n}{sign}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{wiggleMaxLength}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{17}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{16}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{wiggleMaxLength}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{wiggleMaxLength}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
6
7
2
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Greedy/376_Wiggle_Subsequence:key-takeaway}}
\sphinxAtStartPar
The problem of finding the length of the longest wiggle subsequence can be efficiently solved using a greedy approach. The solution iterates through the input array, identifying alternating extremums (peaks and valleys) to form the wiggle subsequence.

\sphinxAtStartPar
By keeping track of the current trend direction (increasing or decreasing), the solution efficiently identifies extremums and increments the count accordingly. This greedy approach ensures that each extremum contributes to increasing the length of the wiggle subsequence, maximizing its overall length.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Partitioning Into Minimum Number Of Deci\sphinxhyphen{}Binary Numbers}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:partitioning-into-minimum-number-of-deci-binary-numbers}}\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers::doc}}

\subsection{Problem statement}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/partitioning\sphinxhyphen{}into\sphinxhyphen{}minimum\sphinxhyphen{}number\sphinxhyphen{}of\sphinxhyphen{}deci\sphinxhyphen{}binary\sphinxhyphen{}numbers/
%
\end{footnote}A decimal number is called deci\sphinxhyphen{}binary if each of its digits is either \sphinxcode{\sphinxupquote{0}} or \sphinxcode{\sphinxupquote{1}} without any leading zeros. For example, \sphinxcode{\sphinxupquote{101}} and \sphinxcode{\sphinxupquote{1100}} are deci\sphinxhyphen{}binary, while \sphinxcode{\sphinxupquote{112}} and \sphinxcode{\sphinxupquote{3001}} are not.

\sphinxAtStartPar
Given a string \sphinxcode{\sphinxupquote{n}} that represents a positive decimal integer, return the minimum number of positive deci\sphinxhyphen{}binary numbers needed so that they sum up to \sphinxcode{\sphinxupquote{n}}.


\subsubsection{Example 1}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = \PYGZdq{}32\PYGZdq{}
Output: 3
Explanation: 10 + 11 + 11 = 32
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = \PYGZdq{}82734\PYGZdq{}
Output: 8
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = \PYGZdq{}27346209830709182346\PYGZdq{}
Output: 9
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n}} consists of only digits.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n}} does not contain any leading zeros and represents a positive integer.

\end{itemize}


\subsection{Solution: Identify the maximum digit of \sphinxstyleliteralintitle{\sphinxupquote{n}}}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:solution-identify-the-maximum-digit-of-n}}
\sphinxAtStartPar
Any digit \sphinxcode{\sphinxupquote{d}} can be obtained by summing the digit \sphinxcode{\sphinxupquote{1}} \sphinxcode{\sphinxupquote{d}} times.

\sphinxAtStartPar
The problem turns into identifying the maximum digit of \sphinxcode{\sphinxupquote{n}}.


\subsubsection{Example 2}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{n = "82734"}} the answer is 8 because:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
  82734
= 11111 
+ 11111 
+ 10111 
+ 10101 
+ 10100
+ 10100
+ 10100
+ 10000
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minPartitions}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{maxDigit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{maxDigit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxDigit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxDigit}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{0}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minPartitions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{32}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minPartitions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{82734}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minPartitions}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{27346209830709182346}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
8
9
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = n.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers:key-takeaway}}
\sphinxAtStartPar
This problem can be efficiently solved by identifying the maximum digit in the string. Since each deci\sphinxhyphen{}binary number can only contain digits from 0 to 9, the maximum digit determines the minimum number of deci\sphinxhyphen{}binary numbers needed.

\sphinxAtStartPar
By finding the maximum digit in the string and converting it to an integer, the solution effectively determines the minimum number of deci\sphinxhyphen{}binary numbers required.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Maximum Units on a Truck}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:maximum-units-on-a-truck}}\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck::doc}}

\subsection{Problem statement}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/maximum\sphinxhyphen{}units\sphinxhyphen{}on\sphinxhyphen{}a\sphinxhyphen{}truck/
%
\end{footnote}You are assigned to put some amount of boxes onto one truck. You are given a 2D array \sphinxcode{\sphinxupquote{boxTypes}}, where \sphinxcode{\sphinxupquote{boxTypes{[}i{]} = {[}numberOfBoxes\_i, numberOfUnitsPerBox\_i{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numberOfBoxes\_i}} is the number of boxes of type \sphinxcode{\sphinxupquote{i}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{numberOfUnitsPerBox\_i}} is the number of units in each box of the type \sphinxcode{\sphinxupquote{i}}.

\end{itemize}

\sphinxAtStartPar
You are also given an integer \sphinxcode{\sphinxupquote{truckSize}}, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed \sphinxcode{\sphinxupquote{truckSize}}.

\sphinxAtStartPar
Return the maximum total number of units that can be put on the truck.


\subsubsection{Example 1}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4
Output: 8
Explanation: There are:
\PYGZhy{} 1 box of the first type that contains 3 units.
\PYGZhy{} 2 boxes of the second type that contain 2 units each.
\PYGZhy{} 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10
Output: 91
Explanation: (5 * 10) + (3 * 9) + (2 * 7) = 91.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= boxTypes.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= numberOfBoxes\_i, numberOfUnitsPerBox\_i \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= truckSize \textless{}= 10\textasciicircum{}6}}.

\end{itemize}


\subsection{Solution: Greedy algorithm}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:solution-greedy-algorithm}}
\sphinxAtStartPar
Put the boxes having more units first.


\subsubsection{Code}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maximumUnits}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{truckSize}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// sort for the boxes based on their number of units}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{boxTypes}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{         }\PYG{p}{[}\PYG{p}{]}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{b}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{         }\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxUnits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{truckSize}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{boxTypes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{truckSize}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// put all boxTypes[i] if there is still room}
\PYG{+w}{            }\PYG{n}{maxUnits}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{truckSize}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// can put only truckSize \PYGZlt{} boxTypes[i][0] of boxTypes[i]}
\PYG{+w}{            }\PYG{n}{maxUnits}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{truckSize}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxUnits}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{boxTypes}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maximumUnits}\PYG{p}{(}\PYG{n}{boxTypes}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{boxTypes}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maximumUnits}\PYG{p}{(}\PYG{n}{boxTypes}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{10}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
8
91
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution optimally loads boxes onto a truck to maximize the total number of units that can be transported, considering both the number of boxes available and their units per box.


\subsubsection{Complexity}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*logN)}}, where \sphinxcode{\sphinxupquote{N = boxTypes.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Modern C++ STL notes}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:modern-c-stl-notes}}
\sphinxAtStartPar
Note that two \sphinxhref{https://en.cppreference.com/w/cpp/container/vector}{\sphinxcode{\sphinxupquote{vector}}s} can be compared. That is why you can sort them.

\sphinxAtStartPar
But in this case you want to sort them based on the number of units. That is why you need to define the comparison function like the code above. Otherwise, the \index{std::sort@\spxentry{std::sort}}std::sort\sphinxhref{https://en.cppreference.com/w/cpp/algorithm/sort}{} algorithm will use the dictionary order to sort them by default.


\subsection{Exercise}
\label{\detokenize{Greedy/1710_Maximum_Units_on_a_Truck:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/}{Maximum Bags With Full Capacity of Rocks}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Dynamic Programming}
\label{\detokenize{Dynamic_Programming/index:dynamic-programming}}\label{\detokenize{Dynamic_Programming/index::doc}}
\sphinxAtStartPar
This chapter explains \sphinxstylestrong{dynamic programming}, a method for solving complex problems with strategic optimization. Elegant and efficient solutions can be found by breaking down problems into smaller subproblems and using memorization and recursion. It’s like solving a puzzle by solving smaller pieces and putting them together to form the larger picture.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Dynamic Programming:} Establish a solid foundation by understanding the core principles of dynamic programming, its advantages, and the problems it best suits.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Overlapping Subproblems and Optimal Substructure:} Delve into the key concepts that underlie dynamic programming, namely identifying overlapping subproblems and exploiting optimal substructure.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Fibonacci Series and Beyond:} Begin with classic examples like solving the Fibonacci series and gradually progress to more intricate problems that involve complex optimization.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Efficiency and Trade\sphinxhyphen{}offs:} Understand the trade\sphinxhyphen{}offs involved in dynamic programming, including the balance between time and space complexity.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving Strategies:} Develop systematic strategies for approaching dynamic programming problems, from identifying subproblems to deriving recurrence relations.

\end{enumerate}

\sphinxstepscope


\section{Fibonacci Number}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:fibonacci-number}}\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number::doc}}\index{Fibonacci Number@\spxentry{Fibonacci Number}}

\subsection{Problem statement}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/fibonacci\sphinxhyphen{}number/
%
\end{footnote}The Fibonacci numbers make up a sequence denoted as \sphinxcode{\sphinxupquote{F(n)}}, known as the Fibonacci sequence. Each number in this sequence is the sum of the two preceding numbers, with the sequence starting from \sphinxcode{\sphinxupquote{0}} and \sphinxcode{\sphinxupquote{1}}. In other words:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
F(0) = 0, F(1) = 1
F(n) = F(n \PYGZhy{} 1) + F(n \PYGZhy{} 2), for n \PYGZgt{} 1.
\end{sphinxVerbatim}

\sphinxAtStartPar
Your task is to calculate the value of \sphinxcode{\sphinxupquote{F(n)}} given an integer \sphinxcode{\sphinxupquote{n}}.


\subsubsection{Example 1}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 2
Output: 1
Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 3
Output: 2
Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 4
Output: 3
Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= n \textless{}= 30}}.

\end{itemize}


\subsection{Solution 1: Recursive}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:solution-1-recursive}}

\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{fib}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution computes the nth Fibonacci number using a recursive approach.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:complexity}}
\sphinxAtStartPar
The time complexity of this solution is exponential, specifically \sphinxcode{\sphinxupquote{O(2\textasciicircum{}n)}}. This is because it repeatedly makes two recursive calls for each \sphinxcode{\sphinxupquote{n}}, resulting in an exponential number of function calls and calculations. As \sphinxcode{\sphinxupquote{n}} grows larger, the execution time increases significantly.

\sphinxAtStartPar
The space complexity of the given recursive Fibonacci solution is \sphinxcode{\sphinxupquote{O(n)}}. This space complexity arises from the function call stack when making recursive calls.

\sphinxAtStartPar
When you call the \sphinxcode{\sphinxupquote{fib}} function with a value of \sphinxcode{\sphinxupquote{n}}, it generates a call stack with a depth of \sphinxcode{\sphinxupquote{n}}, as each call to \sphinxcode{\sphinxupquote{fib}} leads to two more recursive calls (one for \sphinxcode{\sphinxupquote{n \sphinxhyphen{} 1}} and one for \sphinxcode{\sphinxupquote{n \sphinxhyphen{} 2}}) until \sphinxcode{\sphinxupquote{n}} reaches the base cases (0 or 1). The space required to store the function call stack is proportional to the depth of the recursion, which is \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
Therefore, the space complexity is linearly related to the input value \sphinxcode{\sphinxupquote{n}}, making it \sphinxcode{\sphinxupquote{O(n)}}. This can be a concern for large values of \sphinxcode{\sphinxupquote{n}} because it could lead to a stack overflow if \sphinxcode{\sphinxupquote{n}} is too large.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(2\textasciicircum{}n)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 2: Dynamic programming}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:solution-2-dynamic-programming}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{fib}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// store all computed Fibonacci numbers}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{f}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{f}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses dynamic programming to avoid redundant calculations by storing and reusing previously computed Fibonacci numbers.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:id2}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 3: Reduce space for dynamic programming}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:solution-3-reduce-space-for-dynamic-programming}}

\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{fib}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// store only two previous Fibonacci numbers}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{f0}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{f1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{f2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{f1}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{f0}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// update for next round}
\PYG{+w}{        }\PYG{n}{f0}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{f1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{f2}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{f1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{fib}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution calculates the nth Fibonacci number iteratively using two variables to keep track of the last two Fibonacci numbers.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway:}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:key-takeaway}}
\sphinxAtStartPar
The Fibonacci sequence can be efficiently computed using various techniques, including recursion with memoization, bottom\sphinxhyphen{}up dynamic programming, or even optimizing space usage by storing only the necessary previous Fibonacci numbers.

\sphinxAtStartPar
Solutions 2 and 3 demonstrate dynamic programming approaches, where Fibonacci numbers are computed iteratively while storing intermediate results to avoid redundant computations.

\sphinxAtStartPar
Solution 3 further optimizes space usage by only storing the necessary previous Fibonacci numbers, resulting in a space complexity of \sphinxcode{\sphinxupquote{O(1)}}. Understanding these different approaches and their trade\sphinxhyphen{}offs is essential for selecting the most appropriate solution based on the problem constraints and requirements.


\subsection{Exercise}
\label{\detokenize{Dynamic_Programming/509_Fibonacci_Number:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/n-th-tribonacci-number/}{N\sphinxhyphen{}th Tribonacci Number}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Unique Paths}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:unique-paths}}\label{\detokenize{Dynamic_Programming/62_Unique_Paths::doc}}

\subsection{Problem statement}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/unique\sphinxhyphen{}paths/
%
\end{footnote}A robot starts at the top\sphinxhyphen{}left corner of a grid with dimensions \sphinxcode{\sphinxupquote{m x n}}. It can move either down or right at each step. The robot’s goal is to reach the bottom\sphinxhyphen{}right corner of the grid.

\sphinxAtStartPar
The problem is to determine the number of unique paths the robot can take to reach the bottom\sphinxhyphen{}right corner.


\subsubsection{Example 1}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{62_robot_maze}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: m = 3, n = 7
Output: 28
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: m = 3, n = 2
Output: 3
Explanation:
From the top\PYGZhy{}left corner, there are a total of 3 ways to reach the bottom\PYGZhy{}right corner:
1. Right \PYGZhy{}\PYGZgt{} Down \PYGZhy{}\PYGZgt{} Down
2. Down \PYGZhy{}\PYGZgt{} Down \PYGZhy{}\PYGZgt{} Right
3. Down \PYGZhy{}\PYGZgt{} Right \PYGZhy{}\PYGZgt{} Down
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: m = 7, n = 3
Output: 28
\end{sphinxVerbatim}


\subsubsection{Example 4}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:example-4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: m = 3, n = 3
Output: 6
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m, n \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
It’s guaranteed that the answer will be less than or equal to \sphinxcode{\sphinxupquote{2*10\textasciicircum{}9}}.

\end{itemize}


\subsection{Solution 1: Recursive}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:solution-1-recursive}}
\sphinxAtStartPar
At each point, the robot has two ways of moving: right or down. Let \sphinxcode{\sphinxupquote{P(m,n)}} is the wanted result. Then you have a recursive relationship:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
P(m,n) = P(m\PYGZhy{}1, n) + P(m, n\PYGZhy{}1)
\end{sphinxVerbatim}

\sphinxAtStartPar
If the grid has only one row or only one column, then there is only one possible path.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
P(1, n) = P(m, 1) = 1.
\end{sphinxVerbatim}

\sphinxAtStartPar
We have a recursive implementation.


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{uniquePaths}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
28
28
3
6
\end{sphinxVerbatim}

\sphinxAtStartPar
This is a recursive solution that breaks down the problem into two subproblems:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uniquePaths(m\sphinxhyphen{}1, n)}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uniquePaths(m, n\sphinxhyphen{}1)}}

\end{itemize}

\sphinxAtStartPar
Each recursive call reduces either the \sphinxcode{\sphinxupquote{m}} or \sphinxcode{\sphinxupquote{n}} value by 1.

\sphinxAtStartPar
The base case is when \sphinxcode{\sphinxupquote{m == 1}} or \sphinxcode{\sphinxupquote{n == 1}}, where there is only 1 unique path.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:complexity}}
\sphinxAtStartPar
To calculate the complexity, let’s look at the recursion tree:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uniquePaths(m,n)}} calls:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uniquePaths(m\sphinxhyphen{}1,n)}}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{uniquePaths(m, n\sphinxhyphen{}1)}}

\end{itemize}

\item {} 
\sphinxAtStartPar
Each of those calls two more calls and so on.

\end{itemize}

\sphinxAtStartPar
The height of the tree will be \sphinxcode{\sphinxupquote{max(m,n)}}. At each level, there are 2 branches.

\sphinxAtStartPar
So the total number of nodes in the tree will be \sphinxcode{\sphinxupquote{2\textasciicircum{}max(m,n)}}.

\sphinxAtStartPar
Since each node represents a function call, the runtime complexity is \sphinxcode{\sphinxupquote{O(2\textasciicircum{}max(m,n))}}.

\sphinxAtStartPar
The space complexity is \sphinxcode{\sphinxupquote{O(max(m,n))}} due to the call stack.

\sphinxAtStartPar
In summary, the complexities are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(2\textasciicircum{}max(m,n)}}, where \sphinxcode{\sphinxupquote{m x n}} is the size of the grid.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(max(m,n)}}.

\end{itemize}


\subsection{Solution 2: Dynamic programming}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:solution-2-dynamic-programming}}
\sphinxAtStartPar
The recursive implementation repeats a lot of computations.

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{uniquePaths(2,2)}} was recomputed in both \sphinxcode{\sphinxupquote{uniquePaths(2,3)}} and \sphinxcode{\sphinxupquote{uniquePaths(3,2)}} when you compute \sphinxcode{\sphinxupquote{uniquePaths(3,3)}}.

\sphinxAtStartPar
One way of storing what has been computed is by using dynamic programming.


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{uniquePaths}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// store what have been calculated in dp}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{(}\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
28
28
3
6
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses dynamic programming to efficiently compute the number of unique paths in an \sphinxcode{\sphinxupquote{m x n}} grid. It creates a 2D vector \sphinxcode{\sphinxupquote{dp}} of size \sphinxcode{\sphinxupquote{m x n}} and initializes all its values to 1 because there’s exactly one way to reach any cell in the first row or first column.

\sphinxAtStartPar
Then, it iterates through the grid, starting from the second row and second column (i.e., indices (1, 1)), and for each cell, it calculates the number of unique paths to reach that cell. This is done by summing the number of paths from the cell above it and the cell to the left of it, as these are the only two possible directions to reach the current cell.

\sphinxAtStartPar
Finally, the value at \sphinxcode{\sphinxupquote{dp{[}m\sphinxhyphen{}1{]}{[}n\sphinxhyphen{}1{]}}} contains the total number of unique paths to reach the bottom\sphinxhyphen{}right corner of the grid, which is returned as the result.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m*n)}}, where \sphinxcode{\sphinxupquote{m x n}} is the size of the grid.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(m*n)}}.

\end{itemize}


\subsection{Solution 3: Reduced dynamic programming}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:solution-3-reduced-dynamic-programming}}
\sphinxAtStartPar
You can rephrase the relationship inside the loop like this:
\begin{quote}

\sphinxAtStartPar
“new value” = “old value” + “previous value”;
\end{quote}

\sphinxAtStartPar
Then you do not have to store all values of all rows.


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{uniquePaths}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// store the number of unique paths for each column in each row}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{dp}\PYG{p}{[}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePaths}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
28
28
3
6
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime \sphinxcode{\sphinxupquote{O(m*n)}}, where \sphinxcode{\sphinxupquote{m x n}} is the size of the grid.

\item {} 
\sphinxAtStartPar
Memory \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:key-takeaway}}
\sphinxAtStartPar
Solution 3 uses only a 1D vector \sphinxcode{\sphinxupquote{dp}} of size \sphinxcode{\sphinxupquote{n}} to store the number of unique paths for each column.

\sphinxAtStartPar
First, it initializes all elements of \sphinxcode{\sphinxupquote{dp}} to 1, as there’s exactly one way to reach any cell in the first row or first column.

\sphinxAtStartPar
Then, it iterates through the grid, starting from the second row and second column (i.e., indices (1, 1)). For each cell, it updates the value in \sphinxcode{\sphinxupquote{dp}} by adding the value from the cell directly above it and the value from the cell to the left of it. This step efficiently accumulates the number of unique paths to reach the current cell.

\sphinxAtStartPar
Finally, the value at \sphinxcode{\sphinxupquote{dp{[}n\sphinxhyphen{}1{]}}} contains the total number of unique paths to reach the bottom\sphinxhyphen{}right corner of the grid, which is returned as the result.


\subsubsection{A bit of wonder}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:a-bit-of-wonder}}
\sphinxAtStartPar
I am wondering if there is some mathematics behind this problem. Please share your finding if you find a formula for the solution to this problem.


\subsection{Exercise}
\label{\detokenize{Dynamic_Programming/62_Unique_Paths:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-path-sum/}{Minimum Path Sum}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Largest Divisible Subset}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:largest-divisible-subset}}\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset::doc}}

\subsection{Problem statement}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/largest\sphinxhyphen{}divisible\sphinxhyphen{}subset/
%
\end{footnote}You have a collection of positive integers called \sphinxcode{\sphinxupquote{nums}}, where each integer is distinct. Your task is to find the largest subset \sphinxcode{\sphinxupquote{answer}} from this collection, such that for every pair of elements \sphinxcode{\sphinxupquote{(answer{[}i{]}, answer{[}j{]})}} within this subset:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Either \sphinxcode{\sphinxupquote{answer{[}i{]}}} is a multiple of \sphinxcode{\sphinxupquote{answer{[}j{]}}} (i.e., \sphinxcode{\sphinxupquote{answer{[}i{]} \% answer{[}j{]} == 0}}), or

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{answer{[}j{]}}} is a multiple of \sphinxcode{\sphinxupquote{answer{[}i{]}}} (i.e., \sphinxcode{\sphinxupquote{answer{[}j{]} \% answer{[}i{]} == 0}}).

\end{itemize}

\sphinxAtStartPar
If there are multiple possible solutions, you can return any of them.


\subsubsection{Example 1}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,4,8]
Output: [1,2,4,8]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums{[}i{]} \textless{}= 2 * 10\textasciicircum{}9}}.

\item {} 
\sphinxAtStartPar
All the integers in \sphinxcode{\sphinxupquote{nums}} are \sphinxstylestrong{unique}.

\end{itemize}


\subsection{Solution 1: Bruteforce with Dynamic programming}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:solution-1-bruteforce-with-dynamic-programming}}
\sphinxAtStartPar
Note that the condition \sphinxcode{\sphinxupquote{a \% b == 0}} is called \sphinxstyleemphasis{\sphinxcode{\sphinxupquote{a}} is divisible by \sphinxcode{\sphinxupquote{b}}}. In mathematics, it can also be called \sphinxstyleemphasis{\sphinxcode{\sphinxupquote{b}} divides \sphinxcode{\sphinxupquote{a}}} and be written as \sphinxcode{\sphinxupquote{b | a}}.

\sphinxAtStartPar
The symmetry of the divisibility criteria means it does not count the ordering of the \sphinxcode{\sphinxupquote{answer}}. You could sort the vector \sphinxcode{\sphinxupquote{nums}} before trying to find the longest subset \sphinxcode{\sphinxupquote{answer = {[}answer{[}0{]}, answer{[}1{]}, ..., answer{[}m{]}{]}}} where \sphinxcode{\sphinxupquote{answer{[}i{]} | answer{[}j{]}}} with all \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{}= j \textless{}= m}}.

\sphinxAtStartPar
Now assuming the \sphinxcode{\sphinxupquote{nums}} were sorted. For each \sphinxcode{\sphinxupquote{i}}, you need to find the largest subset \sphinxcode{\sphinxupquote{maxSubset{[}i{]}}} starting from \sphinxcode{\sphinxupquote{nums{[}i{]}}}. And the final answer is the largest one among them.


\subsubsection{Example 3}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2, 4, 3, 9, 8].
Sorted nums = [2, 3, 4, 8, 9]. 
maxSubset[0] = [2, 4, 8].
maxSubset[1] = [3, 9].
maxSubset[2] = [4, 8].
maxSubset[3] = [8].
maxSubset[4] = [9].
Output: [2, 4, 8].
\end{sphinxVerbatim}

\sphinxAtStartPar
Note that for a sorted \sphinxcode{\sphinxupquote{nums}}, if \sphinxcode{\sphinxupquote{nums{[}i{]} | nums{[}j{]}}} for some \sphinxcode{\sphinxupquote{i \textless{} j}}, then \sphinxcode{\sphinxupquote{maxSubset{[}j{]}}} is a subset of \sphinxcode{\sphinxupquote{maxSubset{[}i{]}}}.

\sphinxAtStartPar
For example, \sphinxcode{\sphinxupquote{maxSubset{[}2{]}}} is a subset of \sphinxcode{\sphinxupquote{maxSubset{[}0{]}}} in Example 3 because \sphinxcode{\sphinxupquote{nums{[}0{]} = 2 | 4 = nums{[}2{]}}}.

\sphinxAtStartPar
That might lead to some unnecessary recomputing. To avoid it, you could use \sphinxstyleemphasis{dynamic programming} to store the \sphinxcode{\sphinxupquote{maxSubset{[}j{]}}} you have already computed.


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}

\PYG{c+c1}{//! @return the max divisible subset starting from nums[i] }
\PYG{c+c1}{//!         and store it to \PYGZus{}map[i]}
\PYG{c+c1}{//! @param nums a sorted array of unique positive integers }
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{largestDivisibleSubsetOf}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }
\PYG{+w}{            }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{\PYGZus{}map}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// already computed!}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{\PYGZob{}}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// start with nums[i]}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// largest value in nums}
\PYG{+w}{        }\PYG{n}{\PYGZus{}map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// compute the max divisble subset starting from nums[j]}
\PYG{+w}{            }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{subset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubsetOf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{            }\PYG{c+c1}{// add nums[i] to subset as it might become maxSubset}
\PYG{+w}{            }\PYG{n}{subset}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{maxSubset}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subset}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// update maxSubset}
\PYG{+w}{                }\PYG{n}{maxSubset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{subset}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// store what have been calculated in \PYGZus{}map}
\PYG{+w}{    }\PYG{n}{\PYGZus{}map}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{\PYGZcb{}}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubsetOf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{\PYGZus{}map}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{answer}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// update the maximal subset}
\PYG{+w}{            }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{maxSubset}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}\PYG{+w}{        }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printSolution}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printSolution}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printSolution}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[2,1,]
[8,4,2,1,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses dynamic programming with \index{memoization@\spxentry{memoization}}memoization to find the largest divisible subset of a given set of numbers.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{largestDivisibleSubsetOf}} function recursively computes the largest divisible subset starting from a particular index \sphinxcode{\sphinxupquote{i}} in the sorted array \sphinxcode{\sphinxupquote{nums}}. It memoizes the computed subsets in an unordered map \sphinxcode{\sphinxupquote{\_map}} to avoid redundant computations. By iteratively calling \sphinxcode{\sphinxupquote{largestDivisibleSubsetOf}} for each index \sphinxcode{\sphinxupquote{i}} in the sorted array and updating the \sphinxcode{\sphinxupquote{answer}} with the largest subset found so far, the \sphinxcode{\sphinxupquote{largestDivisibleSubset}} function computes the largest divisible subset of the input array \sphinxcode{\sphinxupquote{nums}}.

\sphinxAtStartPar
This approach optimizes the computation by avoiding repeated calculations and leveraging dynamic programming techniques to efficiently explore the solution space.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} vector.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}.

\end{itemize}


\subsection{Solution 2: Store only the representative of the \sphinxstyleliteralintitle{\sphinxupquote{maxSubset}}}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:solution-2-store-only-the-representative-of-the-maxsubset}}
\sphinxAtStartPar
In the brute\sphinxhyphen{}force solution above, you used a big \sphinxcode{\sphinxupquote{map}} to log all \sphinxcode{\sphinxupquote{maxSubset{[}i{]}}} though you need only the largest one at the end.

\sphinxAtStartPar
One way to save memory (and eventually improve performance) is just storing the representative of the chain relationship between the values \sphinxcode{\sphinxupquote{nums{[}i{]}}} of the \sphinxcode{\sphinxupquote{maxSubset}} through their indices mapping.

\sphinxAtStartPar
That means if \sphinxcode{\sphinxupquote{maxSubset{[}i{]} = {[}nums{[}i0{]} | nums{[}i1{]} | ... | nums{[}iN1{]}{]} | nums{[}iN{]}{]}}}, you could log \sphinxcode{\sphinxupquote{pre{[}iN{]} = iN1}}, …,  \sphinxcode{\sphinxupquote{prev{[}i1{]} = i0}}.

\sphinxAtStartPar
Then all you need to find is only the last index \sphinxcode{\sphinxupquote{iN}} of the largest \sphinxcode{\sphinxupquote{maxSubset}}.


\subsubsection{Example 3}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2, 4, 3, 9, 8].
sorted nums = [2, 3, 4, 8, 9]. 
pre[0] = \PYGZhy{}1 (there is no nums[i] | nums[0]).
pre[1] = \PYGZhy{}1 (there is no nums[i] | nums[1]).
pre[2] = 0 (nums[0] is the only divisor of nums[2]).
pre[3] = 2 (for the largest subset though nums[0] and nums[2] are both divisors of nums[3]). 
pre[4] = 1 (nums[1] is the only divisor of nums[4]).
iN = 3 ([2 | 4 | 8] is the largest maxSubset).
Output: [8, 4, 2].
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// the size of the resulting subset}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxSize}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{    }

\PYG{+w}{    }\PYG{c+c1}{// nums[maxindex] is the largest value of the resulting subset}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxindex}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{   }

\PYG{+w}{    }\PYG{c+c1}{// subsetSize[i] stores the size of the largest subset}
\PYG{+w}{    }\PYG{c+c1}{// having the biggest number nums[i]}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{subsetSize}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }

\PYG{+w}{    }\PYG{c+c1}{// pre[i] stores the previous index of i in their largest subset}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{pre}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{       }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// find the previous nums[j] that make subsetSize[i] largest}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}

\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }
\PYG{+w}{                }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }
\PYG{+w}{            }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{pre}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// update the largest subset}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{maxSize}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{maxSize}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{subsetSize}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{maxindex}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{maxindex}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{result}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{maxindex}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{maxindex}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pre}\PYG{p}{[}\PYG{n}{maxindex}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}\PYG{+w}{        }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printSolution}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printSolution}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{largestDivisibleSubset}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printSolution}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[2,1,]
[8,4,2,1,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution finds the largest divisible subset of a given set of numbers by dynamically updating the size of the subsets and maintaining the previous index of each element in their largest subset.

\sphinxAtStartPar
It iterates through the sorted array of numbers, updating the size of the largest subset that ends with each element by considering the previous elements that are factors of the current element. By keeping track of the maximum subset size and the index of the largest element in the subset, it constructs the largest divisible subset.

\sphinxAtStartPar
This approach optimizes the computation by avoiding redundant calculations and leveraging dynamic programming techniques to efficiently explore the solution space.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} vector. The nested loop searches for previous elements with divisibility relationships, which may lead to quadratic time complexity in the worst case. However, it maintains information about subset sizes and elements, reducing redundant calculations and improving performance.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Key takeaway}
\label{\detokenize{Dynamic_Programming/368_Largest_Divisible_Subset:key-takeaway}}
\sphinxAtStartPar
In this interesting problem, we use index mapping to simplify everything. That improves the performance in both runtime and memory.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Triangle}
\label{\detokenize{Dynamic_Programming/120_Triangle:triangle}}\label{\detokenize{Dynamic_Programming/120_Triangle::doc}}

\subsection{Problem statement}
\label{\detokenize{Dynamic_Programming/120_Triangle:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/triangle/
%
\end{footnote}You’re provided with a \sphinxcode{\sphinxupquote{triangle}} array. Your goal is to find the smallest possible sum of a path from the top of the triangle to the bottom.

\sphinxAtStartPar
At each step, you have the option to move to an adjacent number in the row below. Specifically, if you’re at index \sphinxcode{\sphinxupquote{i}} in the current row, you can move to either index \sphinxcode{\sphinxupquote{i}} or index \sphinxcode{\sphinxupquote{i + 1}} in the next row.


\subsubsection{Example 1}
\label{\detokenize{Dynamic_Programming/120_Triangle:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Dynamic_Programming/120_Triangle:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: triangle = [[\PYGZhy{}10]]
Output: \PYGZhy{}10
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Dynamic_Programming/120_Triangle:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= triangle.length \textless{}= 200}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{triangle{[}0{]}.length == 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{triangle{[}i{]}.length == triangle{[}i \sphinxhyphen{} 1{]}.length + 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}4 \textless{}= triangle{[}i{]}{[}j{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Dynamic_Programming/120_Triangle:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you do this using only \sphinxcode{\sphinxupquote{O(n)}} extra space, where \sphinxcode{\sphinxupquote{n}} is the total number of rows in the triangle?

\end{itemize}


\subsection{Solution 1: Store all minimum paths}
\label{\detokenize{Dynamic_Programming/120_Triangle:solution-1-store-all-minimum-paths}}
\sphinxAtStartPar
You can store all minimum paths at every positions \sphinxcode{\sphinxupquote{(i,j)}} so you can compute the next ones with this relationship.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
minPath[i][j] = triangle[i][j] + min(minPath[i \PYGZhy{} 1][j \PYGZhy{} 1], minPath[i \PYGZhy{} 1][j]);
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/120_Triangle:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minimumTotal}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// triangle\PYGZsq{}s height}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minPath}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{.}\PYG{n}{resize}\PYG{p}{(}\PYG{n}{N}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// left most number}
\PYG{+w}{        }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{(}\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// right most number}
\PYG{+w}{        }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{N}\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{]}\PYG{p}{;}

\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// pick the min path among the ones (begin \PYGZhy{}\PYGZgt{} end)}
\PYG{+w}{    }\PYG{c+c1}{// go to the bottom (n\PYGZhy{}1)}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{n}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{n}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minimumTotal}\PYG{p}{(}\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{triangle}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}10}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minimumTotal}\PYG{p}{(}\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
11
\PYGZhy{}10
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution finds the minimum path sum from the top to the bottom of a triangle, represented as a vector of vectors. It uses dynamic programming to calculate the minimum path sum.

\sphinxAtStartPar
The algorithm initializes a \sphinxcode{\sphinxupquote{minPath}} vector of vectors to store the minimum path sum for each element in the \sphinxcode{\sphinxupquote{triangle}}. It starts by setting the first row of \sphinxcode{\sphinxupquote{minPath}} to be the same as the first row of the \sphinxcode{\sphinxupquote{triangle}}.

\sphinxAtStartPar
Then, it iterates through the rows of the \sphinxcode{\sphinxupquote{triangle}} starting from the second row. For each element in the current row, it calculates the minimum path sum by considering the two possible paths from the previous row that lead to that element. It takes the minimum of the two paths and adds the value of the current element. This way, it accumulates the minimum path sum efficiently.

\sphinxAtStartPar
The algorithm continues this process until it reaches the last row of the \sphinxcode{\sphinxupquote{triangle}}. Finally, it returns the minimum element from the last row of \sphinxcode{\sphinxupquote{minPath}}, which represents the minimum path sum from top to bottom.


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/120_Triangle:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n}} is the number of rows in the \sphinxcode{\sphinxupquote{triangle}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}.

\end{itemize}


\subsection{Solution 2: Store only the minimum paths of each row}
\label{\detokenize{Dynamic_Programming/120_Triangle:solution-2-store-only-the-minimum-paths-of-each-row}}
\sphinxAtStartPar
You do not need to store all paths for all rows. The computation of the next row only depends on its previous one.


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/120_Triangle:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minimumTotal}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// store only min path for each row}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{minPath}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// right most number}
\PYG{+w}{        }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{(}\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// left most number}
\PYG{+w}{        }\PYG{n}{minPath}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{minPath}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{minPath}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{triangle}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minimumTotal}\PYG{p}{(}\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{triangle}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}10}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minimumTotal}\PYG{p}{(}\PYG{n}{triangle}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
11
\PYGZhy{}10
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/120_Triangle:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n}} is the number of rows in the triangle.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Unique Paths II}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:unique-paths-ii}}\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II::doc}}

\subsection{Problem statement}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/unique\sphinxhyphen{}paths\sphinxhyphen{}ii/
The grid contains obstacles and empty spaces, which are marked as \sphinxcode{\sphinxupquote{1}} or \sphinxcode{\sphinxupquote{0}} respectively. The robot cannot pass through squares marked as obstacles.
%
\end{footnote}You’re given an \sphinxcode{\sphinxupquote{m x n}} grid represented as an integer array called \sphinxcode{\sphinxupquote{grid}}. In this grid, there is a robot initially located at the top\sphinxhyphen{}left corner (i.e., \sphinxcode{\sphinxupquote{grid{[}0{]}{[}0{]}}}). The robot’s goal is to move to the bottom\sphinxhyphen{}right corner (i.e., \sphinxcode{\sphinxupquote{grid{[}m\sphinxhyphen{}1{]}{[}n\sphinxhyphen{}1{]}}}). The robot is allowed to move only downwards or to the right at any given point.

\sphinxAtStartPar
Your task is to determine the number of unique paths the robot can take to reach the bottom\sphinxhyphen{}right corner while avoiding obstacles.

\sphinxAtStartPar
It’s important to note that the test cases are designed in such a way that the answer will always be less than or equal to \sphinxcode{\sphinxupquote{2 * 10\textasciicircum{}9}}.


\subsubsection{Example 1}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{63_robot1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom\PYGZhy{}right corner:
1. Right \PYGZhy{}\PYGZgt{} Right \PYGZhy{}\PYGZgt{} Down \PYGZhy{}\PYGZgt{} Down
2. Down \PYGZhy{}\PYGZgt{} Down \PYGZhy{}\PYGZgt{} Right \PYGZhy{}\PYGZgt{} Right
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:example-2}}
\sphinxAtStartPar
\sphinxincludegraphics{{63_robot2}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{m == obstacleGrid.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == obstacleGrid{[}i{]}.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= m, n \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{obstacleGrid{[}i{]}{[}j{]}}} is \sphinxcode{\sphinxupquote{0}} or \sphinxcode{\sphinxupquote{1}}.

\end{itemize}


\subsection{Solution: Dynamic programming in place}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:solution-dynamic-programming-in-place}}
\sphinxAtStartPar
Let us find the relationship between the positions.

\sphinxAtStartPar
If there is no obstacle at the position \sphinxcode{\sphinxupquote{(row = i, col = j)}}, the number of paths \sphinxcode{\sphinxupquote{np{[}i{]}{[}j{]}}} that the robot can take to reach this position is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
np[i][j] = np[i \PYGZhy{} 1][j] + np[i][j \PYGZhy{} 1]
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
\sphinxAtStartPar
As long as there is no obstacle in the first row, \sphinxcode{\sphinxupquote{np{[}0{]}{[}j{]} = 1}}. Otherwise, \sphinxcode{\sphinxupquote{np{[}0{]}{[}k{]} = 0}} for all \sphinxcode{\sphinxupquote{k \textgreater{}= j0}}, where \sphinxcode{\sphinxupquote{(0, j0)}} is the position of the first obstacle in the first row.

\item {} 
\sphinxAtStartPar
Similarly, as long as there is no obstacle in the first column, \sphinxcode{\sphinxupquote{np{[}i{]}{[}0{]} = 1}}. Otherwise, \sphinxcode{\sphinxupquote{np{[}k{]}{[}0{]} = 0}} for all \sphinxcode{\sphinxupquote{k \textgreater{}= i0}}, where \sphinxcode{\sphinxupquote{(i0, 0)}} is the position of the first obstacle in the first column.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{uniquePathsWithObstacles}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{col}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{np}\PYG{p}{(}\PYG{n}{row}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{p}{(}\PYG{n}{col}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{row}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// can move as long as there is no obstacle}
\PYG{+w}{        }\PYG{n}{np}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{col}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// can move as long as there is no obstacle}
\PYG{+w}{        }\PYG{n}{np}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{row}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{col}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{obstacleGrid}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// can move since there is obstacle}
\PYG{+w}{                }\PYG{n}{np}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{np}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{np}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{np}\PYG{p}{[}\PYG{n}{row}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{col}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{obstacleGrid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePathsWithObstacles}\PYG{p}{(}\PYG{n}{obstacleGrid}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{obstacleGrid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{uniquePathsWithObstacles}\PYG{p}{(}\PYG{n}{obstacleGrid}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(m*n)}}, where \sphinxcode{\sphinxupquote{m}} and \sphinxcode{\sphinxupquote{n}} are the dimensions of the grid.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(m*n)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:key-takeaway}}
\sphinxAtStartPar
This solution computes the number of unique paths in an \sphinxcode{\sphinxupquote{m x n}} grid with obstacles using dynamic programming. It initializes a 2D vector \sphinxcode{\sphinxupquote{np}} of the same size as \sphinxcode{\sphinxupquote{obstacleGrid}} to store the number of unique paths for each cell.

\sphinxAtStartPar
First, it initializes the top row and left column of \sphinxcode{\sphinxupquote{np}}. If there are no obstacles in the top row or left column of \sphinxcode{\sphinxupquote{obstacleGrid}}, it sets the corresponding cells in \sphinxcode{\sphinxupquote{np}} to 1 because there’s only one way to reach any cell in the top row or left column.

\sphinxAtStartPar
Then, it iterates through the grid starting from the second row and second column (i.e., indices (1, 1)). For each cell, if there’s no obstacle (\sphinxcode{\sphinxupquote{obstacleGrid{[}i{]}{[}j{]} == 0}}), it updates the value in \sphinxcode{\sphinxupquote{np}} by summing up the values from the cell directly above it and the cell to the left of it. This step efficiently accumulates the number of unique paths while avoiding obstacles.

\sphinxAtStartPar
Finally, the value at \sphinxcode{\sphinxupquote{np{[}row\sphinxhyphen{}1{]}{[}col\sphinxhyphen{}1{]}}} contains the total number of unique paths to reach the bottom\sphinxhyphen{}right corner of the grid, which is returned as the result.


\subsection{Exercise}
\label{\detokenize{Dynamic_Programming/63_Unique_Paths_II:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-path-cost-in-a-grid/}{Minimum Path Cost in a Grid}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Counting}
\label{\detokenize{Counting/index:counting}}\label{\detokenize{Counting/index::doc}}
\sphinxAtStartPar
In this chapter, we will explore the benefits of counting elements and how it can enhance the efficiency of different algorithms and operations. By tallying occurrences, you can gain valuable insights that simplify computations and give you a better understanding of your data.

\sphinxAtStartPar
Counting elements is like organizing a messy room. When you categorize items, it becomes easier to access and make decisions. In algorithms, counting allows you to optimize processes by identifying the most frequent elements or solving complex problems more efficiently.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Counting:} Lay the foundation by understanding the significance of counting elements, its role in performance enhancement, and the various scenarios where counting is crucial.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Frequency Counting:} Explore the technique of tallying element occurrences, enabling you to identify the most frequent items within a dataset quickly.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Counting Sort:} Delve into the world of counting sort, a specialized sorting algorithm that capitalizes on the power of element counting to achieve exceptional performance.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Counts:} Develop approaches to solve problems that benefit from element counting, from optimizing search operations to identifying anomalies.

\end{enumerate}

\sphinxstepscope


\section{Single Number}
\label{\detokenize{Counting/136_Single_Number:single-number}}\label{\detokenize{Counting/136_Single_Number::doc}}

\subsection{Problem statement}
\label{\detokenize{Counting/136_Single_Number:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/single\sphinxhyphen{}number/description/
%
\end{footnote}You’re provided with a non\sphinxhyphen{}empty array of integers called \sphinxcode{\sphinxupquote{nums}}. In this array, every element occurs twice except for one element that appears only once. Your task is to identify and find that unique element.

\sphinxAtStartPar
To solve this problem, your solution needs to have a linear runtime complexity and utilize only a constant amount of extra space.


\subsubsection{Example 1}
\label{\detokenize{Counting/136_Single_Number:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2,2,1]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Counting/136_Single_Number:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [4,1,2,1,2]
Output: 4
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Counting/136_Single_Number:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Counting/136_Single_Number:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 3 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}3 * 10\textasciicircum{}4 \textless{}= nums{[}i{]} \textless{}= 3 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
Each element in the array appears twice except for one element which appears only once.

\end{itemize}


\subsection{Solution 1: Counting the appearances}
\label{\detokenize{Counting/136_Single_Number:solution-1-counting-the-appearances}}
\sphinxAtStartPar
Count how many times each element appears in the array. Then return the one appearing only once.


\subsubsection{Code}
\label{\detokenize{Counting/136_Single_Number:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{singleNumber}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{count}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{single}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{pair}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{pair}\PYG{p}{.}\PYG{n}{second}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{single}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{pair}\PYG{p}{.}\PYG{n}{first}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{single}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
4
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution effectively finds the single number by counting the occurrences of each element in the array and selecting the one with a count of 1.


\subsubsection{Complexity}
\label{\detokenize{Counting/136_Single_Number:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Solution 2: Bitwise exclusive OR}
\label{\detokenize{Counting/136_Single_Number:solution-2-bitwise-exclusive-or}}
\sphinxAtStartPar
You can also use the \index{bitwise XOR@\spxentry{bitwise XOR}}bitwise XOR operator to cancel out the duplicated elements in the array. The remain element is the single one.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
a XOR a = 0.
a XOR 0 = a.
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Counting/136_Single_Number:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{singleNumber}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{single}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{single}\PYG{+w}{ }\PYG{o}{\PYGZca{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{single}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{singleNumber}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
4
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Counting/136_Single_Number:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Counting/136_Single_Number:key-takeaway}}
\sphinxAtStartPar
Leveraging bitwise XOR (\textasciicircum{}) operations offers an efficient solution to find the single number in an array. Solution 2 utilizes the property of XOR where XORing a number with itself results in 0.

\sphinxAtStartPar
By XORing all the numbers in the array, Solution 2 effectively cancels out pairs of identical numbers, leaving only the single number behind. This approach achieves a linear time complexity without the need for additional data structures, providing a concise and efficient solution.


\subsection{Exercise}
\label{\detokenize{Counting/136_Single_Number:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/missing-number/}{Missing Number}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{First Unique Character in a String}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:first-unique-character-in-a-string}}\label{\detokenize{Counting/387_First_Unique_Character_in_a_String::doc}}

\subsection{Problem statement}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/first\sphinxhyphen{}unique\sphinxhyphen{}character\sphinxhyphen{}in\sphinxhyphen{}a\sphinxhyphen{}string/
%
\end{footnote}You have a string called \sphinxcode{\sphinxupquote{s}}. Your objective is to locate the index of the first character in the string that does not repeat anywhere else in the string. If such a character doesn’t exist, return \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}.


\subsubsection{Example 1}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}leetcode\PYGZdq{}
Output: 0
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}loveleetcode\PYGZdq{}
Output: 2
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: s = \PYGZdq{}aabb\PYGZdq{}
Output: \PYGZhy{}1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= s.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{s}} consists of only lowercase English letters.

\end{itemize}


\subsection{Solution 1: Using a map to store the appearances}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:solution-1-using-a-map-to-store-the-appearances}}

\subsubsection{Code}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{firstUniqChar}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{char}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{count}\PYG{p}{[}\PYG{n}{c}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{count}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leetcode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{loveleetcode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aabb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
0
2
\PYGZhy{}1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution finds the index of the first non\sphinxhyphen{}repeating character in a string by using an unordered map to count the occurrences of each character.

\sphinxAtStartPar
By iterating through the string and populating the unordered map with the count of each character, it constructs the character count. Then, it iterates through the string again and returns the index of the first character with a count of 1, indicating that it is non\sphinxhyphen{}repeating.

\sphinxAtStartPar
This approach optimizes the computation by efficiently tracking the count of each character and identifying the first non\sphinxhyphen{}repeating character without requiring additional space proportional to the length of the string.


\subsubsection{Complexity}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n}} is the length of the string \sphinxcode{\sphinxupquote{s}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}} as the problem considers only 26 lowercase English letters.

\end{itemize}


\subsection{Solution 2: Using an array to store the appearances}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:solution-2-using-an-array-to-store-the-appearances}}
\sphinxAtStartPar
From the constraints “\sphinxcode{\sphinxupquote{s}} consists of only lowercase English letters”, you can use an array of 26 elements to store the counts.


\subsubsection{Code}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{firstUniqChar}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// map \PYGZsq{}a\PYGZsq{}\PYGZhy{}\PYGZgt{}0, \PYGZsq{}b\PYGZsq{}\PYGZhy{}\PYGZgt{}1, .., \PYGZsq{}z\PYGZsq{}\PYGZhy{}\PYGZgt{}25}
\PYG{+w}{    }\PYG{c+c1}{// initializes an array of 26 elements, all set to zero}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{array}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{26}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{count}\PYG{p}{[}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{p}{.}\PYG{n}{length}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{count}\PYG{p}{[}\PYG{n}{s}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}}\PYG{l+s+sc}{a}\PYG{l+s+sc}{\PYGZsq{}}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{leetcode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{loveleetcode}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{firstUniqChar}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{aabb}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
0
2
\PYGZhy{}1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = s.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}} as the array is fixed regardless of how big \sphinxcode{\sphinxupquote{n}} is.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:key-takeaway}}
\sphinxAtStartPar
Utilizing hash maps or arrays to count the frequency of characters in a string provides an efficient way to identify the first unique character. Both solutions use this approach to iterate through the string and count the occurrences of each character.

\sphinxAtStartPar
By storing the counts in a data structure indexed by the character value, the solutions achieve a linear time complexity proportional to the length of the string. Solution 2 further optimizes memory usage by employing an array with a fixed size corresponding to the lowercase English alphabet, avoiding the overhead associated with hash maps.


\subsection{Exercise}
\label{\detokenize{Counting/387_First_Unique_Character_in_a_String:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/first-letter-to-appear-twice/}{First Letter to Appear Twice}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Max Number of K\sphinxhyphen{}Sum Pairs}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:max-number-of-k-sum-pairs}}\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs::doc}}

\subsection{Problem statement}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/max\sphinxhyphen{}number\sphinxhyphen{}of\sphinxhyphen{}k\sphinxhyphen{}sum\sphinxhyphen{}pairs/
%
\end{footnote}You’re provided with an array of integers called \sphinxcode{\sphinxupquote{nums}} and an integer \sphinxcode{\sphinxupquote{k}}. Each operation involves selecting two numbers from the array whose sum is equal to \sphinxcode{\sphinxupquote{k}}, and then removing them from the array. Your goal is to determine the maximum count of such operations you can perform on the array.


\subsubsection{Example 1}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
\PYGZhy{} Remove numbers 1 and 4, then nums = [2,3]
\PYGZhy{} Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
\PYGZhy{} Remove the first two 3\PYGZsq{}s, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}9}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= k \textless{}= 10\textasciicircum{}9}}.

\end{itemize}


\subsection{Solution: Count the appearances}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:solution-count-the-appearances}}
\sphinxAtStartPar
You can use a map to count the appearances of the elements of \sphinxcode{\sphinxupquote{nums}}.


\subsubsection{Example 2}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}3,1,3,4,3{]}}} and \sphinxcode{\sphinxupquote{k = 6}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Initialize \sphinxcode{\sphinxupquote{count = 0}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{i = 0}}: \sphinxcode{\sphinxupquote{m{[}3{]} = 1}}; \sphinxcode{\sphinxupquote{k \sphinxhyphen{} 3 = 3}} but \sphinxcode{\sphinxupquote{m{[}3{]}}} is only \sphinxcode{\sphinxupquote{1}}, not enough to have two numbers.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{i = 1}}: \sphinxcode{\sphinxupquote{m{[}1{]} = 1}}; \sphinxcode{\sphinxupquote{k \sphinxhyphen{} 1 = 5}} and \sphinxcode{\sphinxupquote{m{[}5{]} = 0}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{i = 2}}: \sphinxcode{\sphinxupquote{m{[}3{]} = 2}}; \sphinxcode{\sphinxupquote{k \sphinxhyphen{} 3 = 3}} and \sphinxcode{\sphinxupquote{m{[}3{]} = 2}} just enough to have two numbers to perform the sum. \sphinxcode{\sphinxupquote{count = 1}}. Erase those two values \sphinxcode{\sphinxupquote{3}}’s from the map: \sphinxcode{\sphinxupquote{m{[}3{]} = 0}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{i = 3}}: \sphinxcode{\sphinxupquote{m{[}4{]} = 1}}; \sphinxcode{\sphinxupquote{k \sphinxhyphen{} 4 = 2}} and \sphinxcode{\sphinxupquote{m{[}2{]} = 0}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{i = 4}}: \sphinxcode{\sphinxupquote{m{[}3{]} = 1}}; \sphinxcode{\sphinxupquote{k \sphinxhyphen{} 3 = 3}} but \sphinxcode{\sphinxupquote{m{[}3{]}}} is only \sphinxcode{\sphinxupquote{1}}, not enough to have two numbers.

\item {} 
\sphinxAtStartPar
Final \sphinxcode{\sphinxupquote{count = 1}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxOperations}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// count a\PYGZsq{}s occurences}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{p}{[}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// k\PYGZhy{}a appears in nums}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{|}\PYG{o}{|}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// if a == k \PYGZhy{} a, a is required to appear at least twice}
\PYG{+w}{                }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{m}\PYG{p}{[}\PYG{n}{a}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{                }\PYG{n}{m}\PYG{p}{[}\PYG{n}{k}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxOperations}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxOperations}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} array.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:key-takeaway}}
\sphinxAtStartPar
This solution utilizes an unordered map to store the frequency of each element encountered while iterating through \sphinxcode{\sphinxupquote{nums}}.

\sphinxAtStartPar
By examining each element \sphinxcode{\sphinxupquote{a}} in \sphinxcode{\sphinxupquote{nums}}, it checks if \sphinxcode{\sphinxupquote{k \sphinxhyphen{} a}} exists in the map and if its frequency is greater than 0. If so, it increments the count of pairs and decrements the frequency of both \sphinxcode{\sphinxupquote{a}} and \sphinxcode{\sphinxupquote{k \sphinxhyphen{} a}}, ensuring that each pair is counted only once.

\sphinxAtStartPar
This approach optimizes the computation by efficiently tracking the frequencies of elements and identifying valid pairs whose sum equals the target value without requiring additional space proportional to the size of the array.


\subsection{Exercise}
\label{\detokenize{Counting/1679_Max_Number_of_K-Sum_Pairs:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/two-sum/}{Two Sum}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Prefix Sums}
\label{\detokenize{Prefix_Sum/index:prefix-sums}}\label{\detokenize{Prefix_Sum/index::doc}}
\sphinxAtStartPar
This chapter will introduce you to a technique called \sphinxstylestrong{prefix sums}. This technique can make calculations much faster and more efficient. The chapter will explain how cumulative aggregation works and can help optimize your operations.

\sphinxAtStartPar
Prefix sums are like building blocks that can create many different algorithms. They make it easier to handle cumulative values and allow you to solve complex problems much more efficiently than before.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Prefix Sums:} Establish the groundwork by understanding the essence of prefix sums, their role in performance enhancement, and the scenarios where they shine.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Prefix Sum Array Construction:} Dive into the mechanics of constructing a prefix sum array, unlocking the potential to access cumulative values efficiently.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Range Sum Queries:} Explore how prefix sums revolutionize calculating sums within a given range, enabling quick and consistent results.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Subarray Sum Queries:} Delve into the technique’s application in efficiently determining the sum of elements within any subarray of an array.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Prefix Sum Variants:} Discover the versatility of prefix sums in solving problems related to averages, running maximum/minimum values, and more.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Prefix Sums:} Develop strategies for solving diverse problems by incorporating prefix sums, from optimizing sequence operations to speeding up specific algorithms.

\end{enumerate}

\sphinxstepscope


\section{Running Sum of 1d Array}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:running-sum-of-1d-array}}\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array::doc}}

\subsection{Problem statement}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/running\sphinxhyphen{}sum\sphinxhyphen{}of\sphinxhyphen{}1d\sphinxhyphen{}array/
%
\end{footnote}Given an array called \sphinxcode{\sphinxupquote{nums}}, calculate the running sum of its elements and return the resulting array. The running sum at index \sphinxcode{\sphinxupquote{i}} is the sum of elements from index \sphinxcode{\sphinxupquote{0}} to \sphinxcode{\sphinxupquote{i}} in the \sphinxcode{\sphinxupquote{nums}} array.


\subsubsection{Example 1}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}6 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}6}}.

\end{itemize}


\subsection{Solution 1: Unchange \sphinxstyleliteralintitle{\sphinxupquote{nums}}}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:solution-1-unchange-nums}}

\subsubsection{Code}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{rs}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{rs}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{rs}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,3,6,10,]
[1,2,3,4,5,]
[3,4,6,16,17,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution iterates through the input array \sphinxcode{\sphinxupquote{nums}}, calculates the running sum at each step, and appends the running sums to a result vector. This approach efficiently computes the running sums in a single pass through the array.


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Change \sphinxstyleliteralintitle{\sphinxupquote{nums}}}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:solution-2-change-nums}}
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{nums}} is allowed to be changed, you could use it to store the result directly.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{printResult}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{s}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{s}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{rs}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{runningSum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printResult}\PYG{p}{(}\PYG{n}{rs}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,3,6,10,]
[1,2,3,4,5,]
[3,4,6,16,17,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Prefix_Sum/1480_Running_Sum_of_1d_Array:key-takeaway}}
\sphinxAtStartPar
Solution 2 directly modifies the input array \sphinxcode{\sphinxupquote{nums}} to store the running sums by iteratively updating each element with the cumulative sum of the previous elements. This approach efficiently calculates the running sums in a single pass through the array.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Maximum Subarray}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:maximum-subarray}}\label{\detokenize{Prefix_Sum/53_Maximum_Subarray::doc}}

\subsection{Problem statement}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/maximum\sphinxhyphen{}subarray/
%
\end{footnote}You’re provided with an array of integers called \sphinxcode{\sphinxupquote{nums}}. Your task is to identify a subarray (a consecutive sequence of numbers) that has the highest sum. Once you find this subarray, return the sum of its elements.


\subsubsection{Example 1}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [\PYGZhy{}2,1,\PYGZhy{}3,4,\PYGZhy{}1,2,1,\PYGZhy{}5,4]
Output: 6
Explanation: [4,\PYGZhy{}1,2,1] has the largest sum = 6.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [5,4,\PYGZhy{}1,7,8]
Output: 23
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}4 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:solution}}
\sphinxAtStartPar
The subarrays you want to find should not have negative prefix sums. A negative prefix sum would make the sum of the subarray smaller.


\subsubsection{Example 1}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}\sphinxhyphen{}2,1,\sphinxhyphen{}3,4,\sphinxhyphen{}1,2,1,\sphinxhyphen{}5,4{]}}}, \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}2{]}}} or \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}2,1{]}}} or \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}2,1,\sphinxhyphen{}3{]}}} should not be a prefix of the subarrays you want to find. Since it makes the sum of the result smaller.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxSubArray}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}10000}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// just chose some negative number to start}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{currSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// sum of current subarray}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{currSum}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// start a new subarray from this num}
\PYG{+w}{            }\PYG{n}{currSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{currSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{currSum}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{num}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// update max sum so far}
\PYG{+w}{        }\PYG{n}{maxSum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxSum}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{currSum}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxSum}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxSubArray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxSubArray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxSubArray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
6
1
23
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Memory \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:key-takeaway}}
\sphinxAtStartPar
This solution is the \index{Kadane\textquotesingle{}s algorithm@\spxentry{Kadane\textquotesingle{}s algorithm}}Kadane’s algorithm\sphinxhref{https://en.wikipedia.org/wiki/Maximum\_subarray\_problem\#Kadane's\_algorithm}{} to find the maximum sum of a contiguous subarray in the given array nums.

\sphinxAtStartPar
It iterates through the elements of the array, updating \sphinxcode{\sphinxupquote{currSum}} to either the current element or the sum of the current element and the previous \sphinxcode{\sphinxupquote{currSum}}, whichever is greater. By considering whether adding the current element improves the overall sum, it effectively handles both positive and negative numbers in the array. Finally, it updates \sphinxcode{\sphinxupquote{maxSum}} with the maximum value encountered during the iteration, ensuring it holds the maximum sum of any contiguous subarray within the given array.

\sphinxAtStartPar
This approach optimizes the computation by tracking the maximum sum and dynamically updating it as it iterates through the array.


\subsection{Exercise}
\label{\detokenize{Prefix_Sum/53_Maximum_Subarray:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/maximum-product-subarray/}{Maximum Product Subarray}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Product of Array Except Self}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:product-of-array-except-self}}\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self::doc}}

\subsection{Problem statement}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/product\sphinxhyphen{}of\sphinxhyphen{}array\sphinxhyphen{}except\sphinxhyphen{}self/
%
\end{footnote}Given an integer array \sphinxcode{\sphinxupquote{nums}}, return an array \sphinxcode{\sphinxupquote{answer}} such that \sphinxcode{\sphinxupquote{answer{[}i{]}}} is equal to the product of all the elements of nums except \sphinxcode{\sphinxupquote{nums{[}i{]}}}.

\sphinxAtStartPar
The product of any prefix or suffix of \sphinxcode{\sphinxupquote{nums}} is guaranteed to fit in a 32\sphinxhyphen{}bit integer.

\sphinxAtStartPar
You must write an algorithm that runs in \sphinxcode{\sphinxupquote{O(n)}} time and without using the division operation.


\subsubsection{Example 1}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [\PYGZhy{}1,1,0,\PYGZhy{}3,3]
Output: [0,0,9,0,0]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}30 \textless{}= nums{[}i{]} \textless{}= 30}}.

\item {} 
\sphinxAtStartPar
The product of any prefix or suffix of \sphinxcode{\sphinxupquote{nums}} is guaranteed to fit in a 32\sphinxhyphen{}bit integer.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Can you solve the problem in \sphinxcode{\sphinxupquote{O(1)}} extra space complexity? (The output array does not count as extra space for space complexity analysis.)

\end{itemize}


\subsection{Solution 1: Compute the prefix and suffix products}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:solution-1-compute-the-prefix-and-suffix-products}}
\sphinxAtStartPar
To avoid division operation, you can compute the prefix product and the suffix one of \sphinxcode{\sphinxupquote{nums{[}i{]}}}.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prefix}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// compute all prefix products nums[0]*nums[1]*..*nums[i\PYGZhy{}1]}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{prefix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{suffix}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{        }
\PYG{+w}{    }\PYG{n}{suffix}\PYG{p}{[}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// compute all suffix products nums[i+1]*nums[i+2]*..*nums[n\PYGZhy{}1]}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{suffix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{suffix}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{prefix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{suffix}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
24 12 8 6 
0 0 9 0 0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution computes the product of all elements in an array except for the current element.

\sphinxAtStartPar
It accomplishes this by first computing two arrays: \sphinxcode{\sphinxupquote{prefix}} and \sphinxcode{\sphinxupquote{suffix}}. The \sphinxcode{\sphinxupquote{prefix}} array stores the product of all elements to the left of the current element, while the \sphinxcode{\sphinxupquote{suffix}} array stores the product of all elements to the right of the current element. By multiplying the corresponding elements from \sphinxcode{\sphinxupquote{prefix}} and \sphinxcode{\sphinxupquote{suffix}} arrays, it effectively computes the product of all elements except for the current element at each index.

\sphinxAtStartPar
This approach optimizes the computation by breaking down the problem into smaller subproblems and leveraging the precomputed prefix and suffix arrays to efficiently compute the final result.


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 2: Use directly vector \sphinxstyleliteralintitle{\sphinxupquote{answer}} to store the prefix product}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:solution-2-use-directly-vector-answer-to-store-the-prefix-product}}
\sphinxAtStartPar
In the solution above you can use directly vector \sphinxcode{\sphinxupquote{answer}} for \sphinxcode{\sphinxupquote{prefix}} and merge the last two loops into one.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// compute all prefix products nums[0]*nums[1]*..*nums[i\PYGZhy{}1]}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{suffix}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// compute suffix product and the final product the same time}
\PYG{+w}{        }\PYG{n}{suffix}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{answer}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{suffix}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{answer}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{v}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{\PYGZhy{}3}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{answer}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{productExceptSelf}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{answer}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
24 12 8 6 
0 0 9 0 0
\end{sphinxVerbatim}

\sphinxAtStartPar
This code efficiently calculates the products of all elements in the \sphinxcode{\sphinxupquote{nums}} vector except for the element at each index using two passes through the array. The first pass calculates products to the left of each element, and the second pass calculates products to the right of each element.


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:key-takeaway}}
\sphinxAtStartPar
The problem of computing the product of all elements in an array except the element at the current index can be efficiently solved using different approaches. Solution 1 utilizes two separate passes through the array to compute prefix and suffix products independently. By first computing prefix products from left to right and then suffix products from right to left, this solution efficiently calculates the product of all elements except the one at the current index.

\sphinxAtStartPar
Solution 2 offers a more concise approach by combining the computation of prefix and suffix products into a single pass through the array. By iteratively updating a variable to compute suffix products while simultaneously updating the elements of the answer array, this solution achieves the desired result more efficiently with only one pass through the array.


\subsection{Exercise}
\label{\detokenize{Prefix_Sum/238_Product_of_Array_Except_Self:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/construct-product-matrix/}{Construct Product Matrix}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Subarray Sum Equals K}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:subarray-sum-equals-k}}\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K::doc}}

\subsection{Problem Statement}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/subarray\sphinxhyphen{}sum\sphinxhyphen{}equals\sphinxhyphen{}k/
%
\end{footnote}You have an array of integers called \sphinxcode{\sphinxupquote{nums}} and an integer \sphinxcode{\sphinxupquote{k}}. Your task is to determine the count of contiguous subarrays within this array, where the sum of elements in each subarray is equal to the value of \sphinxcode{\sphinxupquote{k}}.


\subsubsection{Example 1}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,1,1], k = 2
Output: 2
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3], k = 3
Output: 2
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 2 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}1000 \textless{}= nums{[}i{]} \textless{}= 1000}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}7 \textless{}= k \textless{}= 10\textasciicircum{}7}}.

\end{itemize}


\subsection{Solution 1: Bruteforce}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:solution-1-bruteforce}}
\sphinxAtStartPar
For each element, for all subarrays starting from it, choose the satisfied ones.


\subsubsection{Example 3}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:example-3}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}1, \sphinxhyphen{}1, 0{]}}} and \sphinxcode{\sphinxupquote{k = 0}}, you get \sphinxcode{\sphinxupquote{3}} subarrays for the result:
\begin{itemize}
\item {} 
\sphinxAtStartPar
There are three subarrays starting from \sphinxcode{\sphinxupquote{1}}, which are \sphinxcode{\sphinxupquote{{[}1{]}}}, \sphinxcode{\sphinxupquote{{[}1, \sphinxhyphen{}1{]}}}, and \sphinxcode{\sphinxupquote{{[}1, \sphinxhyphen{}1, 0{]}}}. Only the last two are satisfied.

\item {} 
\sphinxAtStartPar
There are two subarrays starting from \sphinxcode{\sphinxupquote{\sphinxhyphen{}1}}, which are \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}1{]}}} and \sphinxcode{\sphinxupquote{{[}\sphinxhyphen{}1, 0{]}}}. None is satisfied.

\item {} 
\sphinxAtStartPar
Only \sphinxcode{\sphinxupquote{{[}0{]}}} is the subarray starting from \sphinxcode{\sphinxupquote{0}}. It is satisfied.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{subarraySum}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution employs a brute\sphinxhyphen{}force approach by considering all possible subarrays and checking whether their sum equals the target \sphinxcode{\sphinxupquote{k}}. The time complexity of this solution is relatively high due to the nested loops, resulting in an inefficient algorithm for larger input sizes.


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Prefix sum}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:solution-2-prefix-sum}}
\sphinxAtStartPar
In the solution above, many sums can be deducted from the previous ones.


\subsubsection{Example 4}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:example-4}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}1, 2, 3, 4{]}}}. Assume the sum of the subarrays \sphinxcode{\sphinxupquote{{[}1{]}, {[}1, 2{]}, {[}1, 2, 3{]}, {[}1, 2, 3, 4{]}}} were computed in the first loop. Then the sum of any other subarray can be deducted from those values.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sum({[}2, 3{]}) = sum({[}1, 2, 3{]}) \sphinxhyphen{} sum({[}1{]})}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sum({[}2, 3, 4{]}) = sum({[}1, 2, 3, 4{]}) \sphinxhyphen{} sum({[}1{]})}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{sum({[}3, 4{]}) = sum(1, 2, 3, 4) \sphinxhyphen{} sum(1, 2)}}.

\end{itemize}

\sphinxAtStartPar
In general, assume you have computed the sum \sphinxcode{\sphinxupquote{sum{[}i{]}}} for the subarray \sphinxcode{\sphinxupquote{{[}nums{[}0{]}, nums{[}1{]}, ..., nums{[}i{]}{]}}} for all \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{} nums.length}}. Then the sum of the subarray \sphinxcode{\sphinxupquote{{[}nums{[}j+1{]}, nums{[}j+2{]}, ..., nums{[}i{]}{]}}} for any \sphinxcode{\sphinxupquote{0 \textless{}= j \textless{}= i}} can be computed as \sphinxcode{\sphinxupquote{sum{[}i{]} \sphinxhyphen{} sum{[}j{]}}}.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{subarraySum}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sum}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// compute all prefix sums nums[0] + .. + nums[i]}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{sum}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{[}\PYG{n}{i}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// nums[0] + .. + nums[i] = k}
\PYG{+w}{            }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sum}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{sum}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{c+c1}{// nums[j+1] + nums[j+2] + .. + nums[i] = k}
\PYG{+w}{                }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
2
3
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses the concept of prefix sum to efficiently calculate the sum of subarrays. It then iterates through the array to find subarrays with a sum equal to \sphinxcode{\sphinxupquote{k}}, and the nested loop helps in calculating the sum of various subarray ranges. The time complexity of this solution is improved compared to the brute\sphinxhyphen{}force approach.


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 3: Faster lookup}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:solution-3-faster-lookup}}
\sphinxAtStartPar
You can rewrite the condition \sphinxcode{\sphinxupquote{sum{[}i{]} \sphinxhyphen{} sum{[}j{]} == k}} in the inner loop of the Solution 2 to \sphinxcode{\sphinxupquote{sum{[}i{]} \sphinxhyphen{} k == sum{[}j{]}}}.

\sphinxAtStartPar
Then that loop can rephrase to \sphinxstyleemphasis{“checking if \sphinxcode{\sphinxupquote{sum{[}i{]} \sphinxhyphen{} k}} was already a value of \sphinxstylestrong{some} computed \sphinxcode{\sphinxupquote{sum{[}j{]}}}”}.

\sphinxAtStartPar
Now you can use an \sphinxcode{\sphinxupquote{unordered\_map}} to store the \sphinxcode{\sphinxupquote{sums}} as indices for the fast lookup.


\subsubsection{Code}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{subarraySum}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// count the frequency of all subarrays\PYGZsq{} sums }
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sumi}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{sumi}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sumi}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{sumi}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{k}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// it\PYGZhy{}\PYGZgt{}second is the count of j so far }
\PYG{+w}{            }\PYG{c+c1}{// having sum[j] = sum[i] \PYGZhy{} k}
\PYG{+w}{            }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// store the count of prefix sum sumi}
\PYG{+w}{        }\PYG{n}{sums}\PYG{p}{[}\PYG{n}{sumi}\PYG{p}{]}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{count}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{subarraySum}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
2
3
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:key-takeaway}}
\sphinxAtStartPar
Solution 3 uses an unordered map to efficiently track the frequency of cumulative sums. It utilizes the concept of complement sums to identify subarrays with the desired sum and adds their counts to the overall count. This approach significantly improves the time complexity compared to the brute\sphinxhyphen{}force solution.


\subsection{Exercise}
\label{\detokenize{Prefix_Sum/560_Subarray_Sum_Equals_K:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/find-pivot-index/}{Find Pivot Index}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Two Pointers}
\label{\detokenize{Two_Pointers/index:two-pointers}}\label{\detokenize{Two_Pointers/index::doc}}
\sphinxAtStartPar
This chapter will explore the \sphinxstylestrong{Two Pointers} technique, a strategic approach that can help solve complex problems quickly and effectively. We’ll show you how to use simultaneous traversal to streamline operations, optimize algorithms, and extract solutions from complicated scenarios.

\sphinxAtStartPar
The Two Pointers technique is like exploring a cryptic map from both ends to find the treasure. It can enhance your problem\sphinxhyphen{}solving skills and help you tackle intricate challenges with a broader perspective.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Two Pointers:} Lay the foundation by understanding the essence of the Two Pointers technique, its adaptability, and its role in unraveling complex problems.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Two Pointers Approach:} Dive into the mechanics of the technique, exploring scenarios where two pointers traverse a sequence to locate solutions or patterns.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Collision and Separation:} Discover the duality of the technique, where pointers can converge to solve particular problems or diverge to address different aspects of a challenge.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Optimal Window Management:} Explore how the Two Pointers technique optimizes sliding window problems, facilitating efficient substring or subarray analysis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Intersection and Union:} Uncover the technique’s versatility in solving problems that involve intersecting or uniting elements within different sequences.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Two Pointers:} Develop strategies to address diverse problems through the Two Pointers technique, from array manipulation to string analysis.

\end{enumerate}

\sphinxstepscope


\section{Middle of the Linked List}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:middle-of-the-linked-list}}\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/middle\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}linked\sphinxhyphen{}list/
%
\end{footnote}Given the \sphinxcode{\sphinxupquote{head}} of a singly linked list, return \sphinxstyleemphasis{the middle node of the linked list}.

\sphinxAtStartPar
If there are two middle nodes, return \sphinxstyleemphasis{the second middle} node.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{876_lc-midlist1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:example-2}}
\sphinxAtStartPar
\sphinxincludegraphics{{876_lc-midlist2}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in the list is in the range \sphinxcode{\sphinxupquote{{[}1, 100{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= Node.val \textless{}= 100}}.

\end{itemize}


\subsection{Solution 1: Counting the number of nodes}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:solution-1-counting-the-number-of-nodes}}

\subsubsection{Code}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{middleNode}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{count}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{count}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{count}\PYG{o}{/}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{node}\PYG{p}{;}\PYG{+w}{        }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{middleNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{five}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{middleNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[3,4,5,]
[4,5,6,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution first counts the total number of nodes in the linked list, and then it iterates to the middle node using the \sphinxcode{\sphinxupquote{count}} variable.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes in the linked list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Fast and Slow pointers}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:solution-2-fast-and-slow-pointers}}\index{Fast and Slow@\spxentry{Fast and Slow}}
\sphinxAtStartPar
Use two pointers to go through the linked list.

\sphinxAtStartPar
One goes one step at a time. The other goes two steps at a time. When the faster reaches the end, the slower reaches the middle.


\subsubsection{Code}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{middleNode}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{slow}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{slow}\PYG{p}{;}\PYG{+w}{        }
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{middleNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{six}\PYG{p}{(}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{five}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{six}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{middleNode}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[3,4,5,]
[4,5,6,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses two pointers, a slow pointer and a fast pointer, to find the middle node of a linked list. Both pointers start from the head of the list, and in each iteration, the slow pointer moves one step forward while the fast pointer moves two steps forward. This ensures that the slow pointer reaches the middle node of the list when the fast pointer reaches the end.

\sphinxAtStartPar
By advancing the pointers at different speeds, the algorithm identifies the middle node of the linked list. If the list has an odd number of nodes, the slow pointer will be positioned at the middle node. If the list has an even number of nodes, the slow pointer will be positioned at the node closer to the middle of the list.

\sphinxAtStartPar
Finally, the algorithm returns the slow pointer, which points to the middle node of the linked list.

\sphinxAtStartPar
This approach optimizes the computation by traversing the linked list only once and using two pointers to efficiently locate the middle node.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes in the linked list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{OBS!}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:obs}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The approach using slow and fast pointers looks very nice and faster. But it is not suitable to generalize this problem to any relative position (one\sphinxhyphen{}third, a quarter, etc.). Moreover, long expressions like \sphinxcode{\sphinxupquote{fast\sphinxhyphen{}\textgreater{}next\sphinxhyphen{}\textgreater{}...\sphinxhyphen{}\textgreater{}next}} are not recommended.

\item {} 
\sphinxAtStartPar
Though the counting nodes approach does not seem optimized, it is more readable, scalable and maintainable.

\end{itemize}


\subsection{Exercise}
\label{\detokenize{Two_Pointers/876_Middle_of_the_Linked_List:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/}{Delete the Middle Node of a Linked List}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Linked List Cycle}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:linked-list-cycle}}\label{\detokenize{Two_Pointers/141_Linked_List_Cycle::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/linked\sphinxhyphen{}list\sphinxhyphen{}cycle/
%
\end{footnote}Given \sphinxcode{\sphinxupquote{head}}, the head of a linked list, determine if the linked list has a cycle in it.

\sphinxAtStartPar
Return \sphinxcode{\sphinxupquote{true}} if there is a cycle in the linked list. Otherwise, return \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{141_circularlinkedlist}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [3,2,0,\PYGZhy{}4], where \PYGZhy{}4 links next to 2.
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:example-2}}
\sphinxAtStartPar
\sphinxincludegraphics{{141_circularlinkedlist_test2}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2], where 2 links next to 1.
Output: true
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:example-3}}
\sphinxAtStartPar
\sphinxincludegraphics{{141_circularlinkedlist_test3}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1], and 1 links to NULL.
Output: false
Explanation: There is no cycle in this linked list.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of the nodes in the list is in the range \sphinxcode{\sphinxupquote{{[}0, 10\textasciicircum{}4{]}}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}5 \textless{}= Node.val \textless{}= 10\textasciicircum{}5}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Can you solve it using \sphinxcode{\sphinxupquote{O(1)}} (i.e. constant) memory?

\end{itemize}


\subsection{Solution 1: Storing the visited nodes}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:solution-1-storing-the-visited-nodes}}

\subsubsection{Code}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{hasCycle}\PYG{p}{(}\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{n}{ListNode}\PYG{o}{*}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{m}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{p}{[}\PYG{n}{head}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// found this node marked in the map}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{p}{[}\PYG{n}{head}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// mark this node visited}
\PYG{+w}{        }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{three}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{zero}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{zero}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{zero}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses a hash map to track visited nodes while traversing the linked list.

\sphinxAtStartPar
By iterating through the linked list and marking pointers to visited nodes in the hash map, it detects cycles in the linked list. If a node is found marked \sphinxcode{\sphinxupquote{true}} in the map, it indicates the presence of a cycle, and the function returns \sphinxcode{\sphinxupquote{true}}. Otherwise, if the end of the linked list is reached without finding any node marked, it confirms the absence of a cycle, and the function returns \sphinxcode{\sphinxupquote{false}}.

\sphinxAtStartPar
This approach optimizes the computation by leveraging the hash map to efficiently detect cycles in the linked list without requiring additional space proportional to the length of the list.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the length of the linked list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Solution 2: Fast and Slow runners}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:solution-2-fast-and-slow-runners}}\index{Fast and Slow@\spxentry{Fast and Slow}}
\sphinxAtStartPar
Imagine there are two runners both start to run along the linked list from the \sphinxcode{\sphinxupquote{head}}. One runs twice faster than the other.

\sphinxAtStartPar
If the linked list has a cycle in it, they will meet at some point. Otherwise, they never meet each other.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:id2}}
\sphinxAtStartPar
The slower runs \sphinxcode{\sphinxupquote{{[}3,2,0,\sphinxhyphen{}4,2,0,...{]}}} while the faster runs \sphinxcode{\sphinxupquote{{[}3,0,2,\sphinxhyphen{}4,0,2,...{]}}}. They meet each other at node \sphinxcode{\sphinxupquote{\sphinxhyphen{}4}} after three steps.


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:id3}}
\sphinxAtStartPar
The slower runs \sphinxcode{\sphinxupquote{{[}1,2,1,2,...{]}}} while the faster runs \sphinxcode{\sphinxupquote{{[}1,1,1,...{]}}}. They meet each other at node \sphinxcode{\sphinxupquote{1}} after two steps.


\subsubsection{Code}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n+nb}{NULL}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{hasCycle}\PYG{p}{(}\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{slow}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{slow}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n+nb}{false}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{three}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{zero}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{zero}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{zero}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{four}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{one}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{two}\PYG{p}{.}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{hasCycle}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
1
0
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes in the linked list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:key-takeaway}}
\sphinxAtStartPar
Solution 2 uses two pointers, a fast pointer and a slow pointer, to detect cycles in a linked list.

\sphinxAtStartPar
Both pointers start from the head of the list, and the fast pointer moves two steps forward while the slow pointer moves one step forward in each iteration. By comparing the positions of the fast and slow pointers, the algorithm detects cycles in the linked list.

\sphinxAtStartPar
If the fast pointer catches up with the slow pointer at any point during traversal, it indicates the presence of a cycle, and the function returns \sphinxcode{\sphinxupquote{true}}. Otherwise, if the fast pointer reaches the end of the list without intersecting with the slow pointer, it confirms the absence of a cycle, and the function returns \sphinxcode{\sphinxupquote{false}}.

\sphinxAtStartPar
This approach optimizes the computation by simultaneously advancing two pointers at different speeds to efficiently detect cycles in the linked list.


\subsection{Exercise}
\label{\detokenize{Two_Pointers/141_Linked_List_Cycle:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/linked-list-cycle-ii/}{Linked List Cycle II}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Sort Array By Parity II}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:sort-array-by-parity-ii}}\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/sort\sphinxhyphen{}array\sphinxhyphen{}by\sphinxhyphen{}parity\sphinxhyphen{}ii/
%
\end{footnote}Given an array of integers \sphinxcode{\sphinxupquote{nums}}, half of the integers in \sphinxcode{\sphinxupquote{nums}} are odd, and the other half are even.

\sphinxAtStartPar
Sort the array so that whenever \sphinxcode{\sphinxupquote{nums{[}i{]}}} is odd, \sphinxcode{\sphinxupquote{i}} is odd, and whenever \sphinxcode{\sphinxupquote{nums{[}i{]}}} is even, \sphinxcode{\sphinxupquote{i}} is even.

\sphinxAtStartPar
Return any answer array that satisfies this condition.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [4,2,5,7]
Output: [4,5,2,7]
Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2,3]
Output: [2,3]
\end{sphinxVerbatim}


\subsubsection{Constraints:}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2 \textless{}= nums.length \textless{}= 2 * 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums.length}} is even.

\item {} 
\sphinxAtStartPar
Half of the integers in \sphinxcode{\sphinxupquote{nums}} are even.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= nums{[}i{]} \textless{}= 1000}}.

\end{itemize}


\subsection{Solution 1: Bubble Sort}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:solution-1-bubble-sort}}
\sphinxAtStartPar
For each \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{} nums.length}}, if \sphinxcode{\sphinxupquote{nums{[}i{]}}} has the same parity with \sphinxcode{\sphinxupquote{i}}, you do nothing. Otherwise you need to find another \sphinxcode{\sphinxupquote{nums{[}j{]}}} that has the same parity with \sphinxcode{\sphinxupquote{i}} to swap with \sphinxcode{\sphinxupquote{nums{[}i{]}}}.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}4,2,5,7{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums{[}0{]} = 4}} is even like \sphinxcode{\sphinxupquote{i = 0}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums{[}1{]} = 2}} is even, unlike \sphinxcode{\sphinxupquote{i = 1}} is odd. Found \sphinxcode{\sphinxupquote{nums{[}2{]} = 5}} is odd. Swap \sphinxcode{\sphinxupquote{nums{[}1{]} \textless{}\sphinxhyphen{}\textgreater{} nums{[}2{]}}}. \sphinxcode{\sphinxupquote{nums{[}2{]}}} becomes \sphinxcode{\sphinxupquote{2}} while \sphinxcode{\sphinxupquote{nums{[}1{]}}} becomes \sphinxcode{\sphinxupquote{5}} is odd like \sphinxcode{\sphinxupquote{i = 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums{[}2{]} = 2}} is even, like \sphinxcode{\sphinxupquote{i = 2}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{nums{[}3{]} = 7}} is odd like \sphinxcode{\sphinxupquote{i = 3}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{c+c1}{// find suitable nums[j] to swap}
\PYG{+w}{            }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                    }\PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{                    }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{                }\PYG{p}{\PYGZcb{}}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{648}\PYG{p}{,}\PYG{l+m+mi}{831}\PYG{p}{,}\PYG{l+m+mi}{560}\PYG{p}{,}\PYG{l+m+mi}{986}\PYG{p}{,}\PYG{l+m+mi}{192}\PYG{p}{,}\PYG{l+m+mi}{424}\PYG{p}{,}\PYG{l+m+mi}{997}\PYG{p}{,}\PYG{l+m+mi}{829}\PYG{p}{,}\PYG{l+m+mi}{897}\PYG{p}{,}\PYG{l+m+mi}{843}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
4 5 2 7 
0 1 8 3 2 9 4 5 2 1 4 7
4 3
648 831 560 997 192 829 986 897 424 843
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution iteratively scans through the array and swap elements to ensure that the parity (even or odd) of each element matches its index modulo 2.

\sphinxAtStartPar
The algorithm iterates over each index of the array. For each index \sphinxcode{\sphinxupquote{i}}, if the parity of the element at index \sphinxcode{\sphinxupquote{i}} does not match \sphinxcode{\sphinxupquote{i \% 2}}, it implies that the element is in the wrong position. In such cases, the algorithm searches for the next element with the correct parity (i.e., even or odd) starting from index \sphinxcode{\sphinxupquote{i + 1}}. Once found, it swaps the elements at indices \sphinxcode{\sphinxupquote{i}} and \sphinxcode{\sphinxupquote{j}}, where \sphinxcode{\sphinxupquote{j}} is the index of the next element with the correct parity.

\sphinxAtStartPar
By performing these swaps, the algorithm ensures that each element is at the correct position based on its parity.

\sphinxAtStartPar
This approach optimizes the sorting process by performing a single pass through the array and minimizing the number of swaps required to achieve the desired parity arrangement.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{N = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Two pointers \sphinxhyphen{} Make use of the problem’s constraints}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:solution-2-two-pointers-make-use-of-the-problems-constraints}}
\sphinxAtStartPar
In the Bubble Sort approach, you do not make use of the \sphinxstyleemphasis{\sphinxstylestrong{constraint}} that \sphinxstylestrong{half of the integers in \sphinxcode{\sphinxupquote{nums}} are even}. Because of that, these are unnecessary things:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The loops scan through full \sphinxcode{\sphinxupquote{nums}}.

\item {} 
\sphinxAtStartPar
The loops are nested. That increases the complexity.

\item {} 
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{swap(nums{[}i{]}, nums{[}j{]})}} happens even when \sphinxcode{\sphinxupquote{nums{[}j{]}}} was already in place, i.e. \sphinxcode{\sphinxupquote{nums{[}j{]}}} had the same parity with \sphinxcode{\sphinxupquote{j}} (Why to move it?).

\end{enumerate}

\sphinxAtStartPar
Here is a two\sphinxhyphen{}pointer approach which takes the important \sphinxstyleemphasis{\sphinxstylestrong{constraint}} into account.


\subsubsection{Code}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{evenPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{oddPos}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{evenPos}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// find the nums[evenPos] that is odd for swapping}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{evenPos}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{N}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{evenPos}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{evenPos}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// If not found, it means all even nums are in place. Done! }
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{evenPos}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{N}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{break}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// Otherwise, the problem\PYGZsq{}s constraint makes sure }
\PYG{+w}{        }\PYG{c+c1}{// there must be some nums[oddPos] that is even for swapping}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{oddPos}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{oddPos}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{oddPos}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }
\PYG{+w}{        }\PYG{n}{swap}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{evenPos}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{oddPos}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{num}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ }\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{648}\PYG{p}{,}\PYG{l+m+mi}{831}\PYG{p}{,}\PYG{l+m+mi}{560}\PYG{p}{,}\PYG{l+m+mi}{986}\PYG{p}{,}\PYG{l+m+mi}{192}\PYG{p}{,}\PYG{l+m+mi}{424}\PYG{p}{,}\PYG{l+m+mi}{997}\PYG{p}{,}\PYG{l+m+mi}{829}\PYG{p}{,}\PYG{l+m+mi}{897}\PYG{p}{,}\PYG{l+m+mi}{843}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortArrayByParityII}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
4 5 2 7 
0 1 8 3 2 9 4 5 2 1 4 7
4 3
648 831 560 997 192 829 986 897 424 843
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:key-takeaway}}
\sphinxAtStartPar
Solution 2 uses two pointers, one starting from the beginning of the array (\sphinxcode{\sphinxupquote{evenPos}}) and the other starting from the end (\sphinxcode{\sphinxupquote{oddPos}}), to efficiently identify misplaced elements.

\sphinxAtStartPar
By incrementing \sphinxcode{\sphinxupquote{evenPos}} by 2 until an odd element is found and decrementing \sphinxcode{\sphinxupquote{oddPos}} by 2 until an even element is found, the algorithm can swap these elements to ensure that even\sphinxhyphen{}indexed elements contain even values and odd\sphinxhyphen{}indexed elements contain odd values. This process iterates until all even and odd elements are correctly positioned.


\subsection{Exercise}
\label{\detokenize{Two_Pointers/922_Sort_Array_By_Parity_II:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/rearrange-array-elements-by-sign/}{Rearrange Array Elements by Sign}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Container With Most Water}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:container-with-most-water}}\label{\detokenize{Two_Pointers/11_Container_With_Most_Water::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/container\sphinxhyphen{}with\sphinxhyphen{}most\sphinxhyphen{}water/
%
\end{footnote}You are given an integer array \sphinxcode{\sphinxupquote{height}} of length \sphinxcode{\sphinxupquote{n}}. There are \sphinxcode{\sphinxupquote{n}} vertical lines drawn such that the two endpoints of the \sphinxcode{\sphinxupquote{i\sphinxhyphen{}th}} line are \sphinxcode{\sphinxupquote{(i, 0)}} and \sphinxcode{\sphinxupquote{(i, height{[}i{]})}}.

\sphinxAtStartPar
Find two lines that together with the x\sphinxhyphen{}axis form a container, such that the container contains the most water.

\sphinxAtStartPar
Return the maximum amount of water a container can store.

\sphinxAtStartPar
Notice that you may not slant the container.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{11_question_11}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue/grey section) the container can contain is 49.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: height = [1,1]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == height.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{2 \textless{}= n \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= height{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution 1: Bruteforce}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:solution-1-bruteforce}}
\sphinxAtStartPar
For each line \sphinxcode{\sphinxupquote{i}}, find the line \sphinxcode{\sphinxupquote{j \textgreater{} i}} such that it gives the maximum amount of water the container \sphinxcode{\sphinxupquote{(i, j)}} can store.


\subsubsection{Code}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxArea}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{maxA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxA}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{(}\PYG{n}{height}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxArea}\PYG{p}{(}\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{height}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxArea}\PYG{p}{(}\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
49
1
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution computes the maximum area of water that can be trapped between two vertical lines by iterating through all possible pairs of lines.
By considering all combinations of lines and calculating the area using the formula \sphinxcode{\sphinxupquote{(min(height{[}i{]}, height{[}j{]}) * (j \sphinxhyphen{} i))}}, where \sphinxcode{\sphinxupquote{height{[}i{]}}} and \sphinxcode{\sphinxupquote{height{[}j{]}}} represent the heights of the two lines and \sphinxcode{\sphinxupquote{(j \sphinxhyphen{} i)}} represents the width between them, it effectively evaluates the area formed by each pair and updates \sphinxcode{\sphinxupquote{maxA}} with the maximum area encountered.

\sphinxAtStartPar
This approach optimizes the computation by exhaustively considering all possible pairs of lines and efficiently computing the area without requiring additional space.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{n = height.length}}. This is because it checks all possible pairs of vertical lines, resulting in a quadratic time complexity.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Two pointers}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:solution-2-two-pointers}}
\sphinxAtStartPar
Any container has left line \sphinxcode{\sphinxupquote{i}} and right line \sphinxcode{\sphinxupquote{j}} satisfying \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{} j \textless{} height.length}}. The biggest container you want to find satisfies that condition too.

\sphinxAtStartPar
You can start from the broadest container with the left line \sphinxcode{\sphinxupquote{i = 0}} and the right line \sphinxcode{\sphinxupquote{j = height.length \sphinxhyphen{} 1}}. Then by moving \sphinxcode{\sphinxupquote{i}} forward and \sphinxcode{\sphinxupquote{j}} backward, you can narrow down the container to find which one will give the maximum amount of water it can store.

\sphinxAtStartPar
Depending on which line is higher, you can decide which one to move next. Since you want a bigger container, you should move the shorter line.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{height = {[}1,8,6,2,5,4,8,3,7{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Starting with \sphinxcode{\sphinxupquote{i = 0}} and \sphinxcode{\sphinxupquote{j = 8}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
area = min(height[i], height[j]) * (j \PYGZhy{} i) = min(1, 7) * (8 \PYGZhy{} 0) = 8.
maxArea = 8.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{height{[}i{]} = 1 \textless{} 7 = height{[}j{]}}}, move \sphinxcode{\sphinxupquote{i}} to \sphinxcode{\sphinxupquote{1}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
area = min(8, 7) * (8 \PYGZhy{} 1) = 49.
maxArea = 49.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{height{[}i{]} = 8 \textgreater{} 7 = height{[}j{]}}}, move \sphinxcode{\sphinxupquote{j}} to \sphinxcode{\sphinxupquote{7}}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
area = min(8, 3) * (7 \PYGZhy{} 1) = 18.
maxArea = 49.
\end{sphinxVerbatim}

\item {} 
\sphinxAtStartPar
So on and so on. Final \sphinxcode{\sphinxupquote{maxArea = 49}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxArea}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{height}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{maxA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxA}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{maxA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxA}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxA}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{height}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxArea}\PYG{p}{(}\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{height}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxArea}\PYG{p}{(}\PYG{n}{height}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
49
1
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = height.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Two_Pointers/11_Container_With_Most_Water:key-takeaway}}
\sphinxAtStartPar
Solution 2 is the two\sphinxhyphen{}pointer approach. By initializing two pointers \sphinxcode{\sphinxupquote{i}} and \sphinxcode{\sphinxupquote{j}} at the beginning and end of the array respectively, and iteratively moving them towards each other until they converge, it evaluates all possible pairs of lines. At each step, it calculates the area. By moving the pointer corresponding to the shorter line inward at each step, it ensures that the maximum possible area is considered.

\sphinxAtStartPar
This approach optimizes the computation by avoiding redundant calculations and efficiently exploring the solution space using two pointers.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Remove Nth Node From End of List}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:remove-nth-node-from-end-of-list}}\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/remove\sphinxhyphen{}nth\sphinxhyphen{}node\sphinxhyphen{}from\sphinxhyphen{}end\sphinxhyphen{}of\sphinxhyphen{}list/
%
\end{footnote}Given the \sphinxcode{\sphinxupquote{head}} of a linked list, remove the \sphinxcode{\sphinxupquote{n\sphinxhyphen{}th}} node from the end of the list and return its head.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:example-1}}
\sphinxAtStartPar
\sphinxincludegraphics{{19_remove_ex1}.jpg}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1], n = 1
Output: []
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: head = [1,2], n = 1
Output: [1]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of nodes in the list is \sphinxcode{\sphinxupquote{sz}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= sz \textless{}= 30}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= Node.val \textless{}= 100}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= sz}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you do this in one pass?

\end{itemize}


\subsection{Solution 1: Store the nodes}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:solution-1-store-the-nodes}}

\subsubsection{Code}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{removeNthFromEnd}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{ListNode}\PYG{o}{*}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{    }
\PYG{+w}{    }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// remove head if n == nodes.size()}
\PYG{+w}{        }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{pre}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nodes}\PYG{p}{[}\PYG{n}{nodes}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{pre}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printList}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,3,5,]
[]
[4,]
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses a vector to store pointers to all nodes in the linked list, enabling easy access to the node to be removed and its predecessor.

\sphinxAtStartPar
By iterating through the linked list and storing pointers to each node in the vector, it constructs a representation of the linked list in an array\sphinxhyphen{}like structure. Then, it retrieves the node to be removed using its index from the end of the vector. Finally, it handles the removal of the node by updating the \sphinxcode{\sphinxupquote{next}} pointer of its predecessor or updating the \sphinxcode{\sphinxupquote{head}} pointer if the node to be removed is the head of the linked list.

\sphinxAtStartPar
This approach optimizes the computation by sacrificing space efficiency for simplicity of implementation and ease of manipulation of linked list elements.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes in the list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Solution 2: Two pointers}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:solution-2-two-pointers}}
\sphinxAtStartPar
The distance between the removed node and the end (\sphinxcode{\sphinxupquote{nullptr}}) of the list is always \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
You can apply the two\sphinxhyphen{}pointer technique as follows.

\sphinxAtStartPar
Let the slower runner start after the faster one \sphinxcode{\sphinxupquote{n}} nodes. Then when the faster reaches the end of the list, the slower reaches the node to be removed.


\subsubsection{Code}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{k}{struct}\PYG{+w}{ }\PYG{n+nc}{ListNode}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{x}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{val}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{next}\PYG{p}{(}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n+nf}{removeNthFromEnd}\PYG{p}{(}\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// let fast goes ahead n nodes }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{k}{nullptr}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// remove head if n equals the list\PYGZsq{}s length}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{slow}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{slow}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{fast}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{fast}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// remove slow}
\PYG{+w}{    }\PYG{n}{slow}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{slow}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printList}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{head}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{o}{*}\PYG{+w}{ }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{head}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{node}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{val}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{node}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{node}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{next}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{five}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{four}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{three}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{two}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{three}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{ListNode}\PYG{+w}{ }\PYG{n}{one}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{two}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{one}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{five}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{head}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{removeNthFromEnd}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{four}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printList}\PYG{p}{(}\PYG{n}{head}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[1,2,3,5,]
[]
[4,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of nodes in the list.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:key-takeaway}}
\sphinxAtStartPar
Solution 2 uses two pointers, a fast pointer and a slow pointer, to remove the nth node from the end of a linked list.

\sphinxAtStartPar
Initially, both pointers start from the head of the list. The fast pointer moves \sphinxcode{\sphinxupquote{n}} steps ahead, effectively positioning itself \sphinxcode{\sphinxupquote{n}} nodes ahead of the slow pointer. Then, while the fast pointer is not at the end of the list, both pointers move forward simultaneously. This ensures that the slow pointer stays \sphinxcode{\sphinxupquote{n}} nodes behind the fast pointer, effectively reaching the node preceding the nth node from the end when the fast pointer reaches the end of the list. Finally, the nth node from the end is removed by updating the \sphinxcode{\sphinxupquote{next}} pointer of the node preceding it.

\sphinxAtStartPar
This approach optimizes the computation by traversing the linked list only once and using two pointers to efficiently locate the node to be removed.


\subsection{Exercise}
\label{\detokenize{Two_Pointers/19_Remove_Nth_Node_From_End_of_List:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/swapping-nodes-in-a-linked-list/}{Swapping Nodes in a Linked List}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Shortest Unsorted Continuous Subarray}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:shortest-unsorted-continuous-subarray}}\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray::doc}}

\subsection{Problem statement}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/shortest\sphinxhyphen{}unsorted\sphinxhyphen{}continuous\sphinxhyphen{}subarray/
%
\end{footnote}Given an integer array \sphinxcode{\sphinxupquote{nums}}, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.

\sphinxAtStartPar
Return the shortest such subarray and output its length.


\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3,4]
Output: 0
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1]
Output: 0
\end{sphinxVerbatim}


\subsubsection{Constraints:}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}4}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}5 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}5}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Can you solve it in\sphinxcode{\sphinxupquote{O(n)}} time complexity?

\end{itemize}


\subsection{Solution 1: Sort and compare the difference}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:solution-1-sort-and-compare-the-difference}}

\subsubsection{Example 1}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:id2}}
\sphinxAtStartPar
Comparing \sphinxcode{\sphinxupquote{nums = {[}2,6,4,8,10,9,15{]}}} with its sorted one \sphinxcode{\sphinxupquote{sortedNums = {[}2,4,6,8,9,10,15{]}}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first position that makes the difference is \sphinxcode{\sphinxupquote{left = 1}}, where \sphinxcode{\sphinxupquote{6 != 4}}.

\item {} 
\sphinxAtStartPar
The last (right) position that makes the difference is \sphinxcode{\sphinxupquote{right = 5}}, where \sphinxcode{\sphinxupquote{9 != 10}}.

\item {} 
\sphinxAtStartPar
The length of that shortest subarray is \sphinxcode{\sphinxupquote{right \sphinxhyphen{} left + 1 = 5}}.

\end{itemize}


\subsubsection{Code}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{findUnsortedSubarray}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{sortedNums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{sortedNums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sortedNums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{left}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{left}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortedNums}\PYG{p}{[}\PYG{n}{left}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{left}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{right}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{right}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sortedNums}\PYG{p}{[}\PYG{n}{right}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{right}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
0
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution compares the original array with a sorted version of itself to identify the unsorted boundaries efficiently.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N*logN)}} due to the sorting step, where \sphinxcode{\sphinxupquote{N}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} vector.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(N)}}.

\end{itemize}


\subsection{Solution 2: Comparing only maximum and minimum elements}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:solution-2-comparing-only-maximum-and-minimum-elements}}
\sphinxAtStartPar
Assume the subarray \sphinxcode{\sphinxupquote{A = {[}nums{[}0{]}, ..., nums{[}i \sphinxhyphen{} 1{]}{]}}} is sorted. What would be the wanted \sphinxcode{\sphinxupquote{right}} position for the subarray \sphinxcode{\sphinxupquote{B = {[}nums{[}0{]}, ..., nums{[}i \sphinxhyphen{} 1{]}, nums{[}i{]}{]}}}?

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{nums{[}i{]}}} is smaller than \sphinxcode{\sphinxupquote{max(A)}}, the longer subarray \sphinxcode{\sphinxupquote{B}} is not in ascending order. You might need to sort it, which means \sphinxcode{\sphinxupquote{right = i}}.

\sphinxAtStartPar
Similarly, assume the subarray \sphinxcode{\sphinxupquote{C = {[}nums{[}j + 1{]}, ..., nums{[}n \sphinxhyphen{} 1{]}{]}}} is sorted. What would be the wanted \sphinxcode{\sphinxupquote{left}} position for the subarray \sphinxcode{\sphinxupquote{D = {[}nums{[}j{]}, nums{[}j + 1{]}, ..., nums{[}n \sphinxhyphen{} 1{]}{]}}}?

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{nums{[}j{]}}} is bigger than \sphinxcode{\sphinxupquote{min(C)}}, the longer subarray \sphinxcode{\sphinxupquote{D}} is not in ascending order. You might need to sort it,  which means \sphinxcode{\sphinxupquote{left = j}}


\subsubsection{Code}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{findUnsortedSubarray}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{max}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{max}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{min}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{min}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{?}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{right}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{left}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{findUnsortedSubarray}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
0
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution determines the boundaries of the unsorted subarray by iterating through the array from both ends. It starts by initializing the \sphinxcode{\sphinxupquote{right}} boundary to the beginning of the array and tracks the maximum element encountered so far. It iterates from the beginning of the array towards the end, updating the \sphinxcode{\sphinxupquote{right}} boundary whenever an element smaller than the current maximum is encountered. This identifies the rightmost position where the array is unsorted.

\sphinxAtStartPar
Similarly, it initializes the \sphinxcode{\sphinxupquote{left}} boundary to the end of the array and tracking the minimum element encountered so far. It iterates from the end of the array towards the beginning, updating the \sphinxcode{\sphinxupquote{left}} boundary whenever an element greater than the current minimum is encountered. This identifies the leftmost position where the array is unsorted.

\sphinxAtStartPar
Finally, it returns the length of the unsorted subarray, calculated as \sphinxcode{\sphinxupquote{right \sphinxhyphen{} left + 1}}, unless the left boundary is greater than or equal to the right boundary, in which case the array is already sorted, and it returns 0.

\sphinxAtStartPar
This approach optimizes the computation by traversing the array only twice, once from the end and once from the beginning, to efficiently determine the boundaries of the unsorted subarray.


\subsubsection{Complexity}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} vector.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray:key-takeaway}}
\sphinxAtStartPar
Solution 2 helped you identify the shortest subarray (by the \sphinxcode{\sphinxupquote{left}} and \sphinxcode{\sphinxupquote{right}} indices) needed to be sorted in order to sort the whole array.

\sphinxAtStartPar
That means in some cases you can sort an array with complexity \sphinxcode{\sphinxupquote{O(N + m*logm) \textless{} O(N*logN)}} where \sphinxcode{\sphinxupquote{N}} is the length of the whole array and \sphinxcode{\sphinxupquote{m}} is the length of the shortest subarray.


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Mathematics}
\label{\detokenize{Mathematics/index:mathematics}}\label{\detokenize{Mathematics/index::doc}}
\sphinxAtStartPar
This chapter will explore how mathematics and programming create efficient solutions. We’ll cover mathematical concepts and show how they can be integrated into coding to enhance problem\sphinxhyphen{}solving skills.

\sphinxAtStartPar
Mathematics and programming complement each other and can lead to innovative outcomes. By applying mathematical principles, you can refine algorithms, identify patterns, streamline processes, and better understand your code’s underlying logic.

\sphinxAtStartPar
What this chapter covers:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Introduction to Mathematics in Coding:} Set the stage by understanding the symbiotic relationship between mathematics and programming and how mathematical concepts enrich your coding toolkit.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Number Theory and Modular Arithmetic:} Delve into number theory, understanding modular arithmetic and its applications.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Combinatorics and Probability:} Uncover the power of combinatorial mathematics and probability theory in solving problems related to permutations, combinations, and statistical analysis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Problem\sphinxhyphen{}Solving with Mathematics:} Develop strategies for leveraging mathematical concepts to solve problems efficiently and elegantly, from optimization tasks to simulation challenges.

\end{enumerate}

\sphinxstepscope


\section{Excel Sheet Column Number}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:excel-sheet-column-number}}\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/excel\sphinxhyphen{}sheet\sphinxhyphen{}column\sphinxhyphen{}number/
%
\end{footnote}Given a string \sphinxcode{\sphinxupquote{columnTitle}} that represents the column title as appears in an Excel sheet, return its corresponding column number.

\sphinxAtStartPar
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
A \PYGZhy{}\PYGZgt{} 1
B \PYGZhy{}\PYGZgt{} 2
C \PYGZhy{}\PYGZgt{} 3
...
Z \PYGZhy{}\PYGZgt{} 26
AA \PYGZhy{}\PYGZgt{} 27
AB \PYGZhy{}\PYGZgt{} 28 
...
\end{sphinxVerbatim}


\subsubsection{Example 1}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: columnTitle = \PYGZdq{}A\PYGZdq{}
Output: 1
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: columnTitle = \PYGZdq{}AB\PYGZdq{}
Output: 28
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: columnTitle = \PYGZdq{}ZY\PYGZdq{}
Output: 701
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= columnTitle.length \textless{}= 7}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{columnTitle}} consists only of uppercase English letters.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{columnTitle}} is in the range \sphinxcode{\sphinxupquote{{[}"A", "FXSHRXW"{]}}}.

\end{itemize}


\subsection{Solution: Finding The Pattern}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:solution-finding-the-pattern}}
\sphinxAtStartPar
Let us write down some other \sphinxcode{\sphinxupquote{columnTitle}} strings and its value.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdq{}A\PYGZdq{}   =  1
\PYGZdq{}Z\PYGZdq{}   =  26
\PYGZdq{}AA\PYGZdq{}  =  27
\PYGZdq{}AZ\PYGZdq{}  =  52
\PYGZdq{}ZZ\PYGZdq{}  =  702
\PYGZdq{}AAA\PYGZdq{} =  703
\end{sphinxVerbatim}

\sphinxAtStartPar
Then try to find the pattern

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdq{}A\PYGZdq{}   =  1    =  1
\PYGZdq{}Z\PYGZdq{}   =  26   =  26
\PYGZdq{}AA\PYGZdq{}  =  27   =  26 + 1
\PYGZdq{}AZ\PYGZdq{}  =  52   =  26 + 26
\PYGZdq{}ZZ\PYGZdq{}  =  702  =  26*26 + 26
\PYGZdq{}AAA\PYGZdq{} =  703  =  26*26 + 26 + 1
\end{sphinxVerbatim}

\sphinxAtStartPar
If you map \sphinxcode{\sphinxupquote{\textquotesingle{}A\textquotesingle{} = 1, ..., \textquotesingle{}Z\textquotesingle{} = 26}}, the values can be rewritten as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdq{}A\PYGZdq{}   =  1    =  \PYGZsq{}A\PYGZsq{}
\PYGZdq{}Z\PYGZdq{}   =  26   =  \PYGZsq{}Z\PYGZsq{}
\PYGZdq{}AA\PYGZdq{}  =  27   =  26*\PYGZsq{}A\PYGZsq{} + \PYGZsq{}A\PYGZsq{}
\PYGZdq{}AZ\PYGZdq{}  =  52   =  26*\PYGZsq{}A\PYGZsq{} + \PYGZsq{}Z\PYGZsq{}
\PYGZdq{}ZZ\PYGZdq{}  =  702  =  26*\PYGZsq{}Z\PYGZsq{} + \PYGZsq{}Z\PYGZsq{}
\PYGZdq{}AAA\PYGZdq{} =  703  =  26*26*\PYGZsq{}A\PYGZsq{} + 26*\PYGZsq{}A\PYGZsq{} + \PYGZsq{}A\PYGZsq{}
\end{sphinxVerbatim}

\sphinxAtStartPar
In general the formula for a string \sphinxcode{\sphinxupquote{columnTitle = abcd}} is

\begin{sphinxVerbatim}[commandchars=\\\{\}]
abcd = 26\PYGZca{}3*a + 26\PYGZca{}2*b + 26*c + d,
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{a, b, c, d}} are some uppercase English letters \sphinxcode{\sphinxupquote{A, ..., Z}}.

\sphinxAtStartPar
Longer \sphinxcode{\sphinxupquote{columnTitle}}s will have bigger leading exponents of \sphinxcode{\sphinxupquote{26}}.


\subsubsection{Code}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{titleToNumber}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{string}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{columnTitle}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{column}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{columnTitle}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// The ASCII value of \PYGZsq{}A\PYGZsq{} is 65.}
\PYG{+w}{        }\PYG{n}{column}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{26}\PYG{o}{*}\PYG{n}{column}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{c}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{64}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{column}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{titleToNumber}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{A}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{titleToNumber}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{AB}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{titleToNumber}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{ZY}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
28
701
\end{sphinxVerbatim}

\sphinxAtStartPar
The solution calculates the decimal representation of the Excel column title by processing each character and updating the result.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = columnTitle.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsubsection{Implementation notes}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:implementation-notes}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
There are many ways to compute the series

\begin{sphinxVerbatim}[commandchars=\\\{\}]
26\PYGZca{}3*a + 26\PYGZca{}2*b + 26*c + d.
\end{sphinxVerbatim}

\sphinxAtStartPar
If you write it as

\begin{sphinxVerbatim}[commandchars=\\\{\}]
26*(26*(26*(0 + a) + b) + c) + d,
\end{sphinxVerbatim}

\sphinxAtStartPar
you get the loop in the code above.

\item {} 
\sphinxAtStartPar
To map \sphinxcode{\sphinxupquote{\textquotesingle{}A\textquotesingle{} = 1, ..., \textquotesingle{}Z\textquotesingle{} = 26}}, you can use their ASCII values (\sphinxcode{\sphinxupquote{\textquotesingle{}A\textquotesingle{} = 65, ..., \textquotesingle{}Z\textquotesingle{} = 90}}) minus \sphinxcode{\sphinxupquote{64}}.

\item {} 
\sphinxAtStartPar
The parentheses around \sphinxcode{\sphinxupquote{(c \sphinxhyphen{} 64)}} is needed. Otherwise the value of \sphinxcode{\sphinxupquote{columnTitle = "FXSHRXW"}} makes \sphinxcode{\sphinxupquote{26*column + c}} exceed the limit of \sphinxcode{\sphinxupquote{int}} before it subtracts \sphinxcode{\sphinxupquote{64}}.

\end{enumerate}


\subsection{Exercise}
\label{\detokenize{Mathematics/171_Excel_Sheet_Collumn_Number:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/excel-sheet-column-title/}{Excel Sheet Column Title}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Power of Three}
\label{\detokenize{Mathematics/326_Power_of_Three:power-of-three}}\label{\detokenize{Mathematics/326_Power_of_Three::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/326_Power_of_Three:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/power\sphinxhyphen{}of\sphinxhyphen{}three/
%
\end{footnote}Given an integer \sphinxcode{\sphinxupquote{n}}, return \sphinxcode{\sphinxupquote{true}} if it is a power of three. Otherwise, return \sphinxcode{\sphinxupquote{false}}.

\sphinxAtStartPar
An integer \sphinxcode{\sphinxupquote{n}} is a power of three, if there exists an integer \sphinxcode{\sphinxupquote{x}} such that \sphinxcode{\sphinxupquote{n == 3\textasciicircum{}x}}.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/326_Power_of_Three:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 27
Output: true
Explanation: 27 = 3\PYGZca{}3.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/326_Power_of_Three:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 0
Output: false
Explanation: There is no x where 3\PYGZca{}x = 0.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Mathematics/326_Power_of_Three:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = \PYGZhy{}1
Output: false
Explanation: There is no x where 3\PYGZca{}x = (\PYGZhy{}1).
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/326_Power_of_Three:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}2\textasciicircum{}31 \textless{}= n \textless{}= 2\textasciicircum{}31 \sphinxhyphen{} 1}}.

\end{itemize}


\subsubsection{Follow up}
\label{\detokenize{Mathematics/326_Power_of_Three:follow-up}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Could you solve it without loops/recursion?

\end{itemize}


\subsection{Solution 1: Repeat the division}
\label{\detokenize{Mathematics/326_Power_of_Three:solution-1-repeat-the-division}}

\subsubsection{Code}
\label{\detokenize{Mathematics/326_Power_of_Three:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPowerOfThree}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{/}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution repeatedly divides the input by 3 until it either becomes 1 (indicating that it was a power of three) or cannot be divided further by 3.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/326_Power_of_Three:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(logn)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Mathematics and the constraints of the problem}
\label{\detokenize{Mathematics/326_Power_of_Three:solution-2-mathematics-and-the-constraints-of-the-problem}}
\sphinxAtStartPar
A power of three must divide another bigger one, i.e. \(3^x | 3^y\) where \(0 \leq x \leq y\).

\sphinxAtStartPar
Because the constraint of the problem is \(n \leq 2^{31} - 1\), you can choose the biggest power of three in this range to test the others.

\sphinxAtStartPar
It is \(3^{19} = 1162261467\). The next power will exceed \(2^{31} = 2147483648\).


\subsubsection{Code}
\label{\detokenize{Mathematics/326_Power_of_Three:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isPowerOfThree}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{l+m+mi}{1162261467}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{27}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{isPowerOfThree}\PYG{p}{(}\PYG{l+m+mi}{\PYGZhy{}1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
0
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution effectively checks whether \sphinxcode{\sphinxupquote{n}} is a power of three by verifying if it is a divisor of the largest power of three that fits within 32 bits. If the condition is met, it returns \sphinxcode{\sphinxupquote{true}}, indicating that \sphinxcode{\sphinxupquote{n}} is a power of three; otherwise, it returns \sphinxcode{\sphinxupquote{false}}.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/326_Power_of_Three:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(1)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Readable code}
\label{\detokenize{Mathematics/326_Power_of_Three:readable-code}}
\sphinxAtStartPar
Though Solution 2 offers a direct approach without the need for iteration, it is not easy to understand like Solution 1, where complexity of \sphinxcode{\sphinxupquote{O(logn)}} is not too bad.


\subsection{Exercise}
\label{\detokenize{Mathematics/326_Power_of_Three:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/}{Check if Number is a Sum of Powers of Three}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Best Time to Buy and Sell Stock}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:best-time-to-buy-and-sell-stock}}\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/best\sphinxhyphen{}time\sphinxhyphen{}to\sphinxhyphen{}buy\sphinxhyphen{}and\sphinxhyphen{}sell\sphinxhyphen{}stock/
%
\end{footnote}You are given an array \sphinxcode{\sphinxupquote{prices}} where \sphinxcode{\sphinxupquote{prices{[}i{]}}} is the price of a given stock on the \sphinxcode{\sphinxupquote{i\sphinxhyphen{}th}} day.

\sphinxAtStartPar
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

\sphinxAtStartPar
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6\PYGZhy{}1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= prices.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= prices{[}i{]} \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution 1: Bruteforce}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:solution-1-bruteforce}}
\sphinxAtStartPar
For each day \sphinxcode{\sphinxupquote{i}}, find the day \sphinxcode{\sphinxupquote{j \textgreater{} i}} that gives maximum profit.


\subsubsection{Code}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxProfit}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{        }
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{prices}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxProfit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
0
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution uses a brute force approach to find the maximum profit. It compares the profit obtained by buying on each day with selling on all subsequent days and keeps track of the maximum profit found.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N\textasciicircum{}2)}}, where \sphinxcode{\sphinxupquote{N = prices.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Smallest and largest prices}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:solution-2-smallest-and-largest-prices}}
\sphinxAtStartPar
Given a past day \sphinxcode{\sphinxupquote{i}}, the future day \sphinxcode{\sphinxupquote{j \textgreater{} i}} that gives the maximum profit is the day that has the largest price which is bigger than \sphinxcode{\sphinxupquote{prices{[}i{]}}}.

\sphinxAtStartPar
Conversely, given a future day \sphinxcode{\sphinxupquote{j}}, the past day \sphinxcode{\sphinxupquote{i \textless{} j}} that gives the maximum profit is the day with the smallest price.


\subsubsection{Code}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxProfit}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// while prices are going down,}
\PYG{+w}{        }\PYG{c+c1}{// find the bottommost one to start}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{c+c1}{// find the largest price in the future}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{imax}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max\PYGZus{}element}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// find the smallest price in the past}
\PYG{+w}{        }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{imin}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{min\PYGZus{}element}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{imax}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxProfit}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{imax}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{imin}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// next iteration starts after the found largest price }
\PYG{+w}{        }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{distance}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{imax}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
0
6
2
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution optimally finds the maximum profit by iterating through the array only once, avoiding the need for nested loops.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = prices.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 3: Only the smallest price}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:solution-3-only-the-smallest-price}}
\sphinxAtStartPar
Given a future day \sphinxcode{\sphinxupquote{j}}, the past day \sphinxcode{\sphinxupquote{i}} that gives the maximum profit is the day with minimum price.


\subsubsection{Code}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:id4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{maxProfit}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// keep track the minimum price so fat}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{minPrice}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{  }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// update the minimum price}
\PYG{+w}{        }\PYG{n}{minPrice}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{(}\PYG{n}{minPrice}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{maxProfit}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{maxProfit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{minPrice}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{prices}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{prices}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{maxProfit}\PYG{p}{(}\PYG{n}{prices}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
0
6
2
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently computes the maximum profit by iterating through the array only once, maintaining the minimum buying price and updating the maximum profit accordingly.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:id5}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(N)}}, where \sphinxcode{\sphinxupquote{N = prices.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:key-takeaway}}
\sphinxAtStartPar
The problem of finding the maximum profit that can be achieved by buying and selling a stock can be efficiently solved using different approaches. Solutions 1, 2, and 3 each offer a different approach to solving the problem, including brute\sphinxhyphen{}force iteration, finding local minima and maxima, and maintaining a running minimum price.

\sphinxAtStartPar
Solution 3 stands out as the most efficient approach, achieving a linear time complexity by iterating through the prices only once and updating the minimum price seen so far. This approach avoids unnecessary comparisons and achieves the desired result in a single pass through the array.


\subsection{Exercise}
\label{\detokenize{Mathematics/121_Best_Time_to_Buy_and_Sell_Stock:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/}{Best Time to Buy and Sell Stock II}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Subsets}
\label{\detokenize{Mathematics/78_Subsets:subsets}}\label{\detokenize{Mathematics/78_Subsets::doc}}

\subsection{Problem Statement}
\label{\detokenize{Mathematics/78_Subsets:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/subsets/
%
\end{footnote}Given an integer array \sphinxcode{\sphinxupquote{nums}} of unique elements, return all possible subsets (the \index{power set@\spxentry{power set}}power set).

\sphinxAtStartPar
The solution set must not contain duplicate subsets. Return the solution in any order.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/78_Subsets:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/78_Subsets:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1]
Output: [[],[1]]
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/78_Subsets:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10 \textless{}= nums{[}i{]} \textless{}= 10}}.

\item {} 
\sphinxAtStartPar
All the numbers of \sphinxcode{\sphinxupquote{nums}} are unique.

\end{itemize}


\subsection{Solution}
\label{\detokenize{Mathematics/78_Subsets:solution}}
\sphinxAtStartPar
You might need to find the relationship between the result of the array \sphinxcode{\sphinxupquote{nums}} with the result of itself without the last element.


\subsubsection{Example 3}
\label{\detokenize{Mathematics/78_Subsets:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2]
Output: [[],[1],[2],[1,2]]
\end{sphinxVerbatim}

\sphinxAtStartPar
You can see the powerset of Example 3 was obtained from the one in Example 2 with additional subsets \sphinxcode{\sphinxupquote{{[}2{]}}}, \sphinxcode{\sphinxupquote{{[}1,2{]}}}. These new subsets were constructed from subsets \sphinxcode{\sphinxupquote{{[}{]}}}, \sphinxcode{\sphinxupquote{{[}1{]}}} of Example 2 appended with the new element \sphinxcode{\sphinxupquote{2}}.

\sphinxAtStartPar
Similarly, the powerset of Example 1 was obtained from the one in Example 3 with the additional subsets \sphinxcode{\sphinxupquote{{[}3{]}}}, \sphinxcode{\sphinxupquote{{[}1,3{]}}}, \sphinxcode{\sphinxupquote{{[}2,3{]}}}, \sphinxcode{\sphinxupquote{{[}1,2,3{]}}}. These new subsets were constructed from the ones of Example 3 appended with the new element \sphinxcode{\sphinxupquote{3}}.


\subsubsection{Code}
\label{\detokenize{Mathematics/78_Subsets:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{subsets}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{powerset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZob{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{newSubsets}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{subset}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{powerset}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{subset}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{  }
\PYG{+w}{            }\PYG{n}{newSubsets}\PYG{p}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{subset}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{powerset}\PYG{p}{.}\PYG{n}{insert}\PYG{p}{(}\PYG{n}{powerset}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{newSubsets}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{newSubsets}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{powerset}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n}{print}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{powerset}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{set}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{powerset}\PYG{+w}{ }\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{[}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{element}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{set}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{element}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{,}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{]}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{powerset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{powerset}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{powerset}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{subsets}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{print}\PYG{p}{(}\PYG{n}{powerset}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
[][1,][2,][1,2,][3,][1,3,][2,3,][1,2,3,]
[][1,]
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Mathematics/78_Subsets:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(2\textasciicircum{}N)}}, where \sphinxcode{\sphinxupquote{N}} is the number of elements in \sphinxcode{\sphinxupquote{nums}}, as it generates all possible subsets.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(2\textasciicircum{}N)}} due to the space required to store the subsets.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Mathematics/78_Subsets:key-takeaway}}
\sphinxAtStartPar
This solution generates subsets by iteratively adding each element of \sphinxcode{\sphinxupquote{nums}} to the existing subsets and accumulating the results.

\sphinxAtStartPar
Note that in \sphinxcode{\sphinxupquote{for (auto subset : powerset)}} you should not use reference \sphinxcode{\sphinxupquote{auto\&}} because we do not want to change the subsets that have been created.


\subsection{Exercise}
\label{\detokenize{Mathematics/78_Subsets:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/subsets-ii/}{Subsets II}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Minimum Moves to Equal Array Elements II}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:minimum-moves-to-equal-array-elements-ii}}\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/minimum\sphinxhyphen{}moves\sphinxhyphen{}to\sphinxhyphen{}equal\sphinxhyphen{}array\sphinxhyphen{}elements\sphinxhyphen{}ii/
%
\end{footnote}Given an integer array \sphinxcode{\sphinxupquote{nums}} of size \sphinxcode{\sphinxupquote{n}}, return the minimum number of moves required to make all array elements equal.

\sphinxAtStartPar
In one move, you can increment or decrement an element of the array by \sphinxcode{\sphinxupquote{1}}.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =\PYGZgt{}  [2,2,3]  =\PYGZgt{}  [2,2,2]
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [1,10,2,9]
Output: 16
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n == nums.length}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\sphinxhyphen{}10\textasciicircum{}9 \textless{}= nums{[}i{]} \textless{}= 10\textasciicircum{}9}}.

\end{itemize}


\subsection{Solution 1: Median \sphinxhyphen{} The math behind the problem}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:solution-1-median-the-math-behind-the-problem}}
\sphinxAtStartPar
You are asked to move all elements of an array to the same value \sphinxcode{\sphinxupquote{M}}. The problem can be reduced to identifying what \sphinxcode{\sphinxupquote{M}} is.

\sphinxAtStartPar
First, moving elements of an unsorted array and moving a sorted one are the same. So you can assume \sphinxcode{\sphinxupquote{nums}} is sorted in some order. Let us say it is sorted in ascending order.

\sphinxAtStartPar
Second, \sphinxcode{\sphinxupquote{M}} must be in between the minimum element and the maximum one. Apparently!

\sphinxAtStartPar
We will prove that \sphinxcode{\sphinxupquote{M}} will be the \sphinxhref{https://en.wikipedia.org/wiki/Median}{median} of \sphinxcode{\sphinxupquote{nums}}, which is \sphinxcode{\sphinxupquote{nums{[}n/2{]}}} of the sorted \sphinxcode{\sphinxupquote{nums}}.

\sphinxAtStartPar
In other words, we will prove that if you choose \sphinxcode{\sphinxupquote{M}} a value different from \sphinxcode{\sphinxupquote{nums{[}n/2{]}}}, then the number of moves will be increased.

\sphinxAtStartPar
In fact, if you choose \sphinxcode{\sphinxupquote{M = nums{[}n/2{]} + x}}, where \sphinxcode{\sphinxupquote{x \textgreater{} 0}}, then:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Each element \sphinxcode{\sphinxupquote{nums{[}i{]}}} that is less than \sphinxcode{\sphinxupquote{M}} needs more \sphinxcode{\sphinxupquote{x}} moves, while each \sphinxcode{\sphinxupquote{nums{[}j{]}}} that is greater than \sphinxcode{\sphinxupquote{M}} can reduce \sphinxcode{\sphinxupquote{x}} moves.

\item {} 
\sphinxAtStartPar
But the number of \sphinxcode{\sphinxupquote{nums{[}i{]}}} is bigger than the number of \sphinxcode{\sphinxupquote{nums{[}j{]}}}.

\item {} 
\sphinxAtStartPar
So the total number of moves is bigger.

\end{itemize}

\sphinxAtStartPar
The same arguments apply for \sphinxcode{\sphinxupquote{x \textless{} 0}}.


\subsubsection{Example 3}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:example-3}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{nums = {[}0,1,2,2,10{]}}}. Its median is \sphinxcode{\sphinxupquote{2}}. The minimum number of moves is \sphinxcode{\sphinxupquote{2 + 1 + 0 + 0 + 8 = 11}}.

\sphinxAtStartPar
If you choose \sphinxcode{\sphinxupquote{M = 3}} (the average value, the mean), the total number of moves is \sphinxcode{\sphinxupquote{3 + 2 + 1 + 1 + 7 = 14}}.


\subsubsection{Code}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minMoves2}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{sort}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{median}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{moves}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{moves}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{median}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{moves}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minMoves2}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minMoves2}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
16
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution leverages the concept of the median to minimize the total absolute differences between each element and the median, resulting in the minimum number of moves to equalize the array.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*logn)}} due to the sorting step, where \sphinxcode{\sphinxupquote{n}} is the number of elements in the \sphinxcode{\sphinxupquote{nums}} array.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: Using \sphinxstyleliteralintitle{\sphinxupquote{std::nth\_element}} to compute the median}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:solution-2-using-std-nth-element-to-compute-the-median}}
\sphinxAtStartPar
What you only need in Solution 1 is the median value. Computing the total number of moves in the \sphinxcode{\sphinxupquote{for}} loop does not require the array \sphinxcode{\sphinxupquote{nums}} to be fully sorted.

\sphinxAtStartPar
In this case, you can use \sphinxhref{https://en.cppreference.com/w/cpp/algorithm/nth\_element}{\sphinxcode{\sphinxupquote{std::nth\_element}}} to reduce the runtime complexity.


\subsubsection{Code}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:id2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{minMoves2}\PYG{p}{(}\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{mid}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{    }
\PYG{+w}{    }\PYG{c+c1}{// make sure all elements that are less than or equals to nums[mid]}
\PYG{+w}{    }\PYG{c+c1}{// are on the left}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{nth\PYGZus{}element}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{mid}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{median}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{moves}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{a}\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{moves}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{abs}\PYG{p}{(}\PYG{n}{a}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{median}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{moves}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minMoves2}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{minMoves2}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
2
16
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently finds the median of the \sphinxcode{\sphinxupquote{nums}} array in linear time using \sphinxcode{\sphinxupquote{std::nth\_element}} and then calculates the minimum number of moves to make all elements equal to this median.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:id3}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}, where \sphinxcode{\sphinxupquote{n = nums.length}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Modern C++ tips}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:modern-c-tips}}
\sphinxAtStartPar
In the code of Solution 2, the partial sorting algorithm \sphinxhref{https://en.cppreference.com/w/cpp/algorithm/nth\_element}{\sphinxcode{\sphinxupquote{std::nth\_element}}} will make sure for all indices \sphinxcode{\sphinxupquote{i}} and \sphinxcode{\sphinxupquote{j}} that satisfy \sphinxcode{\sphinxupquote{0 \textless{}= i \textless{}= mid \textless{}= j \textless{} nums.length}}, then

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{mid}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{nums}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{.}
\end{sphinxVerbatim}

\sphinxAtStartPar
With this property, if \sphinxcode{\sphinxupquote{mid = nums.length / 2}}, then the value of \sphinxcode{\sphinxupquote{nums{[}mid{]}}} is unchanged no matter how \sphinxcode{\sphinxupquote{nums}} is sorted or not.


\subsection{Exercise}
\label{\detokenize{Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/minimum-moves-to-equal-array-elements/}{Minimum Moves to Equal Array Elements}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Array Nesting}
\label{\detokenize{Mathematics/565_Array_Nesting:array-nesting}}\label{\detokenize{Mathematics/565_Array_Nesting::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/565_Array_Nesting:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/array\sphinxhyphen{}nesting/
%
\end{footnote}You are given an integer array \sphinxcode{\sphinxupquote{nums}} of length \sphinxcode{\sphinxupquote{n}} where \sphinxcode{\sphinxupquote{nums}} is a permutation of the numbers in the range \sphinxcode{\sphinxupquote{{[}0, n \sphinxhyphen{} 1{]}}}.

\sphinxAtStartPar
You should build a set \sphinxcode{\sphinxupquote{s{[}k{]} = \{nums{[}k{]}, nums{[}nums{[}k{]}{]}, nums{[}nums{[}nums{[}k{]}{]}{]}, ... \}}} subjected to the following rule:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The first element in \sphinxcode{\sphinxupquote{s{[}k{]}}} starts with the element \sphinxcode{\sphinxupquote{nums{[}k{]}}}.

\item {} 
\sphinxAtStartPar
The next element in \sphinxcode{\sphinxupquote{s{[}k{]}}} should be \sphinxcode{\sphinxupquote{nums{[}nums{[}k{]}{]}}}, and then \sphinxcode{\sphinxupquote{nums{[}nums{[}nums{[}k{]}{]}{]}}}, and so on.

\item {} 
\sphinxAtStartPar
We stop adding elements before a duplicate element occurs in \sphinxcode{\sphinxupquote{s{[}k{]}}}.

\end{itemize}

\sphinxAtStartPar
Return the length of the longest set \sphinxcode{\sphinxupquote{s{[}k{]}}}.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/565_Array_Nesting:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.
One of the longest sets s[k]:
s[0] = \PYGZob{}nums[0], nums[5], nums[6], nums[2]\PYGZcb{} = \PYGZob{}5, 6, 2, 0\PYGZcb{}
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/565_Array_Nesting:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: nums = [0,1,2]
Output: 1
\end{sphinxVerbatim}


\subsubsection{Constraints:}
\label{\detokenize{Mathematics/565_Array_Nesting:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= nums.length \textless{}= 10\textasciicircum{}5}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{0 \textless{}= nums{[}i{]} \textless{} nums.length}}.

\item {} 
\sphinxAtStartPar
All the values of \sphinxcode{\sphinxupquote{nums}} are unique.

\end{itemize}


\subsection{Solution: Understanding the math behind}
\label{\detokenize{Mathematics/565_Array_Nesting:solution-understanding-the-math-behind}}
\sphinxAtStartPar
A \sphinxhref{https://en.wikipedia.org/wiki/Permutation}{permutation} is a one\sphinxhyphen{}to\sphinxhyphen{}one mapping from a set of integers to itself.

\sphinxAtStartPar
The \index{permutation@\spxentry{permutation}}permutation on the set \sphinxcode{\sphinxupquote{nums}} in this problem is defined by the mapping \sphinxcode{\sphinxupquote{i \sphinxhyphen{}\textgreater{} nums{[}i{]}}}. For instance in Example 1, the permutation is defined as following:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 \PYGZhy{}\PYGZgt{} 5,
1 \PYGZhy{}\PYGZgt{} 4,
2 \PYGZhy{}\PYGZgt{} 0,
3 \PYGZhy{}\PYGZgt{} 3,
4 \PYGZhy{}\PYGZgt{} 1,
5 \PYGZhy{}\PYGZgt{} 6,
6 \PYGZhy{}\PYGZgt{} 2.
\end{sphinxVerbatim}

\sphinxAtStartPar
You can always rearrange the definition of a permutation into groups of cyclic chains (factors).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
0 \PYGZhy{}\PYGZgt{} 5, 5 \PYGZhy{}\PYGZgt{} 6, 6 \PYGZhy{}\PYGZgt{} 2, 2 \PYGZhy{}\PYGZgt{} 0,
1 \PYGZhy{}\PYGZgt{} 4, 4 \PYGZhy{}\PYGZgt{} 1,
3 \PYGZhy{}\PYGZgt{} 3
\end{sphinxVerbatim}

\sphinxAtStartPar
The set \sphinxcode{\sphinxupquote{s{[}k{]}}} in this problem is such a chain. In mathematics, it is called a \sphinxstyleemphasis{cycle}; because the chain \sphinxcode{\sphinxupquote{(0, 5, 6, 2)}} is considered the same as \sphinxcode{\sphinxupquote{(5, 6, 2, 0)}}, \sphinxcode{\sphinxupquote{(6, 2, 0, 5)}} or \sphinxcode{\sphinxupquote{(2, 0, 5, 6)}} in Example 1.

\sphinxAtStartPar
Assume you have used some elements of the array \sphinxcode{\sphinxupquote{nums}} to construct some cycles. To construct another one, you should start with the unused elements.

\sphinxAtStartPar
The problem leads to finding the longest cycle of a given permutation.


\subsubsection{Code}
\label{\detokenize{Mathematics/565_Array_Nesting:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}vector\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}algorithm\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{arrayNesting}\PYG{p}{(}\PYG{k}{const}\PYG{+w}{ }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{maxLen}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{bool}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{visited}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k}{auto}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{:}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{visited}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{continue}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{len}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{+w}{        }\PYG{c+c1}{// visit the cycle starting from i}
\PYG{+w}{        }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{o}{!}\PYG{n}{visited}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{visited}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n+nb}{true}\PYG{p}{;}
\PYG{+w}{            }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{nums}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}\PYG{+w}{            }
\PYG{+w}{            }\PYG{n}{len}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{n}{maxLen}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{max}\PYG{p}{(}\PYG{n}{len}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{maxLen}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{maxLen}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arrayNesting}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arrayNesting}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arrayNesting}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{nums}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{;}\PYG{+w}{ }
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{arrayNesting}\PYG{p}{(}\PYG{n}{nums}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
4
1
2
3
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Mathematics/565_Array_Nesting:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}} where \sphinxcode{\sphinxupquote{n}} is the size of the \sphinxcode{\sphinxupquote{nums}} array.

\item {} 
\sphinxAtStartPar
Extra space: much less than \sphinxcode{\sphinxupquote{O(n)}} since \sphinxhref{https://en.cppreference.com/w/cpp/container/vector\_bool}{\sphinxcode{\sphinxupquote{vector\textless{}bool\textgreater{}}}} is optimized for space efficiency.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Mathematics/565_Array_Nesting:key-takeaway}}
\sphinxAtStartPar
The problem of finding the length of the longest cycle in an array can be efficiently solved using a cycle detection approach. This solution efficiently detects cycles in the array by using a boolean array to mark visited elements.

\sphinxAtStartPar
By iterating through each element in the array and visiting the cycle starting from each unvisited element, the solution identifies the length of each cycle and updates the maximum length accordingly. This approach ensures that each cycle is visited only once and maximizes the length of the longest cycle in the array.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Count Sorted Vowel Strings}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:count-sorted-vowel-strings}}\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/count\sphinxhyphen{}sorted\sphinxhyphen{}vowel\sphinxhyphen{}strings/
%
\end{footnote}Given an integer \sphinxcode{\sphinxupquote{n}}, return the number of strings of length \sphinxcode{\sphinxupquote{n}} that consist only of vowels (\sphinxcode{\sphinxupquote{a}}, \sphinxcode{\sphinxupquote{e}}, \sphinxcode{\sphinxupquote{i}}, \sphinxcode{\sphinxupquote{o}}, \sphinxcode{\sphinxupquote{u}}) and are lexicographically sorted.

\sphinxAtStartPar
A string \sphinxcode{\sphinxupquote{s}} is lexicographically sorted if for all valid \sphinxcode{\sphinxupquote{i}}, \sphinxcode{\sphinxupquote{s{[}i{]}}} is the same as or comes before \sphinxcode{\sphinxupquote{s{[}i+1{]}}} in the alphabet.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 1
Output: 5
Explanation: The 5 sorted strings that consist of vowels only are [\PYGZdq{}a\PYGZdq{},\PYGZdq{}e\PYGZdq{},\PYGZdq{}i\PYGZdq{},\PYGZdq{}o\PYGZdq{},\PYGZdq{}u\PYGZdq{}].
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 2
Output: 15
Explanation: The 15 sorted strings that consist of vowels only are
[\PYGZdq{}aa\PYGZdq{},\PYGZdq{}ae\PYGZdq{},\PYGZdq{}ai\PYGZdq{},\PYGZdq{}ao\PYGZdq{},\PYGZdq{}au\PYGZdq{},\PYGZdq{}ee\PYGZdq{},\PYGZdq{}ei\PYGZdq{},\PYGZdq{}eo\PYGZdq{},\PYGZdq{}eu\PYGZdq{},\PYGZdq{}ii\PYGZdq{},\PYGZdq{}io\PYGZdq{},\PYGZdq{}iu\PYGZdq{},\PYGZdq{}oo\PYGZdq{},\PYGZdq{}ou\PYGZdq{},\PYGZdq{}uu\PYGZdq{}].
Note that \PYGZdq{}ea\PYGZdq{} is not a valid string since \PYGZsq{}e\PYGZsq{} comes after \PYGZsq{}a\PYGZsq{} in the alphabet.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 33
Output: 66045
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 50}}.

\end{itemize}


\subsection{Solution 1: Finding the pattern}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:solution-1-finding-the-pattern}}
\sphinxAtStartPar
Let us find the relationship of the strings between the vowels.


\subsubsection{Example 3}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:id2}}
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{n = 3}}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
There is (always) only one string starting from \sphinxcode{\sphinxupquote{u}}, which is \sphinxcode{\sphinxupquote{uuu}}.

\item {} 
\sphinxAtStartPar
There are 3 strings starting from \sphinxcode{\sphinxupquote{o}}: \sphinxcode{\sphinxupquote{ooo}}, \sphinxcode{\sphinxupquote{oou}} and \sphinxcode{\sphinxupquote{ouu}}.

\item {} 
\sphinxAtStartPar
There are 6 strings starting from \sphinxcode{\sphinxupquote{i}}: \sphinxcode{\sphinxupquote{iii}}, \sphinxcode{\sphinxupquote{iio}}, \sphinxcode{\sphinxupquote{iiu}}, \sphinxcode{\sphinxupquote{ioo}}, \sphinxcode{\sphinxupquote{iou}}, \sphinxcode{\sphinxupquote{iuu}}.

\item {} 
\sphinxAtStartPar
There are 10 strings starting from \sphinxcode{\sphinxupquote{e}}: \sphinxcode{\sphinxupquote{eee}}, \sphinxcode{\sphinxupquote{eei}}, \sphinxcode{\sphinxupquote{eeo}}, \sphinxcode{\sphinxupquote{eeu}}, \sphinxcode{\sphinxupquote{eii}}, \sphinxcode{\sphinxupquote{eio}}, \sphinxcode{\sphinxupquote{eiu}}, \sphinxcode{\sphinxupquote{eoo}}, \sphinxcode{\sphinxupquote{eou}}, \sphinxcode{\sphinxupquote{euu}}.

\item {} 
\sphinxAtStartPar
There are 15 strings starting from \sphinxcode{\sphinxupquote{a}}: \sphinxcode{\sphinxupquote{aaa}}, \sphinxcode{\sphinxupquote{aae}}, \sphinxcode{\sphinxupquote{aai}}, \sphinxcode{\sphinxupquote{aao}}, \sphinxcode{\sphinxupquote{aau}}, \sphinxcode{\sphinxupquote{aee}}, \sphinxcode{\sphinxupquote{aei}}, \sphinxcode{\sphinxupquote{aeo}}, \sphinxcode{\sphinxupquote{aeu}}, \sphinxcode{\sphinxupquote{aii}}, \sphinxcode{\sphinxupquote{aio}}, \sphinxcode{\sphinxupquote{aiu}}, \sphinxcode{\sphinxupquote{aoo}}, \sphinxcode{\sphinxupquote{aou}}, \sphinxcode{\sphinxupquote{auu}}.

\item {} 
\sphinxAtStartPar
In total: there are 35 strings that satisfy the problem.

\end{itemize}


\subsubsection{Findings}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:findings}}
\sphinxAtStartPar
In Example 3, if you ignore the leading vowel of those strings, then the shorted strings of the line above all appear in the ones of the line below and the remaining strings of the line below come from \sphinxcode{\sphinxupquote{n = 2}}.

\sphinxAtStartPar
More precisely:
\begin{itemize}
\item {} 
\sphinxAtStartPar
All the shorted strings \sphinxcode{\sphinxupquote{oo}}, \sphinxcode{\sphinxupquote{ou}} and \sphinxcode{\sphinxupquote{uu}} starting from \sphinxcode{\sphinxupquote{o}} appear on the ones starting from \sphinxcode{\sphinxupquote{i}}. The remaining \sphinxcode{\sphinxupquote{ii}}, \sphinxcode{\sphinxupquote{io}}, \sphinxcode{\sphinxupquote{iu}} starting from \sphinxcode{\sphinxupquote{i}} come from the strings of length \sphinxcode{\sphinxupquote{n = 2}} (see Example 2).

\item {} 
\sphinxAtStartPar
Similarly, all shorted strings \sphinxcode{\sphinxupquote{ii}}, \sphinxcode{\sphinxupquote{io}}, \sphinxcode{\sphinxupquote{iu}}, \sphinxcode{\sphinxupquote{oo}}, \sphinxcode{\sphinxupquote{ou}}, \sphinxcode{\sphinxupquote{uu}} starting from \sphinxcode{\sphinxupquote{i}} appear on the ones starting from \sphinxcode{\sphinxupquote{e}}. The remaining \sphinxcode{\sphinxupquote{ee}}, \sphinxcode{\sphinxupquote{ei}}, \sphinxcode{\sphinxupquote{eo}}, \sphinxcode{\sphinxupquote{eu}} come from \sphinxcode{\sphinxupquote{n = 2}}.

\item {} 
\sphinxAtStartPar
And so on.

\end{itemize}

\sphinxAtStartPar
That leads to the following recursive relationship.

\sphinxAtStartPar
Let \sphinxcode{\sphinxupquote{S(x, n)}} be the number of strings of length \sphinxcode{\sphinxupquote{n}} starting from a vowel \sphinxcode{\sphinxupquote{x}}.  Then
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(\textquotesingle{}o\textquotesingle{}, n) = S(\textquotesingle{}o\textquotesingle{}, n \sphinxhyphen{} 1) + S(\textquotesingle{}u\textquotesingle{}, n)}} for all \sphinxcode{\sphinxupquote{n \textgreater{} 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(\textquotesingle{}i\textquotesingle{}, n) = S(\textquotesingle{}i\textquotesingle{}, n \sphinxhyphen{} 1) + S(\textquotesingle{}o\textquotesingle{}, n)}} for all \sphinxcode{\sphinxupquote{n \textgreater{} 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(\textquotesingle{}e\textquotesingle{}, n) = S(\textquotesingle{}e\textquotesingle{}, n \sphinxhyphen{} 1) + S(\textquotesingle{}i\textquotesingle{}, n)}} for all \sphinxcode{\sphinxupquote{n \textgreater{} 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(\textquotesingle{}a\textquotesingle{}, n) = S(\textquotesingle{}a\textquotesingle{}, n \sphinxhyphen{} 1) + S(\textquotesingle{}e\textquotesingle{}, n)}} for all \sphinxcode{\sphinxupquote{n \textgreater{} 1}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(x, 1) = 1}} for all vowels \sphinxcode{\sphinxupquote{x}}.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{S(\textquotesingle{}u\textquotesingle{}, n) = 1}} for all \sphinxcode{\sphinxupquote{n \textgreater{}= 1}}.

\end{itemize}

\sphinxAtStartPar
For this problem, you want to compute

\begin{sphinxVerbatim}[commandchars=\\\{\}]
S(n) = S(\PYGZsq{}a\PYGZsq{}, n) + S(\PYGZsq{}e\PYGZsq{}, n) + S(\PYGZsq{}i\PYGZsq{}, n) + S(\PYGZsq{}o\PYGZsq{}, n) + S(\PYGZsq{}u\PYGZsq{}, n).
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{countVowelStrings}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{o}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{u}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{o}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{u}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{o}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{u}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{o}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{e}\PYG{p}{;}
\PYG{+w}{        }\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{e}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{o}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{u}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{33}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
15
66045
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution efficiently computes the count of vowel strings of length \sphinxcode{\sphinxupquote{n}} using dynamic programming, updating the counts based on the previous lengths to avoid redundant calculations.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 2: The math behind the problem}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:solution-2-the-math-behind-the-problem}}
\sphinxAtStartPar
The strings of length \sphinxcode{\sphinxupquote{n}} you want to count are formed by a number of \sphinxcode{\sphinxupquote{\textquotesingle{}a\textquotesingle{}}}, then some number of \sphinxcode{\sphinxupquote{\textquotesingle{}e\textquotesingle{}}}, then some number of  \sphinxcode{\sphinxupquote{\textquotesingle{}i\textquotesingle{}}}, then some number of \sphinxcode{\sphinxupquote{\textquotesingle{}o\textquotesingle{}}} and finally some number of \sphinxcode{\sphinxupquote{\textquotesingle{}u\textquotesingle{}}}.

\sphinxAtStartPar
So it looks like this

\begin{sphinxVerbatim}[commandchars=\\\{\}]
s = \PYGZdq{}aa..aee..eii..ioo..ouu..u\PYGZdq{}.
\end{sphinxVerbatim}

\sphinxAtStartPar
And you want to count how many possibilities of such strings of length \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
One way to count it is using combinatorics in mathematics.

\sphinxAtStartPar
If you separate the groups of vowels by \sphinxcode{\sphinxupquote{\textquotesingle{}|\textquotesingle{}}} like this

\begin{sphinxVerbatim}[commandchars=\\\{\}]
s = \PYGZdq{}aa..a|ee..e|ii..i|oo..o|uu..u\PYGZdq{},
\end{sphinxVerbatim}

\sphinxAtStartPar
the problem becomes counting how many ways of putting those 4 separators \sphinxcode{\sphinxupquote{\textquotesingle{}|\textquotesingle{}}} to form a string of length \sphinxcode{\sphinxupquote{n + 4}}.

\sphinxAtStartPar
In combinatorics, the solution is \(\binom{n + 4}{4}\), where \(\binom{n}{k}\) is the \index{binomial coefficient@\spxentry{binomial coefficient}}binomial coefficient\sphinxhref{https://en.wikipedia.org/wiki/Binomial\_coefficient}{}:
\begin{equation*}
\begin{split}
\binom{n}{k} = \frac{n!}{k!(n-k)!}.
\end{split}
\end{equation*}
\sphinxAtStartPar
The final number of strings is
\begin{equation*}
\begin{split}
\binom{n + 4}{4} = \frac{(n + 4)!}{4!n!} = \frac{(n+1)(n+2)(n+3)(n+4)}{24}.
\end{split}
\end{equation*}

\subsubsection{Code}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{countVowelStrings}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{+w}{    }
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{24}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{countVowelStrings}\PYG{p}{(}\PYG{l+m+mi}{33}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
5
15
66045
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:id4}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(1)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Mathematics/1641_Count_Sorted_Vowel_Strings:key-takeaway}}
\sphinxAtStartPar
The problem of counting the number of strings of length \sphinxcode{\sphinxupquote{n}} that consist of the vowels ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’ in sorted order can be efficiently solved using combinatorial techniques. Solution 1 uses dynamic programming to iteratively calculate the count of strings for each length up to \sphinxcode{\sphinxupquote{n}}, updating the counts based on the previous counts. This approach efficiently computes the count of sorted vowel strings for the given length \sphinxcode{\sphinxupquote{n}} without requiring excessive memory usage or computational overhead.

\sphinxAtStartPar
Solution 2 offers a more direct approach by utilizing a combinatorial formula to calculate the count of sorted vowel strings directly based on the given length \sphinxcode{\sphinxupquote{n}}. By leveraging the combinatorial formula, this solution avoids the need for iterative calculations and achieves the desired result more efficiently.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Concatenation of Consecutive Binary Numbers}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:concatenation-of-consecutive-binary-numbers}}\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/concatenation\sphinxhyphen{}of\sphinxhyphen{}consecutive\sphinxhyphen{}binary\sphinxhyphen{}numbers/
%
\end{footnote}Given an integer \sphinxcode{\sphinxupquote{n}}, return the decimal value of the binary string formed by concatenating the binary representations of \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{n}} in order, modulo \sphinxcode{\sphinxupquote{10\textasciicircum{}9 + 7}}.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 1
Output: 1
Explanation: \PYGZdq{}1\PYGZdq{} in binary corresponds to the decimal value 1. 
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 3
Output: 27
Explanation: In binary, 1, 2, and 3 corresponds to \PYGZdq{}1\PYGZdq{}, \PYGZdq{}10\PYGZdq{}, and \PYGZdq{}11\PYGZdq{}.
After concatenating them, we have \PYGZdq{}11011\PYGZdq{}, which corresponds to the decimal value 27.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 12
Output: 505379714
Explanation: The concatenation results in \PYGZdq{}1101110010111011110001001101010111100\PYGZdq{}.
The decimal value of that is 118505380540.
After modulo 10\PYGZca{}9 + 7, the result is 505379714.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 10\textasciicircum{}5}}.

\end{itemize}


\subsection{Solution: Recursive}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:solution-recursive}}
\sphinxAtStartPar
There must be some relationship between the result of \sphinxcode{\sphinxupquote{n}} and the result of \sphinxcode{\sphinxupquote{n \sphinxhyphen{} 1}}.

\sphinxAtStartPar
First, let us list some first values of \sphinxcode{\sphinxupquote{n}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{n = 1}}: the final binary string is \sphinxcode{\sphinxupquote{"1"}}, its decimal value is \sphinxcode{\sphinxupquote{1}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{n = 2}}: the final binary string is \sphinxcode{\sphinxupquote{"110"}}, its decimal value is \sphinxcode{\sphinxupquote{6}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{n = 3}}: the final binary string is \sphinxcode{\sphinxupquote{"11011"}}, its decimal value is \sphinxcode{\sphinxupquote{27}}.

\end{itemize}

\sphinxAtStartPar
Look at \sphinxcode{\sphinxupquote{n = 3}}, you can see the relationship between the decimal value of \sphinxcode{\sphinxupquote{"11011"}} and the one of \sphinxcode{\sphinxupquote{"110"}} (of \sphinxcode{\sphinxupquote{n = 2}}) is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
27 = 6 * 2\PYGZca{}2 + 3
Dec(\PYGZdq{}11011\PYGZdq{}) = Dec(\PYGZdq{}110\PYGZdq{}) * 2\PYGZca{}num\PYGZus{}bits(\PYGZdq{}11\PYGZdq{}) + Dec(\PYGZdq{}11\PYGZdq{})
Result(3) = Result(2) * 2\PYGZca{}num\PYGZus{}bits(3) + 3.
\end{sphinxVerbatim}

\sphinxAtStartPar
The same equation for \sphinxcode{\sphinxupquote{n = 2}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
6 = 1 * 2\PYGZca{}2 + 2
Dec(\PYGZdq{}110\PYGZdq{}) = Dec(\PYGZdq{}1\PYGZdq{}) * 2\PYGZca{}num\PYGZus{}bits(\PYGZdq{}10\PYGZdq{}) + Dec(\PYGZdq{}10\PYGZdq{})
Result(2) = Result(1) * 2\PYGZca{}num\PYGZus{}bits(2) + 2.
\end{sphinxVerbatim}

\sphinxAtStartPar
In general, the recursive relationship between \sphinxcode{\sphinxupquote{n}} and \sphinxcode{\sphinxupquote{n \sphinxhyphen{} 1}} is:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Result(n) = Result(n \PYGZhy{} 1) * 2\PYGZca{}num\PYGZus{}bits(n) + n.
\end{sphinxVerbatim}


\subsubsection{Code}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{concatenatedBinary}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{unsigned}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{k+kt}{long}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{num\PYGZus{}bits}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{log2}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{        }
\PYG{+w}{        }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{(}\PYG{p}{(}\PYG{n}{result}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{num\PYGZus{}bits}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{i}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{1000000007}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{result}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{concatenatedBinary}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{concatenatedBinary}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{concatenatedBinary}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
1
27
505379714
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*logn)}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Key Takeaway}
\label{\detokenize{Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers:key-takeaway}}
\sphinxAtStartPar
This solution efficiently calculates the concatenated binary representation of integers from \sphinxcode{\sphinxupquote{1}} to \sphinxcode{\sphinxupquote{n}}, using bitwise operations and modular arithmetic. Note that \sphinxcode{\sphinxupquote{a \textless{}\textless{} t}} is equivalent to \sphinxcode{\sphinxupquote{ a * 2\textasciicircum{}t}}.


\bigskip\hrule\bigskip


\sphinxstepscope


\section{Perfect Squares}
\label{\detokenize{Mathematics/279_Perfect_Squares:perfect-squares}}\label{\detokenize{Mathematics/279_Perfect_Squares::doc}}

\subsection{Problem statement}
\label{\detokenize{Mathematics/279_Perfect_Squares:problem-statement}}
\sphinxAtStartPar
%
\begin{footnote}[1]\sphinxAtStartFootnote
https://leetcode.com/problems/perfect\sphinxhyphen{}squares/
%
\end{footnote}Given an integer \sphinxcode{\sphinxupquote{n}}, return the least number of perfect square numbers that sum to \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
A \sphinxstylestrong{perfect square} is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, \sphinxcode{\sphinxupquote{1}}, \sphinxcode{\sphinxupquote{4}}, \sphinxcode{\sphinxupquote{9}}, and \sphinxcode{\sphinxupquote{16}} are perfect squares while \sphinxcode{\sphinxupquote{3}} and \sphinxcode{\sphinxupquote{11}} are not.


\subsubsection{Example 1}
\label{\detokenize{Mathematics/279_Perfect_Squares:example-1}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 9
Output: 1
Explanation: 9 is already a perfect square.
\end{sphinxVerbatim}


\subsubsection{Example 2}
\label{\detokenize{Mathematics/279_Perfect_Squares:example-2}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 13
Output: 2
Explanation: 13 = 4 + 9.
\end{sphinxVerbatim}


\subsubsection{Example 3}
\label{\detokenize{Mathematics/279_Perfect_Squares:example-3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 7
Output: 4
Explanation: 7 = 4 + 1 + 1 + 1.
\end{sphinxVerbatim}


\subsubsection{Example 4}
\label{\detokenize{Mathematics/279_Perfect_Squares:example-4}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Input: n = 12
Output: 3
Explanation: 12 = 4 + 4 + 4.
\end{sphinxVerbatim}


\subsubsection{Constraints}
\label{\detokenize{Mathematics/279_Perfect_Squares:constraints}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{1 \textless{}= n \textless{}= 10\textasciicircum{}4}}.

\end{itemize}


\subsection{Solution 1: Dynamic Programming}
\label{\detokenize{Mathematics/279_Perfect_Squares:solution-1-dynamic-programming}}
\sphinxAtStartPar
Let us call the function to be computed \sphinxcode{\sphinxupquote{numSquares(n)}}, which calculates the least number of perfect squares that sum to \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
Here are the findings.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{n}} is already a perfect square then \sphinxcode{\sphinxupquote{numSquares(n) = 1}}.

\item {} 
\sphinxAtStartPar
Otherwise, it could be written as \sphinxcode{\sphinxupquote{n = 1 + (n\sphinxhyphen{}1)}}, or \sphinxcode{\sphinxupquote{n = 4 + (n\sphinxhyphen{}4)}}, or \sphinxcode{\sphinxupquote{n = 9 + (n\sphinxhyphen{}9)}}, etc. which means \sphinxcode{\sphinxupquote{n}} is a sum of a perfect square (\sphinxcode{\sphinxupquote{1, 4}} or \sphinxcode{\sphinxupquote{9}}, etc.) and another number \sphinxcode{\sphinxupquote{m \textless{} n}}. That leads to the problems \sphinxcode{\sphinxupquote{numSquares(m)}} of smaller values \sphinxcode{\sphinxupquote{m}}.

\item {} 
\sphinxAtStartPar
If you have gotten the results of the smaller problems \sphinxcode{\sphinxupquote{numSquares(n\sphinxhyphen{}1)}}, \sphinxcode{\sphinxupquote{numSquares(n\sphinxhyphen{}4)}}, \sphinxcode{\sphinxupquote{numSquares(n\sphinxhyphen{}9)}}, etc. then \sphinxcode{\sphinxupquote{numSquares(n) = 1 + the minimum of those results}}.

\end{enumerate}


\subsubsection{Example 4}
\label{\detokenize{Mathematics/279_Perfect_Squares:id2}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n = 12}} is not a perfect square. It can be written as \sphinxcode{\sphinxupquote{n = 1 + 11 = 4 + 8 = 9 + 3}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{m = 11}}, it is not a perfect square and can be written as \sphinxcode{\sphinxupquote{m = 1 + 10 = 4 + 7 = 9 + 2}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{m = 8}}, it is not a perfect square and can be written as \sphinxcode{\sphinxupquote{m = 1 + 7 = 4 + 4}} (matched). You get \sphinxcode{\sphinxupquote{numSquares(8) = 2}}.

\item {} 
\sphinxAtStartPar
For \sphinxcode{\sphinxupquote{m = 3}}, it is not a perfect square and can be written as \sphinxcode{\sphinxupquote{m = 1 + 2}}.

\end{itemize}

\sphinxAtStartPar
You can continue to compute \sphinxcode{\sphinxupquote{numSquares(m)}} for other values \sphinxcode{\sphinxupquote{m}} in this recursive process. But you can see the case of \sphinxcode{\sphinxupquote{m = 8}} was already the best solution. And \sphinxcode{\sphinxupquote{numSquares(12) = 1 + numSquares(8) = 1 + 2 = 3}}, which is the case of \sphinxcode{\sphinxupquote{n = 12 = 4 + 4 + 4}}.

\sphinxAtStartPar
To improve runtime, you can apply \sphinxstyleemphasis{dynamic programming} to cache the \sphinxcode{\sphinxupquote{numSquares(n)}} that you have computed.


\subsubsection{Code}
\label{\detokenize{Mathematics/279_Perfect_Squares:code}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}unordered\PYGZus{}map\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{c+c1}{//! @return         the least number of perfect squares that sum to n}
\PYG{c+c1}{//! @param[out] ns  a map stores all intermediate results}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{nsq}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{o}{\PYGZam{}}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{auto}\PYG{+w}{ }\PYG{n}{it}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{.}\PYG{n}{find}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{it}\PYG{+w}{ }\PYG{o}{!}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{it}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}}\PYG{n}{second}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// n is already a perfect square}
\PYG{+w}{        }\PYG{n}{ns}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// if n is written as 1 + 1 + .. + 1,}
\PYG{+w}{    }\PYG{c+c1}{// maximum of result is n}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{c+c1}{// finding the minimum nsq(n \PYGZhy{} i*i) across all i \PYGZlt{}= sqrt(n)}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sq}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// }
\PYG{+w}{        }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{min}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{nsq}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{*}\PYG{n}{i}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// write n as imin\PYGZca{}2 + (n \PYGZhy{} imin\PYGZca{}2)}
\PYG{+w}{    }\PYG{n}{ns}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{result}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{numSquares}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{unordered\PYGZus{}map}\PYG{o}{\PYGZlt{}}\PYG{k+kt}{int}\PYG{p}{,}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{nsq}\PYG{p}{(}\PYG{n}{n}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ns}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
The key idea of this algorithm is to build the solution incrementally, starting from the smallest perfect squares, and use memoization to store and retrieve intermediate results. By doing this, it efficiently finds the minimum number of perfect squares required to sum up to \sphinxcode{\sphinxupquote{n}}.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/279_Perfect_Squares:complexity}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(n*sqrt(n)) = O(n\textasciicircum{}(3/2))}} due to the nested loops and recursive calls.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(n)}}.

\end{itemize}


\subsection{Solution 2: Number Theory}
\label{\detokenize{Mathematics/279_Perfect_Squares:solution-2-number-theory}}
\sphinxAtStartPar
The dynamic programming solution above is good enough. But for those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.

\sphinxAtStartPar
It is called \sphinxhref{https://en.wikipedia.org/wiki/Lagrange\%27s\_four-square\_theorem}{Lagrange’s Four\sphinxhyphen{}Square Theorem}, which states
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{every natural number can be represented as the sum of four integer squares.}
\end{quote}

\sphinxAtStartPar
It was proven by Lagrange in 1770.


\subsubsection{Example 4}
\label{\detokenize{Mathematics/279_Perfect_Squares:id3}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{n = 12 = 4 + 4 + 4 + 0}} or \sphinxcode{\sphinxupquote{12 = 1 + 1 + 1 + 9}}.

\sphinxAtStartPar
Applying to our problem, \sphinxstylestrong{\sphinxcode{\sphinxupquote{numSquares(n)}} can only be 1, 2, 3, or 4. Not more.}

\sphinxAtStartPar
It turns into the problem of
\begin{quote}

\sphinxAtStartPar
\sphinxstyleemphasis{identifying when \sphinxcode{\sphinxupquote{numSquares(n)}} returns 1, 2, 3, or 4.}
\end{quote}

\sphinxAtStartPar
Here are the cases.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{n}} is a perfect square, \sphinxcode{\sphinxupquote{numSquares(n) = 1}}.

\item {} 
\sphinxAtStartPar
There is another theorem, \sphinxhref{https://en.wikipedia.org/wiki/Legendre\%27s\_three-square\_theorem}{Legendre’s Three\sphinxhyphen{}Square Theorem}, which states that
\sphinxcode{\sphinxupquote{numSquares(n)}} cannot be 1, 2, or 3 if \sphinxcode{\sphinxupquote{n}} can be expressed as

\end{enumerate}
\begin{equation*}
\begin{split}
n = 4^a(8\cdot b + 7),
\end{split}
\end{equation*}
\sphinxAtStartPar
where \(a\), \(b\) are nonnegative integers.

\sphinxAtStartPar
In other words, \sphinxcode{\sphinxupquote{numSquares(n) = 4}} if \sphinxcode{\sphinxupquote{n}} is of this form.


\subsubsection{Example 3}
\label{\detokenize{Mathematics/279_Perfect_Squares:id4}}
\sphinxAtStartPar
\(n = 7 = 4^0(8\cdot 0 + 7)\). It can only be written as \sphinxcode{\sphinxupquote{7 = 4 + 1 + 1 + 1}}.


\subsubsection{Code}
\label{\detokenize{Mathematics/279_Perfect_Squares:id5}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isSquare}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{numSquares}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isSquare}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// Legendre\PYGZsq{}s three\PYGZhy{}square theorem}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{m}\PYG{+w}{ }\PYG{o}{/}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{m}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sq}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isSquare}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}

\sphinxAtStartPar
This solution finds the minimum number of perfect squares required to sum up to the given integer \sphinxcode{\sphinxupquote{n}} by first applying mathematical properties and Legendre’s three\sphinxhyphen{}square theorem to simplify the problem and then using a loop to find possible combinations of two perfect squares.


\subsubsection{Complexity}
\label{\detokenize{Mathematics/279_Perfect_Squares:id6}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(sqrt(n)) = O(n\textasciicircum{}(1/2))}}, and it does not require dynamic programming or memoization.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Solution 3: Further performance improvement}
\label{\detokenize{Mathematics/279_Perfect_Squares:solution-3-further-performance-improvement}}
\sphinxAtStartPar
Lagrange’s Four\sphinxhyphen{}Square Theorem and Legendre’s Three\sphinxhyphen{}Square Theorem are so powerful to solve this problem. But you can still do a little more algebra to improve further the runtime of the implementation above.

\sphinxAtStartPar
Instead of looping over \sphinxcode{\sphinxupquote{sqrt(n)}} in the final \sphinxcode{\sphinxupquote{for}} loop, we will prove that this loop over \sphinxcode{\sphinxupquote{sqrt(m)}} is enough. That will improve runtime a lot since \sphinxcode{\sphinxupquote{m}} is much less than \sphinxcode{\sphinxupquote{n}}.

\sphinxAtStartPar
Let \sphinxcode{\sphinxupquote{m}} be the reduced value of \sphinxcode{\sphinxupquote{n}} after the Legendre’s \sphinxcode{\sphinxupquote{while}} loop. It satisfies
\begin{equation*}
\begin{split}
n = 4^a \cdot m.
\end{split}
\end{equation*}
\sphinxAtStartPar
We will prove that \sphinxcode{\sphinxupquote{numSquares(n) = numSquares(m)}}.

\sphinxAtStartPar
In fact, if \sphinxcode{\sphinxupquote{m}} is written as \(m = x^2 + y^2 + z^2\), where \(x\), \(y\), \(z\) are nonnegative integers. Then
\begin{equation*}
\begin{split}
n = 4^a \cdot m = (2^a)^2 \cdot m = (2^a \cdot x)^2 + (2^a \cdot y)^2 + (2^a \cdot z)^2.
\end{split}
\end{equation*}
\sphinxAtStartPar
In other words, \sphinxcode{\sphinxupquote{numSquares(n) = numSquares(m)}}.

\sphinxAtStartPar
Now you can change directly the value \sphinxcode{\sphinxupquote{n}} during the Legendre’s \sphinxcode{\sphinxupquote{while}} loop without affecting the final result.


\subsubsection{Code}
\label{\detokenize{Mathematics/279_Perfect_Squares:id7}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}cmath\PYGZgt{}}
\PYG{k}{using}\PYG{+w}{ }\PYG{k}{namespace}\PYG{+w}{ }\PYG{n+nn}{std}\PYG{p}{;}
\PYG{k+kt}{bool}\PYG{+w}{ }\PYG{n+nf}{isSquare}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{numSquares}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isSquare}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{c+c1}{// Legendre\PYGZsq{}s three\PYGZhy{}square theorem}
\PYG{+w}{    }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{/}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZpc{}}\PYG{+w}{ }\PYG{l+m+mi}{8}\PYG{+w}{ }\PYG{o}{=}\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{7}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{4}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{const}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{sq}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sqrt}\PYG{p}{(}\PYG{n}{n}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{=}\PYG{+w}{ }\PYG{n}{sq}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{isSquare}\PYG{p}{(}\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{*}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{12}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{cout}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{numSquares}\PYG{p}{(}\PYG{l+m+mi}{13}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Output:
3
2
\end{sphinxVerbatim}


\subsubsection{Complexity}
\label{\detokenize{Mathematics/279_Perfect_Squares:id8}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Runtime: \sphinxcode{\sphinxupquote{O(sqrt(n)) = O(n\textasciicircum{}(1/2))}}.

\item {} 
\sphinxAtStartPar
Extra space: \sphinxcode{\sphinxupquote{O(1)}}.

\end{itemize}


\subsection{Conclusion}
\label{\detokenize{Mathematics/279_Perfect_Squares:conclusion}}\begin{itemize}
\item {} 
\sphinxAtStartPar
The title of this coding challenge (\sphinxstyleemphasis{Perfect squares}) gives you a hint it is more about mathematics than coding technique.

\item {} 
\sphinxAtStartPar
It is amazing from Lagrange’s Four\sphinxhyphen{}Square Theorem there are only four possibilities for the answer to the problem. Not many people knowing it.

\item {} 
\sphinxAtStartPar
You can get an optimal solution to a coding problem when you know something about the mathematics behind it.

\end{itemize}

\sphinxAtStartPar
Hope you learn something interesting from this code challenge.

\sphinxAtStartPar
\sphinxstyleemphasis{Have fun with coding and mathematics!}


\subsection{Exercise}
\label{\detokenize{Mathematics/279_Perfect_Squares:exercise}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://leetcode.com/problems/ways-to-express-an-integer-as-sum-of-powers/}{Ways to Express an Integer as Sum of Powers}

\end{itemize}


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Conclusion}
\label{\detokenize{conclude:conclusion}}\label{\detokenize{conclude::doc}}
\sphinxAtStartPar
Congratulations! You have made it to the end of this book! I hope you have enjoyed and learned from the \sphinxstylestrong{coding challenges} and \sphinxstylestrong{solutions} presented in this book.

\sphinxAtStartPar
Through these challenges, you have not only improved your \sphinxstylestrong{coding skills} but also your \sphinxstylestrong{problem\sphinxhyphen{}solving abilities}, \sphinxstylestrong{logical thinking}, and \sphinxstylestrong{creativity}. You have been exposed to different \sphinxstylestrong{programming techniques} and \sphinxstylestrong{algorithms}, which have broadened your understanding of the programming world. These skills and knowledge will undoubtedly benefit you in your future coding endeavors.

\sphinxAtStartPar
Remember, coding challenges are not only a way to improve your coding skills but also a fun and engaging way to stay up\sphinxhyphen{}to\sphinxhyphen{}date with the latest technology trends. They can also help you to prepare for technical interviews, which are a crucial part of landing a programming job.

\sphinxAtStartPar
In conclusion, I encourage you to continue exploring the world of coding challenges, as there is always something new to learn and discover. \sphinxstylestrong{Keep practicing, keep learning, and keep challenging yourself}. With hard work and dedication, you can become an expert in coding and a valuable asset to any team.

\sphinxstepscope

\appendix
\chapter{Coding challenge best practices}
\label{\detokenize{best_practices:coding-challenge-best-practices}}\label{\detokenize{best_practices::doc}}
\sphinxAtStartPar
Here are some best practices to keep in mind when working on coding challenges:


\section{Read the problem carefully}
\label{\detokenize{best_practices:read-the-problem-carefully}}
\sphinxAtStartPar
Before jumping into writing code, take the time to read and understand the problem statement. Make sure you understand the input and output requirements, any constraints or special cases, and the desired algorithmic approach.


\section{Plan and pseudocode}
\label{\detokenize{best_practices:plan-and-pseudocode}}
\sphinxAtStartPar
Once you understand the problem, take some time to plan and sketch out a high\sphinxhyphen{}level algorithmic approach. Write pseudocode to help break down the problem into smaller steps and ensure that your solution covers all cases.


\section{Test your code}
\label{\detokenize{best_practices:test-your-code}}
\sphinxAtStartPar
After writing your code, test it thoroughly to make sure it produces the correct output for a range of test cases. Consider edge cases, large inputs, and unusual scenarios to make sure your solution is robust.


\section{Optimize for time and space complexity}
\label{\detokenize{best_practices:optimize-for-time-and-space-complexity}}
\sphinxAtStartPar
When possible, optimize your code for time and space complexity. Consider the Big O notation of your solution and try to reduce it if possible. This can help your code to run faster and more efficiently.


\section{Write clean, readable code}
\label{\detokenize{best_practices:write-clean-readable-code}}
\sphinxAtStartPar
Make sure your code is easy to read and understand. Use meaningful variable names, indent properly, and comment your code where necessary. This will make it easier for other programmers to read and understand your code, and will help prevent errors and bugs.


\section{Submit your code and learn from feedback}
\label{\detokenize{best_practices:submit-your-code-and-learn-from-feedback}}
\sphinxAtStartPar
Once you have a working solution, submit it for review and feedback. Pay attention to any feedback you receive and use it to improve your coding skills and approach for future challenges.


\section{Keep practicing}
\label{\detokenize{best_practices:keep-practicing}}
\sphinxAtStartPar
The more coding challenges you complete, the better you will become. Keep practicing and challenging yourself to learn new techniques and approaches to problem\sphinxhyphen{}solving.

\sphinxAtStartPar
In conclusion, coding challenges are a great way to improve your coding skills and prepare for technical interviews. By following these best practices, you can ensure that you approach coding challenges in a structured and efficient manner, producing clean and readable code that is optimized for time and space complexity.

\sphinxstepscope

\pagestyle{plain}
\backmatter

\chapter*{Thank you!}
\label{\detokenize{thanks:thank-you}}\label{\detokenize{thanks::doc}}
\sphinxAtStartPar
Thank you for taking the time to read this book.

\sphinxAtStartPar
I would love to hear your thought about this book. Visit my blog leetsolve.com and find how to do a review on this book.

\sphinxAtStartPar
I hope it has been a valuable experience and that you are excited to continue your coding journey. Best of luck with your coding challenges, and remember to have fun along the way!

\sphinxstepscope


\chapter*{About the author}
\label{\detokenize{about:about-the-author}}\label{\detokenize{about::doc}}
\sphinxAtStartPar
Nhut Nguyen is a seasoned software engineer and career coach with nearly a decade of experience in the tech industry.

\sphinxAtStartPar
He was born and grew up in Ho Chi Minh City, Vietnam. In 2012, he moved to Denmark for a Ph.D. in mathematics at the Technical University of Denmark. After his study, Nhut Nguyen switched to the industry in 2016 and has worked at various tech companies in Copenhagen, Denmark.

\sphinxAtStartPar
Nhut’s passion for helping aspiring software engineers succeed led him to write several articles and books where he shares his expertise and practical strategies to help readers navigate their dream job and work efficiently.

\sphinxAtStartPar
With a strong background in mathematics and computer science and a deep understanding of the industry, Nhut is dedicated to empowering individuals to unlock their full potential, land their dream jobs and live happy lives.

\sphinxAtStartPar
Learn more at \sphinxurl{https://nhutnguyen.com}.



\renewcommand{\indexname}{Index}
\printindex
\end{document}