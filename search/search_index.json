{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LeetSolve - Leetcode Solutions in C++","text":"<p>Hello and Welcome to LeetSolve. We share C++ solutions to selected LeetCode. </p> <p>This is a programming blog for coding learners. We focus on readable code, essential algorithms, basic data structures, common programming techniques and elementary C++ programming language.</p> <p>Get our Book 10 Classic Coding Challenges for FREE.</p> <p>Hope you enjoy our blog.</p>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/","title":"3 Longest Substring Without Repeating Characters","text":""},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#3-longest-substring-without-repeating-characters","title":"3. Longest Substring Without Repeating Characters","text":"<p>Tag: string</p>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#problem-statement","title":"Problem statement","text":"<p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with a length of 3.\n</code></pre>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n</code></pre>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with a length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n</code></pre>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= s.length &lt;= 5 * 10^4</code>.</li> <li><code>s</code> consists of English letters, digits, symbols and spaces.</li> </ul>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#solution-store-the-position-of-the-visited-characters","title":"Solution: Store the position of the visited characters","text":"<p>Whenever you meet a visited character <code>s[i] == s[j]</code> for some <code>0 &lt;= i &lt; j &lt; s.length</code>, the substring <code>\"s[i]...s[j - 1]\"</code> might be valid, i.e. it consist of only nonrepeating characters.</p> <p>But in case you meet another visited character <code>s[x] == s[y]</code> where <code>x &lt; i &lt; j &lt; y</code>, the substring <code>\"s[x]...s[y - 1]\"</code> is not valid because it consists of repeated character <code>s[i] == s[j]</code>. </p> <p>That shows the substring <code>\"s[i]...s[j - 1]\"</code> is not always a valid one. You might need to find the right starting position <code>start &gt;= i</code> for the valid substring <code>\"s[start]...s[j - 1]\"</code>.</p>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#example-4","title":"Example 4","text":"<p>For the string <code>s = \"babba\"</code>:</p> <ul> <li>When you visit the second letter <code>'b'</code>, the substring <code>\"ba\"</code> is a valid one. </li> <li>When you visit the third letter <code>'b'</code>, the substring of interest should be started by the second letter <code>'b'</code>. It gives you the substring <code>\"b\"</code>.</li> <li>When you visit the second letter <code>'a'</code>, the substring <code>\"abb\"</code> is not a valid one since <code>'b'</code> is repeated. To ensure no repetition, the starting position for this substring should be the latter <code>'b'</code>, which leads to the valid substring <code>\"b\"</code>.</li> <li>The final longest valid substring is <code>\"ba\"</code> with length 2.</li> </ul> <p>Example 4 shows the starting position <code>start</code> for the substring of interest <code>\"s[i]...s[j - 1]\"</code> should be:</p> <pre><code>this_start = max(previous_start, i).\n</code></pre>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint lengthOfLongestSubstring(string s) {\n    unordered_map&lt;char, int&gt; position;\n    int maxLen = 0;\n    int start = -1;\n    for (int i = 0; i &lt; s.length(); i++) {\n        if (position.find(s[i]) != position.end()) {\n            start = max(start, position[s[i]]);\n        }\n        position[s[i]] = i;\n        maxLen = max(maxLen, i - start);\n    }\n    return maxLen;\n}\nint main() {\n    cout &lt;&lt; lengthOfLongestSubstring(\"abcabcbb\") &lt;&lt; endl;\n    cout &lt;&lt; lengthOfLongestSubstring(\"bbbbb\") &lt;&lt; endl;\n    cout &lt;&lt; lengthOfLongestSubstring(\"pwwkew\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n1\n3\n</code></pre>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"Strings/3_Longest_Substring_Without_Repeating_Characters/#references","title":"References","text":"<ul> <li>https://leetcode.com/problems/longest-substring-without-repeating-characters/</li> <li>https://www.leetsolve.com/3-longest-substring-without-repeating-characters</li> </ul>"},{"location":"source/best_practices/","title":"Coding challenge best practices","text":"<p>Here are some best practices to keep in mind when working on coding challenges:</p>"},{"location":"source/best_practices/#read-the-problem-carefully","title":"Read the problem carefully","text":"<p>Before jumping into writing code, take the time to read and understand the problem statement. Make sure you understand the input and output requirements, any constraints or special cases, and the desired algorithmic approach.</p>"},{"location":"source/best_practices/#plan-and-pseudocode","title":"Plan and pseudocode","text":"<p>Once you understand the problem, take some time to plan and sketch out a high-level algorithmic approach. Write pseudocode to help break down the problem into smaller steps and ensure that your solution covers all cases.</p>"},{"location":"source/best_practices/#test-your-code","title":"Test your code","text":"<p>After writing your code, test it thoroughly to make sure it produces the correct output for a range of test cases. Consider edge cases, large inputs, and unusual scenarios to make sure your solution is robust.</p>"},{"location":"source/best_practices/#optimize-for-time-and-space-complexity","title":"Optimize for time and space complexity","text":"<p>When possible, optimize your code for time and space complexity. Consider the Big O notation of your solution and try to reduce it if possible. This can help your code to run faster and more efficiently.</p>"},{"location":"source/best_practices/#write-clean-readable-code","title":"Write clean, readable code","text":"<p>Make sure your code is easy to read and understand. Use meaningful variable names, indent properly, and comment your code where necessary. This will make it easier for other programmers to read and understand your code, and will help prevent errors and bugs.</p>"},{"location":"source/best_practices/#submit-your-code-and-learn-from-feedback","title":"Submit your code and learn from feedback","text":"<p>Once you have a working solution, submit it for review and feedback. Pay attention to any feedback you receive and use it to improve your coding skills and approach for future challenges.</p>"},{"location":"source/best_practices/#keep-practicing","title":"Keep practicing","text":"<p>The more coding challenges you complete, the better you will become. Keep practicing and challenging yourself to learn new techniques and approaches to problem-solving.</p> <p>In conclusion, coding challenges are a great way to improve your coding skills and prepare for technical interviews. By following these best practices, you can ensure that you approach coding challenges in a structured and efficient manner, producing clean and readable code that is optimized for time and space complexity.</p>"},{"location":"source/conclude/","title":"Conclusion","text":"<p>Congratulations! You have made it to the end of this book! I hope you have enjoyed and learned from the coding challenges and solutions presented in this book.</p> <p>Through these challenges, you have not only improved your coding skills but also your problem-solving abilities, logical thinking, and creativity. You have been exposed to different programming techniques and algorithms, which have broadened your understanding of the programming world. These skills and knowledge will undoubtedly benefit you in your future coding endeavors.</p> <p>Remember, coding challenges are not only a way to improve your coding skills but also a fun and engaging way to stay up-to-date with the latest technology trends. They can also help you to prepare for technical interviews, which are a crucial part of landing a programming job.</p> <p>In conclusion, I encourage you to continue exploring the world of coding challenges, as there is always something new to learn and discover. Keep practicing, keep learning, and keep challenging yourself. With hard work and dedication, you can become an expert in coding and a valuable asset to any team.</p>"},{"location":"source/intro/","title":"Introduction","text":""},{"location":"source/intro/#why-indexleetcode","title":"Why {index}<code>LeetCode</code>?","text":"<p>Coding challenges are a great way to practice problem-solving, algorithm development, and logical thinking. They showcase your creativity and innovation while improving your coding techniques. This book offers diverse coding challenges to help you develop your skills.</p> <p>{index}<code>Coding challenges</code> could be programming puzzles or mathematical problems that require coding solutions. Each challenge requires different coding skills and is designed to challenge and develop a particular set of skills. </p> <p>The coding challenges in this book are picked from LeetCode. It is a popular online platform for programmers and software engineers that provides many coding challenges and problems. The website was launched in 2015 and has since grown to become one of the go-to resources for coding practice, technical interview preparation, and skills enhancement.</p> <p>LeetCode offers diverse coding challenges, ranging from easy to hard, covering a wide range of topics such as algorithms, data structures, databases, system design, and more. The problems are created by industry experts and are designed to simulate real-world scenarios, allowing you to gain practical experience in problem-solving.</p> <p>One feature that makes LeetCode stand out is its extensive discussion forum, where you can interact, share your solutions, and learn from one another. This fosters community and collaboration, as you can receive feedback on their solutions and ask for clarification on difficult problems.</p> <p>LeetCode also provides premium services like mock interviews with real-world companies, career coaching, and job postings. These premium services are designed to help you prepare for technical interviews, sharpen your skills, and advance your careers.</p> <p>LeetCode has become a popular resource for technical interview preparation, as many companies use similar problems to screen and evaluate potential candidates. The platform has helped many users to secure job offers from top companies in the technology industry, including Google, Microsoft, and Facebook.</p> <p>In summary, LeetCode is a valuable resource for programmers and software engineers looking to improve their coding skills, prepare for technical interviews, and advance their careers. Its extensive collection of coding challenges, community discussion forums, and premium services make it an all-in-one platform for coding practice and skills enhancement.</p>"},{"location":"source/intro/#a-brief-about-indexalgorithm-complexity","title":"A brief about {index}<code>algorithm complexity</code>","text":"<p>Algorithm complexity, also known as runtime complexity, is a measure of how the running time of an algorithm increases as the input size grows. It is an essential concept in computer science, as it helps programmers evaluate and optimize their algorithms' performance.</p> <p>The complexity of an algorithm is usually measured in terms of its Big O notation, which describes the upper bound of the algorithm's running time as a function of the input size. For example, an algorithm with a time complexity of <code>O(n)</code> will have a running time proportional to the input size. In contrast, an algorithm with a time complexity of <code>O(n^2)</code> will have a running time proportional to the square of the input size.</p> <p>Algorithm complexity is important because it helps programmers determine their algorithms' efficiency and scalability. In general, algorithms with lower complexity are more efficient, as they require less time and resources to process larger inputs. By analyzing the time complexity of an algorithm, programmers can identify potential performance bottlenecks and optimize their code accordingly.</p> <p>In addition to time complexity, algorithms may also have space complexity, which measures the memory required to execute the algorithm. Space complexity is also measured in Big O notation and is important for optimizing the memory usage of an algorithm.</p> <p></p> <p>While it is important to optimize the performance of algorithms, it is also important to balance this with readability and maintainability. A highly optimized algorithm may be difficult to understand and maintain, which can lead to problems in the long run. Therefore, it is important to balance performance and readability when designing and implementing algorithms.</p> <p>In summary, algorithm complexity is an essential concept in computer science that helps programmers evaluate and optimize their algorithms' performance. By analyzing an algorithm's time and space complexity, programmers can identify potential performance bottlenecks and optimize their code to improve efficiency and scalability.</p>"},{"location":"source/intro/#why-indexreadable-code","title":"Why {index}<code>readable code</code>?","text":"<p>Readable code is code that is easy to understand, maintain, and modify. It is an essential aspect of programming, as it ensures that code is accessible to other programmers and helps to prevent errors and bugs. Readable code is important for several reasons.</p> <p>Firstly, readable code makes it easier for other programmers to understand and modify it. This is particularly important in collaborative projects where multiple programmers work on the same codebase. If the code is not readable, it can lead to confusion and errors, making it difficult for others to work on it.</p> <p>Secondly, readable code helps to prevent bugs and errors. When code is easy to understand, it is easier to identify and fix potential issues before they become problems. This is important for ensuring the code is reliable and performs as expected.</p> <p>Thirdly, readable code can improve the overall quality of the codebase. When code is easy to understand, it is easier to identify areas for improvement and make changes to improve the code. This can help improve the codebase's efficiency and maintainability, leading to a better overall product.</p> <p>Finally, readable code can save time and money. When code is easy to understand, it is easier to maintain and modify. This can help reduce the time and resources required to make changes to the codebase, leading to cost savings in the long run.</p> <p>In conclusion, readable code is an essential aspect of programming that ensures that code is accessible, error-free, and efficient. By focusing on readability when designing and implementing code, programmers can improve the quality and reliability of their code, leading to a better overall product.</p> <p>I hope this book is an enjoyable and educational experience that will challenge and inspire you. Whether you want to enhance your skills, prepare for a technical interview, or just have fun, this book has something for you. So, get ready to put your coding skills to the test and embark on a challenging and rewarding journey through the world of coding challenges!</p>"},{"location":"source/preface/","title":"Preface","text":"<p>Welcome to The Problem Solver's Guide To Coding, a comprehensive journey to master problem-solving, data structures, algorithms, and programming techniques using C++. This book results from my experiences, challenges, failures and successes in my programming career. </p> <p>One of the most critical phases in software developer hiring process is the coding interview, a rigorous process where candidates are tested on their problem-solving skills and technical proficiency. Companies like FAANG (Facebook, Amazon, Apple, Netflix, and Google) often subject candidates to three to four rounds of interviews, making preparation essential for success.</p> <p>My journey with coding interviews began during a pivotal career change in the summer of 2021. During this transitional period, I discovered LeetCode, a platform that soon became my daily companion in honing my programming skills. What started as a means to practice new languages (Golang and C#) quickly evolved into a deep exploration of my strongest language, C++.</p> <p>One day, I decided to write an article for each challenge and share it on my blog leetsolve.com. Over time, my daily practice transformed into more than 70 challenges, each accompanied by a detailed article encompassing problem statements, various approaches, C++ code implementations, thorough explanations, and complexity analyses.</p> <p>As I delved into these coding challenges, I realized their potential to empower aspiring programmers, students, and junior developers to excel in interviews and master problem-solving and algorithmic thinking.</p>"},{"location":"source/preface/#the-books-overview","title":"The book's overview","text":"<p>The Problem Solver's Guide to Coding presents challenges covering fundamental data structures, algorithms, and mathematical problems. Challenges are grouped in topics, starting with the simplest data structure - Array. Most are arranged in order of increasing difficulty, but you can pick any chapter or any challenge to start since I write each independently to the other. </p> <p>Challenges in this book are curated from LeetCode.com, focusing on those that are not difficult but provide valuable learning experiences. You might encounter some simple challenges I go directly to the code without saying much about the idea (intuition) since their solution is straightforward. </p> <p>I also keep the problems' original constraints (inputs' size, limits, etc.) as the code in this book is the ones I submitted on Leetcode.com. It explains why I usually focus on the core algorithm and do not consider/handle corner cases or invalid inputs.</p> <p>The problems in each chapter comes with a detailed solution, explaining the logic behind the solution and how to implement it in C++, my strongest programming language. </p> <p>At the end of some problems, I also provide similar problems on leetcode.com for you to solve on your own, as practicing is essential for reinforcing understanding and mastery of the concepts presented in the book. By engaging in problem-solving exercises, you can apply what you have learned, develop your problem-solving skills, and gain confidence in your ability to tackle real-world challenges.</p> <p>In this book, I focus on readable code rather than optimal one, as most of you are at the beginner level. Some of my solutions might need to be in better runtime or memory. But I keep my code in my style or coding convention, where readability is vital.</p> <p>Moreover, my weekly sharing of articles with various developer communities has refined the content and established a connection with a diverse group of programming enthusiasts.</p>"},{"location":"source/preface/#who-is-this-book-for","title":"Who is this book for?","text":"<p>This book is tailored to benefit a wide audience, from students beginning their programming journey to experienced developers looking to enhance their skills. Regardless of your experience level, whether you're preparing for coding interviews or simply seeking to improve your problem-solving abilities, this book is designed to meet your needs.</p> <p>As a minimum requirement, you are supposed to have some basic background in C++ programming language, data structures and algorithms like a second-year undergraduate in Computer Science.</p> <p>What sets this book apart is its focus on practicality. The challenges presented here are not just exercises; they mirror real coding interviews from top companies like FAANG. </p> <p>As you work through the coding challenges in this book, you'll learn new skills, improve your problem-solving abilities, and develop your confidence as a programmer. </p>"},{"location":"source/preface/#acknowledgement","title":"Acknowledgement","text":"<p>I am deeply grateful to my invaluable previewers, especially Alexander Volkodav, Phung Phu Tai, Le Nhat Tung, Tran Anh Tuan A, Bui Nguyen Cong Duy, Cao Minh Thinh, Nguyen Trung Tuan, Nguyen Tuan Hung, Nguyen Hoang Nhat Minh, Nhan Nguyen, Phan Dinh Thai and Nguyen Quang Trung, whose dedication and insights have shaped this book into its final form. Your contributions and unwavering support are truly appreciated.</p> <p>I would like to express my heartfelt gratitude to Ninh Pham, Hoang Thanh Lam, Dinh Thai Minh Tam and Tran Anh Tuan B, whose invaluable feedback contributed to the refinement of this book in future versions. Your insightful comments and constructive criticism have played a pivotal role in shaping its content and enhancing its quality. Thank you for your dedication and generosity in sharing your expertise. Your input will undoubtedly pave the way for future improvements and iterations of this work.</p> <p>Students and developers! By immersing yourself in the challenges and insights shared in this book, you will not only prepare for coding interviews but also cultivate a mindset beyond the scope of a job interview. You will become a problem solver, a strategic thinker, and a proficient C++ programmer.</p> <p>As you embark on this journey, remember that every challenge you encounter is an opportunity for growth. Embrace the complexities, learn from each solution, and let the knowledge you gain propel you to new heights in your programming career.</p> <p>Thank you for joining me on this expedition. </p> <p>May your code be elegant, your algorithms efficient, and your programming journey genuinely transformative.</p> <p>Happy coding!</p> <p>Copenhagen, March 2024.</p> <p>Nhut Nguyen, Ph.D.</p>"},{"location":"source/thanks/","title":"Thank you!","text":"<p>Dear Readers,</p> <p>Thank you for reading my book! Your support means the world to me. If you enjoyed the book and would like to share your thoughts, I would greatly appreciate it if you could leave a review and join our vibrant reader community. Your feedback and engagement help shape the future of our community, and I'm excited to connect with you further.</p> <p>Again, Thank you for your support and for participating in this journey.</p> <p>I hope it has been a valuable experience and that you are excited to continue your coding journey. Best of luck with your coding challenges, and remember to have fun along the way!</p> <p>Warm regards,   </p> <p>Nhut Nguyen, Ph.D.</p>"},{"location":"source/Array/1260_Shift_2D_Grid/","title":"Shift 2D Grid","text":""},{"location":"source/Array/1260_Shift_2D_Grid/#problem-statement","title":"Problem statement","text":"<p>You are given a 2D <code>grid</code> with dimension <code>mxn</code> and an integer <code>k</code>. Your task is to perform <code>k</code> shift operations on the grid.</p> <p>In each shift operation:</p> <ul> <li>The element at <code>grid[i][j]</code> moves to <code>grid[i][j+1]</code>.</li> <li>The element at <code>grid[i][n-1]</code> moves to <code>grid[i+1][0]</code>.</li> <li>The element at <code>grid[m-1][n-1]</code> moves to <code>grid[0][0]</code>.</li> </ul> <p>After performing <code>k</code> shift operations, return the updated 2D grid.</p>"},{"location":"source/Array/1260_Shift_2D_Grid/#example-1","title":"Example 1","text":"<p>\\begin{equation} \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 9 &amp; 1 &amp; 2 \\ 3 &amp; 4 &amp; 5 \\ 6 &amp; 7 &amp; 8 \\end{bmatrix} \\end{equation}</p> <pre><code>Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\nOutput: [[9,1,2],[3,4,5],[6,7,8]]\n</code></pre>"},{"location":"source/Array/1260_Shift_2D_Grid/#example-2","title":"Example 2","text":"<p>\\begin{equation} \\begin{bmatrix} 3 &amp; 8 &amp; 1 &amp; 9 \\ 19 &amp; 7 &amp; 2 &amp; 5 \\ 4 &amp; 6 &amp; 11 &amp; 10 \\ 12 &amp; 0 &amp; 21 &amp; 13 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 13 &amp; 3 &amp; 8 &amp; 1 \\ 9 &amp; 19 &amp; 7 &amp; 2 \\ 5 &amp; 4 &amp; 6 &amp; 11 \\ 10 &amp; 12 &amp; 0 &amp; 21 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 21 &amp; 13 &amp; 3 &amp; 8 \\ 1 &amp; 9 &amp; 19 &amp; 7 \\ 2 &amp; 5 &amp; 4 &amp; 6  \\ 11 &amp; 10 &amp; 12 &amp; 0  \\end{bmatrix} \\ \\end{equation} \\begin{equation} \\rightarrow \\begin{bmatrix} 0 &amp; 21 &amp; 13 &amp; 3 \\ 8 &amp; 1 &amp; 9 &amp; 19 \\ 7 &amp; 2 &amp; 5 &amp; 4 \\ 6 &amp; 11 &amp; 10 &amp; 12 \\end{bmatrix} \\rightarrow \\begin{bmatrix} 12 &amp; 0 &amp; 21 &amp; 13 \\ 3 &amp; 8 &amp; 1 &amp; 9 \\ 19 &amp; 7 &amp; 2 &amp; 5 \\ 4 &amp; 6 &amp; 11 &amp; 10 \\end{bmatrix} \\end{equation}</p> <pre><code>Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\nOutput: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n</code></pre>"},{"location":"source/Array/1260_Shift_2D_Grid/#example-3","title":"Example 3","text":"<pre><code>Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\nOutput: [[1,2,3],[4,5,6],[7,8,9]]\n</code></pre>"},{"location":"source/Array/1260_Shift_2D_Grid/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= grid.length &lt;= 50</code>.</li> <li><code>1 &lt;= grid[i].length &lt;= 50</code>.</li> <li><code>-1000 &lt;= grid[i][j] &lt;= 1000</code>.</li> <li><code>0 &lt;= k &lt;= 100</code>.</li> </ul>"},{"location":"source/Array/1260_Shift_2D_Grid/#solution-convert-a-2d-array-into-a-1d-one","title":"Solution: Convert a 2D array into a 1D one","text":"<p>You can convert the 2D <code>grid</code> into a 1D vector <code>v</code> to perform the shifting easier. One way of doing this is concatenating the rows of the matrix.</p> <ul> <li>If you shift the grid <code>k = i*N</code> times where <code>N = v.size()</code> and <code>i</code> is any non-negative integer, you go back to the original grid; i.e. you did not shift it.</li> <li>If you shift the grid <code>k</code> times with <code>0 &lt; k &lt; N</code>, the first element of the result starts from <code>v[N-k]</code>.</li> <li>In general, the first element of the result starts from <code>v[N - k%N]</code>.</li> </ul>"},{"location":"source/Array/1260_Shift_2D_Grid/#example-1_1","title":"Example 1","text":"<p>For <code>grid = [[1,2,3],[4,5,6],[7,8,9]]</code>:</p> <ul> <li>It can be converted into a 1D vector <code>v = [1,2,3,4,5,6,7,8,9]</code> of size <code>m*n = 9</code>.</li> <li>With <code>k = 1</code> the shifted <code>grid</code> now starts from <code>v[9-1] = 9</code>.</li> <li>The final result is <code>grid = [[9,1,2][3,4,5][6,7,8]]</code>.</li> </ul>"},{"location":"source/Array/1260_Shift_2D_Grid/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; shiftGrid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {\n    vector&lt;int&gt; v;\n    // store the 2D grid values into a 1D vector v\n    for (auto&amp; r : grid) {\n        v.insert(v.end(), r.begin(), r.end());\n    }\n    const int N = v.size();\n\n    // perform the shifting\n    int p = N - k % N;\n\n    // number of rows\n    const int m = grid.size();\n\n    // number of columns\n    const int n = grid[0].size();    \n\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (p == N) {\n                p = 0;\n            }\n            // reconstruct the grid\n            grid[i][j] = v[p++];\n        }\n    }\n    return grid;\n}\nvoid printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; grid) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; r : grid) {\n        cout &lt;&lt; \"[\";\n        for (int a: r) {\n            cout &lt;&lt; a &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"]\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; grid{{1,2,3},{4,5,6},{7,8,9}};\n    auto result = shiftGrid(grid, 1);\n    printResult(result);\n    grid = {{3,8,1,9},{19,7,2,5},{4,6,11,10},{12,0,21,13}};\n    result = shiftGrid(grid, 4);\n    printResult(result);\n    grid = {{1,2,3},{4,5,6},{7,8,9}};\n    result = shiftGrid(grid, 9);\n    printResult(result);\n}\n</code></pre> <pre><code>Output:\n[[9,1,2,][3,4,5,][6,7,8,]]\n[[12,0,21,13,][3,8,1,9,][19,7,2,5,][4,6,11,10,]]\n[[1,2,3,][4,5,6,][7,8,9,]]\n</code></pre> <p>This solution flattens the 2D <code>grid</code> into a 1D vector <code>v</code>, representing the grid's elements in a linear sequence. Then, by calculating the new position for each element after the shift operation, it reconstructs the grid by placing the elements back into their respective positions based on the calculated indices. This approach avoids unnecessary copying or shifting of elements within the grid, optimizing both memory and time complexity.</p>"},{"location":"source/Array/1260_Shift_2D_Grid/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m*n)</code> (the nested <code>for</code> loops), where <code>m = grid.length</code> and <code>n = grid[i].length</code>.</li> <li>Extra space: <code>O(m*n)</code> (the vector <code>v</code>).</li> </ul>"},{"location":"source/Array/1260_Shift_2D_Grid/#key-takeaway","title":"Key takeaway","text":"<ol> <li> <p>To convert a 2D matrix into a 1D vector, you can use the <code>std::vector</code>'s function <code>insert()</code>.</p> </li> <li> <p>The modulo operator <code>%</code> is usually used to ensure the index is inbound.</p> </li> </ol>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/","title":"Find All Numbers Disappeared in an Array","text":"<p>% Easy </p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#problem-statement","title":"Problem statement","text":"<p>You are given an array <code>nums</code> of <code>n</code> integers, where each integer <code>nums[i]</code> falls within the range <code>[1, n]</code>. Your task is to find and return an array containing all the integers in the range <code>[1, n]</code> that are not present in the given array <code>nums</code>.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]\n</code></pre>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,1]\nOutput: [2]\n</code></pre>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#constraints","title":"Constraints","text":"<ul> <li><code>n == nums.length</code>.</li> <li><code>1 &lt;= n &lt;= 10^5</code>.</li> <li><code>1 &lt;= nums[i] &lt;= n</code>.</li> </ul>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#follow-up","title":"Follow up","text":"<p>Can you solve the problem without using additional memory and achieve a linear runtime complexity? You can assume that the list you return does not count as extra space.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#solution-1-marking-the-appearances-by-bool","title":"Solution 1: Marking the appearances by <code>bool</code>","text":"<p>You can use a vector of <code>bool</code> to mark which value appeared in the array.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; findDisappearedNumbers(const vector&lt;int&gt;&amp; nums) {        \n\n    const int n = nums.size();\n    vector&lt;bool&gt; exist(n + 1, false);        \n    for (auto&amp; a : nums) {\n        exist[a] = true;\n    }\n    vector&lt;int&gt; result;\n    for (int i = 1; i &lt;= n; i++) {\n        if (!exist.at(i)) {\n            result.push_back(i);\n        }\n    }\n    return result;\n}\nvoid print(const vector&lt;int&gt;&amp; nums) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; a : nums) {\n        cout &lt;&lt; a &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums = {4,3,2,7,8,2,3,1};\n    auto result = findDisappearedNumbers(nums);\n    print(result);\n    nums = {1,1};\n    result = findDisappearedNumbers(nums);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n[5,6,]\n[2,]\n</code></pre> <p>This code declares a vector named <code>exist</code> of type <code>bool</code> and initializes all of its values to <code>false</code>. Its size is declared as <code>n + 1</code> where <code>n = nums.size()</code> so it can mark the values ranged from <code>1</code> to <code>n</code>.</p> <p>Then it performs the marking of all <code>nums</code>'s elements to <code>true</code>. The ones that are <code>false</code> will belong to the result.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#complexity","title":"Complexity","text":"<ul> <li> <p>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</p> </li> <li> <p>Extra space: much less than <code>O(n)</code>. <code>vector&lt;bool&gt;</code> is optimized for space efficiency; it stores single bits.</p> </li> </ul>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#solution-2-marking-the-appearances-by-sign","title":"Solution 2: Marking the appearances by sign","text":"<p>You could use the indices of the array <code>nums</code> to mark the appearances of its elements because they are just a shift (<code>[1, n]</code> vs. <code>[0, n-1]</code>).</p> <p>One way of marking the appearance of a value <code>j</code> (<code>1 &lt;= j &lt;= n</code>) is making the element <code>nums[j-1]</code> to be negative. Then the indices <code>j</code>'s whose <code>nums[j-1]</code> are still positive are the ones that do not appear in <code>nums</code>.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#example-1_1","title":"Example 1","text":"<p>With <code>nums = [4,3,2,7,8,2,3,1]</code>:</p> <ul> <li>To indicate <code>4</code> is present, make <code>nums[4-1]</code> is negative, i.e. changing <code>nums[4-1] = nums[3]</code> to <code>-7</code>.</li> <li>To indicate <code>3</code> is present, make <code>nums[3-1]</code> is negative, i.e. changing <code>nums[3-1] = nums[2]</code> to <code>-2</code>.</li> <li>And so on.</li> <li><code>nums</code> becomes <code>[-4,-3,-2,-7,8,2,-3,-1]</code>.</li> <li>The positive values <code>8</code> corresponds to <code>nums[4] = nums[5-1]</code>, indicates <code>5</code> was not present in <code>nums</code>.</li> <li>Similarly, the positive values <code>2</code> corresponds to <code>nums[5] = nums[6-1]</code>, indicates <code>6</code> was not present in <code>nums</code>.</li> </ul>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {\n    const int n = nums.size();\n    int j;\n    for (int i{0}; i &lt; n; i++) {\n        // make sure j is positive since nums[i] might be \n        // changed to be negative in previous steps\n        j = abs(nums.at(i));\n\n        // Mark nums[j - 1] as negative to indicate its presence       \n        nums[j - 1] = -abs(nums.at(j - 1));\n    }\n    vector&lt;int&gt; result;\n    for (int j{1}; j &lt;= n; j++) {\n        // If nums[j - 1] is positive, it means j is missing        \n        if (nums.at(j - 1) &gt; 0) {\n            result.push_back(j);\n        }\n    }\n    return result;\n}\nvoid print(const vector&lt;int&gt;&amp; nums) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; a : nums) {\n        cout &lt;&lt; a &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums = {4,3,2,7,8,2,3,1};\n    auto result = findDisappearedNumbers(nums);\n    print(result);\n    nums = {1,1};\n    result = findDisappearedNumbers(nums);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n[5,6,]\n[2,]\n</code></pre> <p>The key to this solution is that it utilizes the array to mark the presence of numbers. Negating the value at the index corresponding to each number found in the input array effectively marks that number as present. Then, by iterating through the modified array, it identifies the missing numbers by checking which indices still hold positive values.</p>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code> (the returned list does not count as extra space).</li> </ul>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#readable-code","title":"Readable code","text":"<ul> <li> <p>Solution 2 helps to avoid allocating extra memory but it is not straightforward to understand.</p> </li> <li> <p>Though Solution 1 requires some extra space, that memory is not much since <code>std::vector&lt;bool&gt;</code> is optimized for space efficiency. Moreover, it is easier to understand than Solution 2.</p> </li> </ul>"},{"location":"source/Array/448_Find_All_Numbers_Disappeared_in_an_Array/#exercise","title":"Exercise","text":"<ul> <li>Find All Duplicates in an Array.</li> </ul>"},{"location":"source/Array/48_Rotate_Image/","title":"Rotate Image","text":"<p>% Medium </p>"},{"location":"source/Array/48_Rotate_Image/#problem-statement","title":"Problem statement","text":"<p>Given an <code>n x n</code> 2D matrix representing an image, your task is to rotate the image by 90 degrees clockwise. The rotation must be performed in-place, meaning you need to modify the original input 2D matrix directly. It is not allowed to create another 2D matrix for the rotation.</p>"},{"location":"source/Array/48_Rotate_Image/#example-1","title":"Example 1","text":"<p>\\begin{equation} \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 7 &amp; 4 &amp; 1 \\ 8 &amp; 5 &amp; 2 \\ 9 &amp; 6 &amp; 3 \\end{bmatrix} \\end{equation}</p> <pre><code>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n</code></pre>"},{"location":"source/Array/48_Rotate_Image/#example-2","title":"Example 2","text":"<p>\\begin{equation} \\begin{bmatrix} 5 &amp; 1 &amp; 9 &amp; 11 \\ 2 &amp; 4 &amp; 8 &amp; 10 \\ 13 &amp; 3 &amp; 6 &amp; 7 \\ 15 &amp; 14 &amp; 12 &amp; 16 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 15 &amp; 13 &amp; 2 &amp; 5 \\ 14 &amp; 3 &amp; 4 &amp; 1 \\ 12 &amp; 6 &amp; 8 &amp; 9 \\ 16 &amp; 7 &amp; 10 &amp; 11 \\end{bmatrix} \\end{equation}</p> <pre><code>Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n</code></pre>"},{"location":"source/Array/48_Rotate_Image/#constraints","title":"Constraints","text":"<ul> <li><code>n == matrix.length == matrix[i].length</code>.</li> <li><code>1 &lt;= n &lt;= 20</code>.</li> <li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code>.</li> </ul>"},{"location":"source/Array/48_Rotate_Image/#solution-the-math-behind","title":"Solution: The math behind","text":"<p>For any square matrix, the rotation 90 degrees clockwise can be performed in two steps:</p> <ol> <li>Transpose the matrix.</li> <li>Mirror the matrix vertically.</li> </ol>"},{"location":"source/Array/48_Rotate_Image/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvoid rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    const int n = matrix.size();\n    // transpose\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = i + 1; j &lt; n; j++) {\n            swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n    // vertical mirror\n    for (int i = 0; i &lt; n; i++) {\n        for (int j = 0; j &lt; n / 2; j++ ) {\n            swap(matrix[i][j], matrix[i][n - 1 - j]);\n        }\n    }\n}\nvoid printMatrix(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; row: matrix) {\n        cout &lt;&lt; \"[\";\n        for (auto&amp; a: row) {\n            cout &lt;&lt; a &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"],\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; matrix{{1,2,3},{4,5,6},{7,8,9}};\n    rotate(matrix);\n    printMatrix(matrix);\n    matrix = {{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}};\n    rotate(matrix);\n    printMatrix(matrix);\n}\n</code></pre> <pre><code>Output:\n[[7,4,1,],[8,5,2,],[9,6,3,],]\n[[15,13,2,5,],[14,3,4,1,],[12,6,8,9,],[16,7,10,11,],]\n</code></pre>"},{"location":"source/Array/48_Rotate_Image/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n = matrix.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/48_Rotate_Image/#implementation-tips","title":"Implementation tips","text":"<ol> <li> <p>The function <code>std::swap</code> can be used to exchange two values.</p> </li> <li> <p>When doing the transpose or mirroring, you could visit over only one-half of the matrix.</p> </li> </ol>"},{"location":"source/Array/48_Rotate_Image/#exercise","title":"Exercise","text":"<ul> <li>Determine Whether Matrix Can Be Obtained By Rotation.</li> </ul>"},{"location":"source/Array/59_Spiral_Matrix_II/","title":"Spiral Matrix II","text":"<p>% Medium </p>"},{"location":"source/Array/59_Spiral_Matrix_II/#problem-statement","title":"Problem statement","text":"<p>Given a positive integer <code>n</code>, generate an <code>n x n</code> matrix filled with elements from <code>1</code> to <code>n^2</code> in spiral order.</p>"},{"location":"source/Array/59_Spiral_Matrix_II/#example-1","title":"Example 1","text":"<pre><code>Input: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n</code></pre>"},{"location":"source/Array/59_Spiral_Matrix_II/#example-2","title":"Example 2","text":"<pre><code>Input: n = 1\nOutput: [[1]]\n</code></pre>"},{"location":"source/Array/59_Spiral_Matrix_II/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n &lt;= 20</code>.</li> </ul>"},{"location":"source/Array/59_Spiral_Matrix_II/#solution","title":"Solution","text":"<ol> <li>Starting from the top left of the matrix.</li> <li>Going along the spiral direction. </li> <li>Put the value to the matrix, starting from <code>1</code>.</li> </ol>"},{"location":"source/Array/59_Spiral_Matrix_II/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nenum Direction {RIGHT, DOWN, LEFT, UP};\nvector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) {\n    vector&lt;vector&lt;int&gt;&gt; m(n, vector&lt;int&gt;(n));\n    int bottom = n - 1;\n    int right = n - 1;\n    int top = 0;\n    int left = 0;\n    int row = 0;\n    int col = 0;\n    Direction d = RIGHT;\n    int a = 1;\n    while (top &lt;= bottom &amp;&amp; left &lt;= right) {\n        m[row][col] = a++;\n        switch (d) {\n            case RIGHT: if (col == right) {\n                            top++;\n                            d = DOWN;\n                            row++;\n                        } else {\n                            col++;\n                        }\n                        break;\n            case DOWN:  if (row == bottom) {\n                            right--;\n                            d = LEFT;\n                            col--;\n                        } else {\n                            row++;\n                        }\n                        break;\n            case LEFT:  if (col == left) {\n                            bottom--;\n                            d = UP;\n                            row--;\n                        } else {\n                            col--;\n                        }\n                        break;\n            case UP:    if (row == top) {\n                            left++;\n                            d = RIGHT;\n                            col++;\n                        } else {\n                            row--;\n                        }\n                        break;\n        }\n    }\n    return m;\n}\nvoid printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; m) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; r : m) {\n        cout &lt;&lt; \"[\";\n        for (int a : r) {\n            cout &lt;&lt; a &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"]\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    auto m = generateMatrix(3);\n    printResult(m);\n    m = generateMatrix(1);\n    printResult(m);\n}\n</code></pre> <pre><code>Output:\n[[1,2,3,][8,9,4,][7,6,5,]]\n[[1,]]\n</code></pre> <p>This solution uses a <code>Direction</code> <code>enum</code> and boundary variables to iteratively fill the matrix in a spiral pattern. Updating the direction of movement based on the current position and boundaries efficiently populates the matrix with sequential values, traversing in a clockwise direction from the outer layer to the inner layer.</p>"},{"location":"source/Array/59_Spiral_Matrix_II/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n x n</code> is the size of the matrix.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/59_Spiral_Matrix_II/#key-takeaway","title":"Key Takeaway","text":"<p>Enumerating directions with an enum (like <code>Direction</code>) can enhance code readability and maintainability, especially in algorithms involving traversal or movement. It aids in clearly defining and referencing the possible directions within the problem domain.</p>"},{"location":"source/Array/59_Spiral_Matrix_II/#exercise","title":"Exercise","text":"<ul> <li>Spiral Matrix.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/","title":"Daily Temperatures","text":"<p>% Medium </p>"},{"location":"source/Array/739_Daily_Temperatures/#problem-statement","title":"Problem statement","text":"<p>You are given an array of integers <code>temperatures</code>, which represents the daily temperatures. Your task is to create an array <code>answer</code> such that <code>answer[i]</code> represents the number of days you need to wait after the i-th day to experience a warmer temperature. If there is no future day with a warmer temperature, then <code>answer[i]</code> should be set to <code>0</code>. </p>"},{"location":"source/Array/739_Daily_Temperatures/#example-1","title":"Example 1","text":"<pre><code>Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n</code></pre>"},{"location":"source/Array/739_Daily_Temperatures/#example-2","title":"Example 2","text":"<pre><code>Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n</code></pre>"},{"location":"source/Array/739_Daily_Temperatures/#example-3","title":"Example 3","text":"<pre><code>Input: temperatures = [30,60,90]\nOutput: [1,1,0]\n</code></pre>"},{"location":"source/Array/739_Daily_Temperatures/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= temperatures.length &lt;= 10^5</code>.</li> <li><code>30 &lt;= temperatures[i] &lt;= 100</code>.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/#solution-1-starting-from-the-first-day","title":"Solution 1: Starting from the first day","text":"<p>For each <code>temperatures[i]</code>, find the closest <code>temperatures[j]</code> with <code>j &gt; i</code> such that <code>temperatures[j] &gt; temperatures[i]</code>, then <code>answer[i] = j - i</code>. If not found, <code>answer[i] = 0</code>.</p>"},{"location":"source/Array/739_Daily_Temperatures/#example-1_1","title":"Example 1","text":"<p>For <code>temperatures = [73,74,75,71,69,72,76,73]</code>:</p> <ul> <li><code>answer[0] = 1</code> since the next day is warmer (<code>74 &gt; 73</code>).</li> <li><code>answer[1] = 1</code> since the next day is warmer (<code>75 &gt; 74</code>).</li> <li><code>answer[2] = 4</code> since only after <code>4</code> days it is warmer (<code>76 &gt; 75</code>).</li> <li>And so on.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; dailyTemperatures(const vector&lt;int&gt;&amp; temperatures) {\n    vector&lt;int&gt; answer(temperatures.size());\n    for (int i = 0; i &lt; temperatures.size(); i++) {\n        answer[i] = 0;\n        for (int j = i + 1; j &lt; temperatures.size(); j++) {\n            if (temperatures[j] &gt; temperatures[i]) {\n                answer[i] = j - i;\n                break;\n            }\n        }\n    }\n    return answer;\n}\nvoid print(const vector&lt;int&gt;&amp; answer) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; v : answer ) {\n        cout &lt;&lt; v &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; temperatures{73,74,75,71,69,72,76,73};\n    auto answer = dailyTemperatures(temperatures);\n    print(answer);\n    temperatures = {30,40,50,60};\n    answer = dailyTemperatures(temperatures);\n    print(answer);\n    temperatures = {30,60,90};\n    answer = dailyTemperatures(temperatures);\n    print(answer);\n}\n</code></pre> <pre><code>Output:\n[1,1,4,2,1,1,0,0,]\n[1,1,1,0,]\n[1,1,0,]\n</code></pre> <p>This solution iterates through the <code>temperatures</code> array and, for each temperature, iterates through the remaining temperatures to find the next higher temperature. Storing the time difference between the current day and the next higher temperature day constructs the resulting array representing the number of days until warmer temperatures.</p>"},{"location":"source/Array/739_Daily_Temperatures/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N^2)</code>, where <code>N = temperatures.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/#solution-2-starting-from-the-last-day","title":"Solution 2: Starting from the last day","text":"<p>The straightforward solution above is easy to understand, but the complexity is <code>O(N^2)</code>. </p> <p>The way starting from the first day to the last day does not make use of the knowledge of the <code>answer[i]</code> values. </p> <ul> <li>The value <code>answer[i] &gt; 0</code> tells you that <code>temperatures[i + answer[i]]</code> is the next temperature that is warmer than <code>temperatures[i]</code>. </li> <li>The value <code>answer[i] = 0</code> tells you that there is no warmer temperature than <code>temperatures[i]</code>. </li> </ul> <p>When computing <code>answer[i]</code> in the reversed order, you can use that knowledge more efficiently.</p> <p>Suppose you already know the future values <code>answer[j]</code>. To compute an older value <code>answer[i]</code> with <code>i &lt; j</code>, you need only to compare <code>temperatures[i]</code> with <code>temperatures[i + 1]</code> and its chain of warmer temperatures.  </p>"},{"location":"source/Array/739_Daily_Temperatures/#example-1_2","title":"Example 1","text":"<p>For <code>temperatures = [73,74,75,71,69,72,76,73]</code>. </p> <p>Suppose you have computed all <code>answer[j]</code> with <code>j &gt; 2</code>, <code>answer = [?,?,?,2,1,1,0,0]</code>.  </p> <p>To compute <code>answer[i = 2]</code> for <code>temperatures[2] = 75</code>, you need to compare it with</p> <ul> <li><code>temperatures[3] = 71 (&lt; 75)</code>. Go to the next warmer temperature than <code>temperatures[3]</code>, which is <code>temperatures[3 + answer[3]] = temperatures[3 + 2]</code>. </li> <li><code>temperatures[5] = 72 (&lt; 75)</code>. Go to the next warmer temperature than <code>temperatures[5]</code>, which is <code>temperatures[5 + answer[5]] = temperatures[5 + 1]</code>. </li> <li><code>temperatures[6] = 76 (&gt; 75)</code>. Stop.</li> <li><code>answer[i = 2] = j - i = 6 - 2 = 4</code>.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; dailyTemperatures(const vector&lt;int&gt;&amp; temperatures) {\n    vector&lt;int&gt; answer(temperatures.size(), 0);\n    for (int i = temperatures.size() - 2; i &gt;= 0 ; i--) {\n        int j = i + 1;\n        while (j &lt; temperatures.size() &amp;&amp; \n               temperatures[j] &lt;= temperatures[i]) {\n            // some temperature is bigger than temperatures[j], \n            // go to that value \n            if (answer[j] &gt; 0) { \n                j += answer[j];\n            } else {\n                j = temperatures.size();    \n            }\n        }\n        if (j &lt; temperatures.size()) {\n            answer[i] = j - i;\n        }\n    }\n    return answer;\n}\nvoid print(const vector&lt;int&gt;&amp; answer) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; v : answer ) {\n        cout &lt;&lt; v &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; temperatures{73,74,75,71,69,72,76,73};\n    auto answer = dailyTemperatures(temperatures);\n    print(answer);\n    temperatures = {30,40,50,60};\n    answer = dailyTemperatures(temperatures);\n    print(answer);\n    temperatures = {30,60,90};\n    answer = dailyTemperatures(temperatures);\n    print(answer);\n}\n</code></pre> <pre><code>Output:\n[1,1,4,2,1,1,0,0,]\n[1,1,1,0,]\n[1,1,0,]\n</code></pre> <p>The key to this solution lies in its optimized approach to finding the next higher temperature. It utilizes a <code>while</code> loop to traverse the <code>temperatures</code> array efficiently, skipping elements if they are not potential candidates for a higher temperature. Updating the index based on previously calculated values stored in the <code>answer</code> array avoids unnecessary iterations, resulting in improved performance compared to the straightforward nested loop approach.</p> <p>This improved solution reduces the time complexity to <code>O(N)</code> as it iterates through the <code>temperatures</code> vector only once, resulting in a more efficient algorithm for finding the waiting periods for each day.</p>"},{"location":"source/Array/739_Daily_Temperatures/#complexity_1","title":"Complexity","text":"<p>Worse cases for the <code>while</code> loop are when most <code>temperatures[j]</code> in their chain are cooler than <code>temperatures[i]</code>. </p> <p>In these cases, the resulting <code>answer[i]</code> will be either <code>0</code> or a big value <code>j - i</code>. Those extreme values give you a huge knowledge when computing <code>answer[i]</code> for other older days <code>i</code>.</p> <p>The value <code>0</code> would help the <code>while</code> loop terminates very soon. On the other hand, the big value <code>j - i</code> would help the <code>while</code> loop skips the days <code>j</code> very quickly.</p> <ul> <li>Runtime: <code>O(N)</code>, where <code>N = temperatures.length</code>. </li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/739_Daily_Temperatures/#tips","title":"Tips","text":"<p>In some computations, you could improve the performance by using the knowledge of the results you have computed. </p> <p>In this particular problem, it can be achieved by doing it in the reversed order.</p>"},{"location":"source/Array/739_Daily_Temperatures/#exercise","title":"Exercise","text":"<ul> <li>Next Greater Element I.</li> </ul>"},{"location":"source/Array/867_Transpose_Matrix/","title":"Transpose Matrix","text":"<p>% Easy </p>"},{"location":"source/Array/867_Transpose_Matrix/#problem-statement","title":"Problem statement","text":"<p>You are given a 2D integer array <code>matrix</code>, and your objective is to find the transpose of the given matrix.</p> <p>The transpose of a matrix involves flipping the matrix over its main diagonal, effectively swapping its row and column indices.</p> <p>\\begin{equation} \\begin{bmatrix} 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\end{bmatrix} \\longrightarrow \\begin{bmatrix} 1 &amp; 4 &amp; 7 \\ 2 &amp; 5 &amp; 8 \\ 3 &amp; 6 &amp; 9 \\end{bmatrix} \\end{equation}</p>"},{"location":"source/Array/867_Transpose_Matrix/#example-1","title":"Example 1","text":"<pre><code>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]\n</code></pre>"},{"location":"source/Array/867_Transpose_Matrix/#example-2","title":"Example 2","text":"<pre><code>Input: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]\n</code></pre>"},{"location":"source/Array/867_Transpose_Matrix/#constraints","title":"Constraints","text":"<ul> <li><code>m == matrix.length</code>.</li> <li><code>n == matrix[i].length</code>.</li> <li><code>1 &lt;= m, n &lt;= 1000</code>.</li> <li><code>1 &lt;= m * n &lt;= 10^5</code>.</li> <li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code>.</li> </ul>"},{"location":"source/Array/867_Transpose_Matrix/#solution","title":"Solution","text":""},{"location":"source/Array/867_Transpose_Matrix/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; transpose(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    // declare the transposed matrix mt of desired size, i.e.\n    // mt's number of rows = matrix's number of columns\n    // mt's number of columns = matrix's number of rows\n    vector&lt;vector&lt;int&gt;&gt; mt(matrix[0].size(), \n                           vector&lt;int&gt;(matrix.size()));\n    for (int i = 0; i &lt; mt.size(); i++) {\n        for (int j = 0; j &lt; mt[i].size(); j++) {\n            mt[i][j] = matrix[j][i];\n        }\n    }\n    return mt;\n}\nvoid printResult(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; row : matrix) {\n        cout &lt;&lt; \"[\";\n        for (int m : row) {\n            cout &lt;&lt; m &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"]\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; matrix = {{1,2,3},{4,5,6},{7,8,9}};\n    auto result = transpose(matrix);\n    printResult(result);\n    matrix = {{1,2,3},{4,5,6}};\n    result = transpose(matrix);\n    printResult(result);\n}\n</code></pre> <pre><code>Output:\n[[1,4,7,][2,5,8,][3,6,9,]]\n[[1,4,][2,5,][3,6,]]\n</code></pre>"},{"location":"source/Array/867_Transpose_Matrix/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m*n)</code>, where <code>m = matrix.length</code> and <code>n = matrix[i].length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/867_Transpose_Matrix/#implementation-note","title":"Implementation note","text":"<p>Note that the matrix might not be square, you cannot just swap the elements using for example the function <code>std::swap</code>.</p>"},{"location":"source/Array/941_Valid_Mountain_Array/","title":"Valid Mountain Array","text":"<p>% Easy</p>"},{"location":"source/Array/941_Valid_Mountain_Array/#problem-statement","title":"Problem statement","text":"<p>You are given an array of integers <code>arr</code>, and your task is to determine whether it is a valid mountain array.</p> <p>A valid mountain array must meet the following conditions:</p> <ol> <li>The length of <code>arr</code> should be greater than or equal to <code>3</code>.</li> <li>There should exist an index <code>i</code> such that <code>0 &lt; i &lt; arr.length - 1</code>, and the elements up to <code>i</code> (<code>arr[0]</code> to <code>arr[i]</code>) should be in strictly ascending order, while the elements starting from <code>i</code> (<code>arr[i]</code> to <code>arr[arr.length-1]</code>) should be in strictly descending order.</li> </ol> <p></p>"},{"location":"source/Array/941_Valid_Mountain_Array/#example-1","title":"Example 1","text":"<pre><code>Input: arr = [2,1]\nOutput: false\n</code></pre>"},{"location":"source/Array/941_Valid_Mountain_Array/#example-2","title":"Example 2","text":"<pre><code>Input: arr = [3,5,5]\nOutput: false\n</code></pre>"},{"location":"source/Array/941_Valid_Mountain_Array/#example-3","title":"Example 3","text":"<pre><code>Input: arr = [0,3,2,1]\nOutput: true\n</code></pre>"},{"location":"source/Array/941_Valid_Mountain_Array/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= arr.length &lt;= 10^4</code>.</li> <li><code>0 &lt;= arr[i] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Array/941_Valid_Mountain_Array/#solution","title":"Solution","text":"<p>Following the conditions, you might implement like the following.</p>"},{"location":"source/Array/941_Valid_Mountain_Array/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nbool validMountainArray(const vector&lt;int&gt;&amp; arr) {\n    if (arr.size() &lt; 3) {\n        return false;\n    }\n    const int N = arr.size() - 1;\n    int i = 0;\n    // find the top of the mountain\n    while (i &lt; N &amp;&amp; arr[i] &lt; arr[i + 1]) {\n        i++;\n    }\n    // condition: 0 &lt; i &lt; N - 1\n    if (i == 0 || i == N) {\n        return false;\n    }\n    // going from the top to the bottom\n    while (i &lt; N &amp;&amp; arr[i] &gt; arr[i + 1]) {\n        i++;\n    }\n    return i == N;\n}\nint main() {\n    vector&lt;int&gt; arr{2,1};\n    cout &lt;&lt; validMountainArray(arr) &lt;&lt; endl;\n    arr = {3,5,5};   \n    cout &lt;&lt; validMountainArray(arr) &lt;&lt; endl;\n    arr = {0,3,2,1};   \n    cout &lt;&lt; validMountainArray(arr) &lt;&lt; endl;\n    arr = {9,8,7,6,5,4,3,2,1,0};\n    cout &lt;&lt; validMountainArray(arr) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n0\n1\n0\n</code></pre> <p>This solution iteratively checks for the two slopes of a mountain array, ensuring that the elements to the left are strictly increasing and the elements to the right are strictly decreasing. If both conditions are met, the function returns <code>true</code>, indicating that the input array is a valid mountain array; otherwise, it returns <code>false</code>.</p>"},{"location":"source/Array/941_Valid_Mountain_Array/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = arr.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Array/941_Valid_Mountain_Array/#coding-best-practices","title":"Coding best practices","text":"<p>Breaking down the problem into distinct stages, like finding the peak of the mountain and then traversing down from there, can simplify the logic and improve code readability. This approach facilitates a clear understanding of the algorithm's progression and helps in handling complex conditions effectively.</p>"},{"location":"source/Array/941_Valid_Mountain_Array/#exercise","title":"Exercise","text":"<ul> <li>Beautiful Towers I.</li> </ul>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/","title":"Letter Combinations of a Phone Number","text":""},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#problem-statement","title":"Problem statement","text":"<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p> <p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that <code>1</code> does not map to any letters.</p> <p></p>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#example-1","title":"Example 1","text":"<pre><code>Input: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n</code></pre>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#example-2","title":"Example 2","text":"<pre><code>Input: digits = \"\"\nOutput: []\n</code></pre>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#example-3","title":"Example 3","text":"<pre><code>Input: digits = \"2\"\nOutput: [\"a\",\"b\",\"c\"]\n</code></pre>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= digits.length &lt;= 4</code>.</li> <li><code>digits[i]</code> is a digit in the range <code>['2', '9']</code>.</li> </ul>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#solution-recursive","title":"Solution: Recursive","text":"<p>If you know the combinations <code>result</code> of a string <code>digits</code>, what is the result of extending it one more digit?</p> <p>Answer: The new result is constructed by adding each letter of the mapping of the new digit to each string of the <code>result</code>. </p>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#example-1-and-3","title":"Example 1 and 3","text":"<p>Assume you have computed the result of <code>digits = \"2\"</code>, which is <code>[\"a\",\"b\",\"c\"]</code>. </p> <p>To compute the result of <code>digits = \"23\"</code>, you add each letter of the mapping <code>'3' -&gt; {'d', 'e', 'f'}</code> to each string <code>\"a\", \"b\", \"c\"</code>. </p> <p>You get the new result <code>[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]</code>.</p>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nconst unordered_map&lt;char, vector&lt;char&gt; &gt; m{{'2', {'a', 'b', 'c'}},\n                                        {'3', {'d', 'e', 'f'}},\n                                        {'4', {'g', 'h', 'i'}},\n                                        {'5', {'j', 'k', 'l'}},\n                                        {'6', {'m', 'n', 'o'}},\n                                        {'7', {'p', 'q', 'r', 's'}},\n                                        {'8', {'t', 'u', 'v'}},\n                                        {'9', {'w', 'x', 'y', 'z'}}};\n\nvoid combination(const string_view&amp; digits, int i, vector&lt;string&gt;&amp; result) {\n    if (i &gt;= digits.length()) {\n        return;\n    }\n    if (result.empty()) {\n        result = {\"\"};\n    }\n    vector&lt;string&gt; newResult;\n    for (string&amp; s : result) {\n        for (auto&amp; c : m.at(digits[i])) {\n            newResult.push_back(s + c);\n        }\n    }\n    result.swap(newResult);\n    combination(digits, i + 1, result);\n}\nvector&lt;string&gt; letterCombinations(string digits) {\n    vector&lt;string&gt; result;\n    combination(digits, 0, result);\n    return result;\n}\nvoid printResult(vector&lt;string&gt;&amp; result) {\n    cout &lt;&lt; \"[\";\n    for (string&amp; s : result) {\n        cout &lt;&lt; s &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;string&gt; result = letterCombinations(\"23\");\n    printResult(result);\n    result = letterCombinations(\"\");\n    printResult(result);\n    result = letterCombinations(\"2\");\n    printResult(result);\n}\n</code></pre> <pre><code>Output:\n[ad,ae,af,bd,be,bf,cd,ce,cf,]\n[]\n[a,b,c,]\n</code></pre>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(3^N)</code>, where <code>N = digits.length</code>. In this problem, <code>N</code> is very small (<code>N &lt;= 4</code>).</li> <li>Extra space: <code>O(1)</code> (the small map).</li> </ul>"},{"location":"source/Back_Tracking/17_Letter_Combinations_of_a_Phone_Number/#implementation-notes","title":"Implementation notes","text":"<p>You can use the assignment operator <code>'='</code> for <code>result.swap(newResult)</code>, i.e. <code>result = newResult</code>. </p> <p>But this assignment allocates additional memory for a copy of <code>newResult</code> before assigning it to <code>result</code>.</p> <p>The <code>std::swap()</code> algorithm avoids such copying by using <code>std::move()</code>. It exchanges the contents of each other without allocating additional memory.</p>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/","title":"Sudoku Solver","text":"<p>% Hard</p>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#problem-statement","title":"Problem statement","text":"<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p> <p>A sudoku solution must satisfy all of the following rules:</p> <p>Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid. The '.' character indicates empty cells.</p>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#example-1","title":"Example 1","text":"<pre><code>Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\n\nExplanation: The input board is shown above and the only valid solution is shown below:\n</code></pre>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#constraints","title":"Constraints","text":"<ul> <li><code>board.length == 9</code>.</li> <li><code>board[i].length == 9</code>.</li> <li><code>board[i][j]</code> is a digit or <code>'.'</code>.</li> <li>It is guaranteed that the input board has only one solution.</li> </ul>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#solution","title":"Solution","text":"<p>This is a classical example for Back Tracking:</p> <p>For each empty cell of the <code>board</code>, and for each remaining valid digit you need to check if you can go further to other cells with that digit or you have to choose another one to go.</p>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nbool isValid(const vector&lt;vector&lt;char&gt;&gt;&amp; board, int row, int col, char c) {\n    // Check row\n    for (int i = 0; i &lt; 9; i++) {\n        if (board[row][i] == c) return false;\n    }\n    // Check column\n    for (int i = 0; i &lt; 9; i++) {\n        if (board[i][col] == c) return false;\n    }\n    // Check 3x3 sub-box\n    for (int i = 0; i &lt; 9; i++) {\n        // sub-box's row-position\n        auto subrow = 3 * (row / 3) + i / 3;\n        // sub-box'scol-position\n        auto subcol = 3 * (col / 3) + i % 3;\n        if (board[subrow][subcol] == c) return false;\n    }\n    return true;\n}\n\nbool solve(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n    for (int i = 0; i &lt; 9; i++) {\n        for (int j = 0; j &lt; 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c &lt;= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solve(board)) {\n                            return true;\n                        } else {\n                            board[i][j] = '.';\n                        }\n                    }\n                }\n                return false; // If no valid number can be placed, return false\n            }\n        }\n    }\n    return true; // If all cells are filled correctly, return true\n}\n\nvoid solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n    solve(board);\n}\n\nvoid print(const vector&lt;vector&lt;char&gt;&gt;&amp; board) {\n    cout &lt;&lt; '{';\n    for (int i = 0; i &lt; 9; i++) {\n        cout &lt;&lt; '{';\n        for (int j = 0; j &lt; 9; j++) {\n            cout &lt;&lt; board[i][j];\n            if (j &lt; 8) {\n                cout &lt;&lt; \",\";\n            }\n        }\n        cout &lt;&lt; \"}\\n\";\n    }\n    cout &lt;&lt; \"}\\n\";\n}\n\nint main() {\n    vector&lt;vector&lt;char&gt;&gt; board{ {'5','3','.','.','7','.','.','.','.'},\n                                {'6','.','.','1','9','5','.','.','.'},\n                                {'.','9','8','.','.','.','.','6','.'},\n                                {'8','.','.','.','6','.','.','.','3'},\n                                {'4','.','.','8','.','3','.','.','1'},\n                                {'7','.','.','.','2','.','.','.','6'},\n                                {'.','6','.','.','.','.','2','8','.'},\n                                {'.','.','.','4','1','9','.','.','5'},\n                                {'.','.','.','.','8','.','.','7','9'}};\n    solveSudoku(board);\n    print(board);\n}\n</code></pre> <pre><code>Output:\n{{5,3,4,6,7,8,9,1,2}\n{6,7,2,1,9,5,3,4,8}\n{1,9,8,3,4,2,5,6,7}\n{8,5,9,7,6,1,4,2,3}\n{4,2,6,8,5,3,7,9,1}\n{7,1,3,9,2,4,8,5,6}\n{9,6,1,5,3,7,2,8,4}\n{2,8,7,4,1,9,6,3,5}\n{3,4,5,2,8,6,1,7,9}\n}\n</code></pre>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(9^3)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Back_Tracking/37_Sudoku_Solver/#conclusion","title":"Conclusion","text":"<p>The Sudoku Solver problem is an excellent example of how backtracking can be used to tackle complex problems. </p> <p>This approach, where a solution is built incrementally and backtracks when an invalid configuration is encountered, is particularly effective for constraint satisfaction problems like Sudoku. </p> <p>The recursive nature of the solution allows for efficient exploration of vast configuration spaces, breaking the problem down into smaller, manageable tasks. </p>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/","title":"Single Element in a Sorted Array","text":""},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#problem-statement","title":"Problem statement","text":"<p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p> <p>Return the single element that appears only once.</p> <p>Your solution must run in <code>O(logn)</code> time and <code>O(1)</code> space.</p>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,1,2,3,3,4,4,8,8]\nOutput: 2\n</code></pre>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [3,3,7,7,10,11,11]\nOutput: 10\n</code></pre>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>0 &lt;= nums[i] &lt;= 10^5</code>.</li> </ul>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":""},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint singleNonDuplicate(vector&lt;int&gt;&amp; nums) {\n    for (int i = 0; i &lt; nums.size() - 1; i += 2) {\n        if (nums[i] != nums[i + 1]) {\n            return nums[i];\n        }\n    }\n    return nums[0];\n}\nint  main() {\n    vector&lt;int&gt; nums{1,1,2,3,3,4,4,8,8};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n    nums = {3,3,7,7,10,11,11};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n    nums = {3};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n10\n3\n</code></pre>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#code-explanation","title":"Code explanation","text":"<ol> <li> <p>The code uses a simple loop to iterate through the array <code>nums</code>.</p> </li> <li> <p>Inside the loop, it checks if the current element <code>nums[i]</code> is equal to the next element <code>nums[i + 1]</code>.</p> </li> <li> <p>If the current element and the next element are not equal, it means that <code>nums[i]</code> is the single element because all other elements in the sorted array appear twice. In this case, the code immediately returns <code>nums[i]</code> as the result.</p> </li> <li> <p>If the current element and the next element are equal, it means that the single element has not been found yet, and the loop continues to the next pair of elements.</p> </li> <li> <p>The loop continues until <code>i</code> reaches the second-to-last element in the array. This is because the code compares elements in pairs, and there's no \"next element\" to compare with the last element.</p> </li> <li> <p>If the loop completes without finding the single element, it means that the single element is the first element in the array (since it hasn't been found in any pair). Therefore, the code returns <code>nums[0]</code> as the result.</p> </li> </ol> <p>In summary, this code takes advantage of the sorted nature of the array to find the single element efficiently. It iterates through the array by comparing elements in pairs, and as soon as it finds a pair of elements that are not equal, it returns the first element of that pair as the result. If no such pair is found, it returns the first element as the single element. </p>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#complexity","title":"Complexity","text":"<ul> <li>Runtime <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Memory <code>O(1)</code>.</li> </ul>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#solution-2-binary-search","title":"Solution 2: Binary search","text":"<p>Since <code>nums</code> is sorted, you can perform a binary search on it.</p> <p>Let us divide <code>nums</code> into two halves.</p> <p>If the single element belongs to the right half, all elements of the left half satisfy <code>nums[2*i] == nums[2*i + 1]</code>.</p> <p>Conversely, if the single element belongs to the left half, that condition is violated at the middle element of <code>nums</code> (the middle one with an even index).</p>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#example-1_1","title":"Example 1","text":"<p>For <code>nums = [1,1,2,3,3,4,4,8,8]</code>:</p> <ul> <li>The middle element with even index is <code>nums[4] = 3</code>. It is not equal to <code>nums[4 + 1] = 4</code>. So the single element must be somewhere in the left half <code>[1,1,2,3,3]</code>.</li> <li>The middle element of <code>nums = [1,1,2,3,3]</code> with even index is <code>nums[2] = 2</code>, which is not equal to <code>nums[2 + 1] = 3</code>. So the single element must be somewhere in the left half <code>[1,1,2]</code>.</li> <li>The middle element of <code>nums = [1,1,2]</code> with even index is <code>nums[0] = 1 == nums[0 + 1]</code>. So the single element must be somewhere in the right half <code>[2]</code>.</li> <li><code>nums = [2]</code> contains only one element. So <code>2</code> is the result.</li> </ul>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint singleNonDuplicate(vector&lt;int&gt;&amp; nums) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left &lt; right) {\n        int mid = (right + left)/4 * 2; // to make sure mid is even\n        if (nums[mid] != nums[mid + 1]) {\n            right = mid;\n        } else {\n            left = mid + 2;\n        }\n    }\n    return nums[right];\n}\nint  main() {\n    vector&lt;int&gt; nums{1,1,2,3,3,4,4,8,8};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n    nums = {3,3,7,7,10,11,11};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n    nums = {3};\n    cout &lt;&lt; singleNonDuplicate(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n10\n3\n</code></pre>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#code-explanation_1","title":"Code explanation","text":"<ol> <li> <p>Two integer variables, <code>left</code> and <code>right</code>, are initialized. <code>left</code> is set to <code>0</code>, and <code>right</code> is set to <code>nums.size() - 1</code>, which represents the range of indices to search within the array.</p> </li> <li> <p>The code enters a <code>while</code> loop that continues as long as <code>left</code> is less than <code>right</code>. This loop aims to narrow down the search range to eventually find the single element.</p> </li> <li> <p>Inside the loop, the code calculates the <code>mid</code> index using the formula <code>(right + left) / 4 * 2</code>. This calculation ensures that <code>mid</code> is even because the elements in the array are sorted in pairs, and you need to compare elements in pairs. The division by 4 followed by multiplication by 2 essentially rounds <code>mid</code> down to the nearest even number.</p> </li> <li> <p>The code checks if the element at index <code>mid</code> is not equal to the element at index <code>mid + 1</code>. If this condition is true, it means that the single element is on the left side of the current <code>mid</code>. Therefore, the code updates <code>right</code> to <code>mid</code>, effectively narrowing the search range to the left half of the array.</p> </li> <li> <p>If the elements at index <code>mid</code> and <code>mid + 1</code> are equal, it means that the single element is on the right side of the current <code>mid</code>. Therefore, the code updates <code>left</code> to <code>mid + 2</code> (skipping the pair of elements). This narrows the search range to the right half of the array.</p> </li> <li> <p>The loop continues to iterate, adjusting the <code>left</code> and <code>right</code> pointers, until they meet. When they meet, <code>left</code> will be pointing to the single element in the array.</p> </li> <li> <p>Finally, the code returns <code>nums[right]</code>, which is the single element found after the binary search.</p> </li> </ol> <p>In summary, this solution uses a binary search approach to efficiently find the single element in the sorted array. It takes advantage of the sorted nature of the array and compares elements in pairs, narrowing down the search range until the single element is located. </p>"},{"location":"source/Binary_Search/540_Single_Element_in_a_Sorted_Array/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime <code>O(logn)</code>, where <code>n = nums.length</code>.</li> <li>Memory <code>O(1)</code>.</li> </ul>"},{"location":"source/Binary_Tree/100_Same_Tree/","title":"Same Tree","text":""},{"location":"source/Binary_Tree/100_Same_Tree/#problem-statement","title":"Problem statement","text":"<p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p> <p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>"},{"location":"source/Binary_Tree/100_Same_Tree/#example-1","title":"Example 1","text":"<pre><code>Input: p = [1,2,3], q = [1,2,3]\nOutput: true\n</code></pre>"},{"location":"source/Binary_Tree/100_Same_Tree/#example-2","title":"Example 2","text":"<pre><code>Input: p = [1,2], q = [1,null,2]\nOutput: false\n</code></pre>"},{"location":"source/Binary_Tree/100_Same_Tree/#example-3","title":"Example 3","text":"<pre><code>Input: p = [1,2,1], q = [1,1,2]\nOutput: false\n</code></pre>"},{"location":"source/Binary_Tree/100_Same_Tree/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in both trees is in the range <code>[0, 100]</code>.</li> <li><code>-10^4 &lt;= Node.val &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Binary_Tree/100_Same_Tree/#solution","title":"Solution","text":"<p>To determine whether two binary trees are the same, you can use a recursive approach that traverses both trees simultaneously. The idea is to compare corresponding nodes in both trees as you traverse them:</p> <ul> <li>Base Case: If both nodes are <code>nullptr</code>, they are considered identical at this position.</li> <li>If one of the nodes is <code>nullptr</code> and the other is not, they are not the same.</li> <li>If both nodes have values but the values differ, the trees are not identical at this point.</li> <li>Recursive Case: If the current nodes are the same, you recursively check the left and right subtrees. The trees are only considered identical if both the left and right subtrees are also identical.</li> </ul> <p>By following this strategy, you ensure that every node in both trees is compared in the same relative position, which determines whether the entire tree structures are the same.</p>"},{"location":"source/Binary_Tree/100_Same_Tree/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) \n    : val(x), left(left), right(right) {}\n};\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (p == nullptr &amp;&amp; q == nullptr) return true;\n    if (p == nullptr || q == nullptr) return false;\n    if (p-&gt;val != q-&gt;val) return false;\n    return (isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right));\n}\nint main() {\n    {   // Example 1\n        TreeNode two1(2);\n        TreeNode three1(3);\n        TreeNode p(1, &amp;two1, &amp;three1);\n        TreeNode two2(2);\n        TreeNode three2(3);\n        TreeNode q(1, &amp;two2, &amp;three2);\n        std::cout &lt;&lt; (isSameTree(&amp;p, &amp;q) ? \"true\" : \"false\") &lt;&lt; std::endl;\n    }\n    {   // Example 2\n        TreeNode two1(2);\n        TreeNode p(1, &amp;two1, nullptr);\n        TreeNode two2(2);\n        TreeNode q(1, nullptr, &amp;two2);\n        std::cout &lt;&lt; (isSameTree(&amp;p, &amp;q) ? \"true\" : \"false\") &lt;&lt; std::endl;\n    }\n    {   // Example 3\n        TreeNode two1(2);\n        TreeNode one1(1);\n        TreeNode p(1, &amp;two1, &amp;one1);\n        TreeNode two2(2);\n        TreeNode one2(1);\n        TreeNode q(1, &amp;one2, &amp;two2);\n        std::cout &lt;&lt; (isSameTree(&amp;p, &amp;q) ? \"true\" : \"false\") &lt;&lt; std::endl;\n    }\n}\n</code></pre> <pre><code>Output:\ntrue\nfalse\nfalse\n</code></pre>"},{"location":"source/Binary_Tree/100_Same_Tree/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n</code> is the size of one tree.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Binary_Tree/100_Same_Tree/#key-takeaway","title":"Key takeaway","text":"<p>This problem highlights the importance of understanding recursion in tree traversal. By breaking down the problem into smaller subproblems: comparing individual nodes and their subtrees, you can effectively determine whether two binary trees are identical. </p> <p>The recursive approach mirrors the tree structure itself, making it an intuitive and powerful technique for tree-related problems.</p> <p>This problem also emphasizes the significance of base cases in recursion. Especially when dealing with data structures like trees where <code>nullptr</code> values play a crucial role in defining the structure. Understanding how to handle these edge cases is key to mastering recursion and tree algorithms.</p>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/","title":"Maximum Depth of Binary Tree","text":""},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#problem-statement","title":"Problem statement","text":"<p>Given the <code>root</code> of a {index}<code>binary tree</code>, return its maximum depth.</p> <p>A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#example-1","title":"Example 1","text":"<pre><code>Input: root = [3,9,20,null,null,15,7]\nOutput: 3\n</code></pre>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#example-2","title":"Example 2","text":"<pre><code>Input: root = [1,null,2]\nOutput: 2\n</code></pre>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the tree is in the range <code>[0, 10^4]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code>.</li> </ul>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#solution","title":"Solution","text":"<p>You have the following recursive relationship between the <code>root</code> and its children.</p> <pre><code>maxDepth(root) = max(maxDepth(root-&gt;left), maxDepth(root-&gt;right))\n</code></pre>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct TreeNode \n{\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) \n    {        \n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) \n    {        \n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n    : val(x), left(left), right(right) \n    {        \n    }\n};\n\nint maxDepth(TreeNode* root) \n{\n    if (root == nullptr) \n    {\n        return 0;\n    }\n    return 1 + max(maxDepth(root-&gt;left), maxDepth(root-&gt;right));\n}\nint main() \n{\n    TreeNode fifteen(15);\n    TreeNode seven(7);\n    TreeNode twenty(20, &amp;fifteen, &amp;seven);\n    TreeNode nine(9);\n    TreeNode three(3, &amp;nine, &amp;twenty);\n    cout &lt;&lt; maxDepth(&amp;three) &lt;&lt; endl;\n    TreeNode two(2);\n    TreeNode one(1, nullptr, &amp;two);\n    cout &lt;&lt; maxDepth(&amp;one) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#code-explanation","title":"Code explanation","text":"<ol> <li> <p>At the beginning of the function, there is a base case check. This condition checks if the current node, represented by <code>root</code>, is a null pointer. If it is, it means that the tree is empty (or a subtree is empty), and the depth at this point is zero. So, the function returns <code>0</code> to indicate that the depth of the current subtree is zero.</p> </li> <li> <p>If the current node is not null (i.e., it's a valid node in the tree), the code proceeds to calculate the maximum depth of the left and right subtrees.</p> </li> <li> <p><code>maxDepth(root-&gt;left)</code> and <code>maxDepth(root-&gt;right)</code> are recursive function calls that calculate the maximum depth of the left and right subtrees, respectively.</p> </li> <li> <p>The <code>std::max</code> function is used to find the maximum depth among the left and right subtrees. Adding <code>1</code> to this maximum depth represents the depth of the current node in the tree.</p> </li> <li> <p>This recursive calculation repeats for each node in the tree until it reaches the base case of a null node, and the recursion unwinds, returning depth values for each subtree.</p> </li> <li> <p>Ultimately, the function returns the maximum depth of the entire binary tree rooted at the given <code>root</code> node.</p> </li> </ol>"},{"location":"source/Binary_Tree/104_Maximum_Depth_of_Binary_Tree/#complexity","title":"Complexity","text":"<p>This solution uses a recursive algorithm to calculate the maximum depth of a binary tree. It starts from the root node and recursively calculates the maximum depth of the left and right subtrees, returning the maximum depth among them. This process continues until it reaches the leaf nodes of the tree. </p> <ul> <li>Runtime: <code>O(n)</code>, where <code>n</code> is the number of nodes.</li> <li>Extra space: <code>O(h)</code>, where <code>h</code> is the height of the tree.</li> </ul>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/","title":"Lowest Common Ancestor of a Binary Search Tree","text":""},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#problem-statement","title":"Problem statement","text":"<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p> <p>According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where a node is allowed to be a descendant of itself).\"</p>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#example-1","title":"Example 1","text":"<pre><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n</code></pre>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#example-2","title":"Example 2","text":"<pre><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.\n</code></pre>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#example-3","title":"Example 3","text":"<pre><code>Input: root = [2,1], p = 2, q = 1\nOutput: 2\n</code></pre>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the tree is in the range <code>[2, 10^5]</code>.</li> <li><code>-10^9 &lt;= Node.val &lt;= 10^9</code>.</li> <li>All <code>Node.val</code> are unique.</li> <li><code>p != q</code>.</li> <li><code>p</code> and <code>q</code> will exist in the BST.</li> </ul>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#solution-recursion","title":"Solution: Recursion","text":"<p>Note that in a BST, the values of a <code>node</code> and its children <code>left</code> and <code>right</code> satisfy</p> <pre><code>left.value &lt; node.value &lt; right.value.\n</code></pre> <p>It lets you know which branch (left or right) of the <code>root</code> the nodes <code>p</code> and <code>q</code> belong to.</p>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val) {\n        return lowestCommonAncestor(root-&gt;left, p, q);\n    } else if (root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) {\n        return lowestCommonAncestor(root-&gt;right, p, q);\n    }\n    return root;\n}\nint main() {\n    TreeNode zero(0);\n    TreeNode three(3);\n    TreeNode five(5);\n    TreeNode four(4);\n    four.left = &amp;three;\n    four.right = &amp;five;\n    TreeNode two(2);\n    two.left = &amp;zero;\n    two.right = &amp;four;\n    TreeNode seven(7);\n    TreeNode nine(9);\n    TreeNode eight(8);\n    eight.left = &amp;seven;\n    eight.right = &amp;nine;\n    TreeNode six(6);\n    six.left = &amp;two;\n    six.right = &amp;eight;\n\n    cout &lt;&lt; lowestCommonAncestor(&amp;six, &amp;two, &amp;eight)-&gt;val &lt;&lt; endl;\n    cout &lt;&lt; lowestCommonAncestor(&amp;six, &amp;two, &amp;four)-&gt;val &lt;&lt; endl;\n    cout &lt;&lt; lowestCommonAncestor(&amp;two, &amp;two, &amp;zero)-&gt;val &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n6\n2\n2\n</code></pre>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#code-explanation","title":"Code explanation","text":"<ol> <li> <p>The function takes three arguments: <code>root</code>, <code>p</code>, and <code>q</code>. <code>root</code> represents the root node of the BST, while <code>p</code> and <code>q</code> represent the two nodes for which you want to find the lowest common ancestor.</p> </li> <li> <p>The code starts with a recursive approach and a divide-and-conquer strategy. It checks whether the values of <code>p</code> and <code>q</code> are less than the value of the current <code>root</code> node or greater than the value of the current <code>root</code> node. These comparisons are made using the values stored in <code>p-&gt;val</code>, <code>q-&gt;val</code>, and <code>root-&gt;val</code>.</p> </li> <li> <p>If both <code>p</code> and <code>q</code> are less than <code>root-&gt;val</code>, it means that both nodes <code>p</code> and <code>q</code> are in the left subtree of the current <code>root</code>. In this case, the code recursively calls <code>lowestCommonAncestor(root-&gt;left, p, q)</code> to search for the LCA in the left subtree.</p> </li> <li> <p>If both <code>p</code> and <code>q</code> are greater than <code>root-&gt;val</code>, it means that both nodes <code>p</code> and <code>q</code> are in the right subtree of the current <code>root</code>. In this case, the code recursively calls <code>lowestCommonAncestor(root-&gt;right, p, q)</code> to search for the LCA in the right subtree.</p> </li> <li> <p>If neither of the above conditions is met, it means that one node is in the left subtree, and the other is in the right subtree, or one of them is the current <code>root</code> node itself. In either case, the current <code>root</code> node is the lowest common ancestor, and the code returns <code>root</code>.</p> </li> <li> <p>The recursion continues until it finds the LCA or reaches a null node (indicating that one of the nodes <code>p</code> or <code>q</code> was not found in the subtree). In the latter case, the code returns <code>root</code>, which might be a valid LCA if one of the nodes is present in the subtree or <code>nullptr</code> if both nodes are not in the tree.</p> </li> </ol>"},{"location":"source/Binary_Tree/235_Lowest_Common_Ancestor_of_a_Binary_Search_Tree/#complexity","title":"Complexity","text":"<p>This solution leverages the properties of a BST, where the left subtree contains nodes with values less than the root, and the right subtree contains nodes with values greater than the root, to efficiently find the lowest common ancestor of two nodes <code>p</code> and <code>q</code>. </p> <ul> <li>Runtime: <code>O(h)</code>, where <code>h</code> is the height of the tree. In a balanced BST, this height is typically <code>log(N)</code> for <code>N</code> nodes.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/","title":"Search in a Binary Search Tree","text":""},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#problem-statement","title":"Problem statement","text":"<p>You are given the <code>root</code> of a binary search tree (BST) and an integer <code>val</code>.</p> <p>Find the node in the BST that the node's value equals <code>val</code> and return the subtree rooted with that node. If such a node does not exist, return <code>null</code>.</p>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#example-1","title":"Example 1","text":"<pre><code>Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]\n</code></pre>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#example-2","title":"Example 2","text":"<pre><code>Input: root = [4,2,7,1,3], val = 5\nOutput: []\n</code></pre>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the tree is in the range <code>[1, 5000]</code>.</li> <li><code>1 &lt;= Node.val &lt;= 10^7</code>.</li> <li><code>root</code> is a binary search tree.</li> <li><code>1 &lt;= val &lt;= 10^7</code>.</li> </ul>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#solution-1-recursive-approach","title":"Solution 1: Recursive approach","text":"<p>To solve this problem, you can leverage the properties of a binary search tree. In a BST, for any given node:</p> <ul> <li> <p>The left subtree contains only nodes with values less than the node's value.</p> </li> <li> <p>The right subtree contains only nodes with values greater than the node's value.</p> </li> </ul> <p>Given this property, you can use a recursive approach to search for the node:</p> <ol> <li>Start at the root node.</li> <li>If the <code>root</code> is <code>null</code>, return <code>null</code> (base case).</li> <li>If the <code>root</code>'s value equals <code>val</code>, return the <code>root</code>.</li> <li>If <code>val</code> is less than the <code>root</code>'s value, recursively search the left subtree.</li> <li>If <code>val</code> is greater than the <code>root</code>'s value, recursively search the right subtree.</li> </ol> <p>This approach ensures that you efficiently find the node or determine that it does not exist in the tree.</p>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\nTreeNode* searchBST(TreeNode* root, int val) {\n    if (root == nullptr || root-&gt;val == val) return root;\n    if (val &lt; root-&gt;val) return searchBST(root-&gt;left, val);\n    return searchBST(root-&gt;right, val);\n}\nvoid printNode(TreeNode* root) {\n    if (root == nullptr) return;\n    std::cout &lt;&lt; root-&gt;val;\n    if (root-&gt;left) {\n        std::cout &lt;&lt; \",\";\n        printNode(root-&gt;left);\n    }\n    if (root-&gt;right)  {\n        std::cout &lt;&lt; \",\";\n        printNode(root-&gt;right);\n    }    \n}\nvoid printTree(TreeNode* root) {\n    std::cout &lt;&lt; \"[\";\n    printNode(root);\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\n\nint main() {\n    TreeNode one(1);\n    TreeNode three(3);\n    TreeNode two(2, &amp;one, &amp;three);\n    TreeNode seven(7);\n    TreeNode four(4, &amp;two, &amp;seven);\n    // Example 1\n    printTree(searchBST(&amp;four, 2));\n    // Example 2\n    printTree(searchBST(&amp;four, 5));\n}\n</code></pre> <pre><code>Output:\n[2,1,3]\n[]\n</code></pre>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(log n)</code>, where <code>n</code> is the number of nodes in the tree. This is because, in the best case, you halve the search space at each step.</li> <li>Extra memory: <code>O(1)</code>as you are not using any additional data structures that grow with the input size.</li> </ul>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#summary","title":"Summary","text":"<ol> <li> <p>Understanding BST Properties: This solution leverages the properties of BSTs to efficiently search for a node. Understanding these properties is crucial for solving similar problems.</p> </li> <li> <p>Recursive Approach: The recursive approach simplifies the problem by breaking it down into smaller subproblems. Each recursive call handles a smaller part of the tree.</p> </li> <li> <p>Base Cases: Handling base cases (e.g., when the root is <code>null</code> or the node is found) is essential to avoid infinite recursion and ensure correct results.</p> </li> </ol>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#solution-2-non-recursive-iterative-approach","title":"Solution 2: Non-recursive (iterative) approach","text":"<p>You can use a loop to traverse the tree instead of recursion.</p>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#code_1","title":"Code","text":"<pre><code>TreeNode* searchBST(TreeNode* root, int val) {\n    while (root != nullptr &amp;&amp; root-&gt;val != val) {\n        if (val &lt; root-&gt;val) {\n            root = root-&gt;left;\n        } else {\n            root = root-&gt;right;\n        }\n    }\n    return root;\n}\n</code></pre>"},{"location":"source/Binary_Tree/700_Search_in_a_Binary_Search_Tree/#key-takeaway","title":"Key takeaway","text":"<ol> <li> <p>Iterative Approach: The iterative approach avoids the overhead of recursive function calls, which can be beneficial in environments with limited stack space.</p> </li> <li> <p>Efficiency: Like the recursive approach, the iterative solution is efficient with a time complexity of <code>O(log n)</code> for balanced trees.</p> </li> <li> <p>Practical Application: Understanding both recursive and iterative approaches provides flexibility in solving tree-related problems, which is valuable in coding interviews and real-world applications.</p> </li> </ol>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/","title":"Find the Duplicate Number","text":"<p>% Medium</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#problem-statement","title":"Problem statement","text":"<p>You have an array of integers called <code>nums</code> that contains <code>n + 1</code> integers. Each integer in the array falls within the range <code>[1, n]</code> inclusive.</p> <p>Within this array, there is only one number that appears more than once. Your task is to find and return this repeated number.</p> <p>Importantly, you must solve this problem without making any modifications to the original array <code>nums</code>, and you are only allowed to use a constant amount of extra space. </p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,3,4,2,2]\nOutput: 2\n</code></pre>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [3,1,3,4,2]\nOutput: 3\n</code></pre>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n &lt;= 10^5</code>.</li> <li><code>nums.length == n + 1</code>.</li> <li><code>1 &lt;= nums[i] &lt;= n</code>.</li> <li>All the integers in <code>nums</code> appear only once except for precisely one integer which appears two or more times.</li> </ul>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#follow-up","title":"Follow up","text":"<ul> <li>How can we prove that at least one duplicate number must exist in <code>nums</code>?</li> <li>Can you solve the problem in linear runtime complexity?</li> </ul>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#solution-1-indexsorting","title":"Solution 1: {index}<code>Sorting</code>","text":""},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint findDuplicate(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i &lt; nums.size() - 1; i++) {\n        if (nums[i] == nums[i + 1]) {\n            return nums[i];\n        }\n    }\n    return 0;\n}\nint main() {\n    vector&lt;int&gt; nums{1,3,4,2,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n    nums = {3,1,3,4,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n3\n</code></pre> <p>The code relies on sorting to bring duplicate elements together, making it easy to identify them during the linear pass.</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*logn)</code> (sorting).</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#follow-up_1","title":"Follow up","text":""},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#how-can-you-prove-that-at-least-one-duplicate-number-must-exist-in-nums","title":"How can you prove that at least one duplicate number must exist in <code>nums</code>?","text":"<p>Due to Pigeonhole principle:</p> <p>Here there are <code>n + 1</code> pigeons in <code>n</code> holes. The pigeonhole principle says that at least one hole has more than one pigeon.</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#can-you-solve-the-problem-in-linear-runtime-complexity","title":"Can you solve the problem in linear runtime complexity?","text":"<p>Here are a few solutions.</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#solution-2-marking-the-visited-numbers","title":"Solution 2: Marking the visited numbers","text":""},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint findDuplicate(const vector&lt;int&gt;&amp; nums) {\n    // initialize n + 1 elements false\n    vector&lt;bool&gt; visited(nums.size());\n    for (auto&amp; a : nums) {        \n        if (visited.at(a)) {\n            return a;\n        }\n        visited[a] = true;\n    }\n    return 0;\n}\nint main() {\n    vector&lt;int&gt; nums{1,3,4,2,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n    nums = {3,1,3,4,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n3\n</code></pre> <p>This solution utilizes a boolean array <code>visited</code> to track visited elements. </p> <p>It iterates through the elements of the input vector <code>nums</code>, marking each element as visited by setting the corresponding index in the <code>visited</code> array to true. Upon encountering a visited element, it immediately returns it as the duplicate element. </p> <p>This approach efficiently identifies the duplicate element in the vector by tracking visited elements without requiring additional space proportional to the size of the input vector.</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>.</li> <li>Extra space: much less than <code>O(n)</code> since  <code>std::vector&lt;bool&gt;</code> is optimized for space-efficient. </li> </ul>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#solution-3-marking-with-indexstdbitset","title":"Solution 3: Marking with {index}<code>std::bitset</code>","text":"<p>Since <code>n &lt;= 10^5</code>, you can use this size for a <code>std::bitset</code> to do the marking. </p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#code_2","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;bitset&gt;\nusing namespace std;\nint findDuplicate(const vector&lt;int&gt;&amp; nums) {\n    // initialize visited = '000..0' with 100001 bits 0\n    bitset&lt;100001&gt; visited;\n    for (auto&amp; a : nums) {\n        if (visited[a]) {\n            return a;\n        }\n        // set a-th bit to 1\n        visited[a] = 1;\n    }\n    return 0;\n}\nint main() {\n    vector&lt;int&gt; nums{1,3,4,2,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n    nums = {3,1,3,4,2};\n    cout &lt;&lt; findDuplicate(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n3\n</code></pre> <p>This code uses a bitset to keep track of visited elements and quickly detects any duplicate element encountered during the iteration.</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>.</li> <li>Extra space: <code>O(1)</code>. </li> </ul>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#key-takeaway","title":"Key Takeaway","text":"<p>Different strategies can be employed to detect duplicates in an array, such as sorting followed by linear search, using a hash set to track visited elements, or utilizing a bitset to mark visited indices. </p> <p>Each approach has its trade-offs in terms of time complexity, space complexity, and implementation simplicity. To me, Solution 2 balances all the trade-offs. What do you think?</p>"},{"location":"source/Bit_Manipulation/287_Find_the_Duplicate_Number/#exercise","title":"Exercise","text":"<ul> <li>Missing Number.</li> </ul>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/","title":"Maximum Product of Word Lengths","text":"<p>% Medium</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#problem-statement","title":"Problem statement","text":"<p>Given a string array <code>words</code>, return the maximum value of <code>length(word[i]) * length(word[j])</code> where the two words do not share common letters. If no such two words exist, return <code>0</code>.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#example-1","title":"Example 1","text":"<pre><code>Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\n</code></pre>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#example-2","title":"Example 2","text":"<pre><code>Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\n</code></pre>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#example-3","title":"Example 3","text":"<pre><code>Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\n</code></pre>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#constraints","title":"Constraints","text":"<ul> <li><code>2 &lt;= words.length &lt;= 1000</code>.</li> <li><code>1 &lt;= words[i].length &lt;= 1000</code>.</li> <li><code>words[i]</code> consists only of lowercase English letters.</li> </ul>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":"<p>For each <code>words[i]</code>, for all <code>words[j]</code> with <code>j &gt; i</code>, check if they do not share common letters and compute the product of their lengths.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint maxProduct(const vector&lt;string&gt;&amp; words) {\n    int maxP = 0;\n    for (int i = 0; i &lt; words.size(); i++) {\n        // visited marks all letters that appear in words[i] \n        // words[i] consists of only 26 lowercase English letters\n        vector&lt;bool&gt; visited(26, false);\n        for (auto&amp; c : words[i]) {\n            // map 'a'-&gt;0, 'b'-&gt;1, .., 'z'-&gt;25\n            visited[c - 'a'] = true;\n        }\n        // compare with all other words[j]         \n        for (int j = i + 1; j &lt; words.size(); j++) {\n            bool found = false;\n            for (auto&amp; c : words[j]) {              \n                if (visited[c - 'a']) {\n                    // this words[j] has common letter with words[i]\n                    found = true;\n                    break;\n                }\n            }\n            // if words[j] disjoints words[i]\n            if (!found) {\n                // compute and update max product of their lengths\n                maxP = max(maxP, (int) (words[i].length() * words[j].length()));\n            } \n        }\n    }\n    return maxP;\n}\nint main() {\n    vector&lt;string&gt; words{\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n    words = {\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n    words = {\"a\",\"aa\",\"aaa\",\"aaaa\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n16\n4\n0\n</code></pre> <p>This solution checks for common characters between pairs of words to determine their product of lengths. </p> <p>It iterates through each pair of words in the input vector <code>words</code>, maintaining a boolean array <code>visited</code> to mark the presence of characters in each word. By comparing the characters of each pair of words, it identifies whether there are any common characters. If no common characters are found, it computes the product of the lengths of the two words and updates the maximum product accordingly. </p> <p>This approach optimizes the computation of the maximum product by efficiently checking for common characters between pairs of words without requiring additional space proportional to the length of the words.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2 * m)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#solution-2-checking-common-letters-using-indexbit-masking","title":"Solution 2: Checking common letters using {index}<code>bit masking</code>","text":"<p>You can map a <code>words[i]</code> to the bit representation of an integer <code>n</code> by their characters like the following:</p> <ul> <li>If the word <code>words[i]</code> contains the letter <code>'a'</code>, the bit at position <code>0</code> of <code>n</code> is <code>1</code>.</li> <li>If the word <code>words[i]</code> contains the letter <code>'b'</code>, the bit at position <code>1</code> of <code>n</code> is <code>1</code>.</li> <li>...</li> <li>If the word <code>words[i]</code> contains the letter <code>'z'</code>, the bit at position <code>25</code> of <code>n</code> is <code>1</code>.</li> </ul> <p>Then to check if two words have common letters, you just perform the bitwise operator AND on them.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#example-1_1","title":"Example 1:","text":"<ul> <li>The word <code>\"abcw\"</code> is mapped to <code>00010000000000000000000111</code>.</li> <li>The word <code>\"baz\"</code> is mapped to <code>10000000000000000000000011</code>.</li> <li><code>\"abcw\" &amp; \"baz\" = 00000000000000000000000011</code>. This value is not zero, which means they have common letters.</li> </ul> <p>This technique is called bit masking.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint maxProduct(const vector&lt;string&gt;&amp; words) {\n    int maxP = 0;\n    // initialize all elements of mask to 0\n    vector&lt;int&gt; mask(words.size());\n    for (int i = 0; i &lt; words.size(); i++) {\n        // mark all characters of word[i]\n        for (auto&amp; c : words[i]) {\n            // map 'a'-&gt;0, 'b'-&gt;1, .., 'z'-&gt;25\n            // set the bit at that mapped position of mask[i] to 1\n            mask[i] |= 1 &lt;&lt; (c - 'a');\n        }        \n        for (int j = 0; j &lt; i; j++) {\n            if ((mask[j] &amp; mask[i]) == 0) {\n                // there is no common bit between mask[j] and mask[i]\n                maxP = max(maxP, (int) (words[i].length() * words[j].length()));\n            } \n        }\n    }\n    return maxP;\n}\nint main() {\n    vector&lt;string&gt; words{\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n    words = {\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n    words = {\"a\",\"aa\",\"aaa\",\"aaaa\"};\n    cout &lt;&lt; maxProduct(words) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n16\n4\n0\n</code></pre> <p>This solution represents each word in the input vector <code>words</code> as a bitmask, where each bit represents the presence or absence of a character in the word. </p> <p>By iterating through the words and constructing their corresponding bitmasks, it encodes the character information. Then, by comparing the bitmasks of pairs of words, it identifies whether there are any common characters between them. If no common characters are found, it computes the product of the lengths of the two words and updates the maximum product accordingly. </p> <p>This approach optimizes the computation of the maximum product by using bitwise operations to efficiently check for common characters between pairs of words without requiring additional space proportional to the length of the words.</p>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of words in the input vector.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/318_Maximum_Product_of_Word_Lengths/#tips","title":"Tips","text":"<p>Utilizing bit manipulation techniques, such as bitmasking, can significantly optimize the comparison process for determining common characters between words. </p> <p>Solution 2 reduces the time complexity compared to brute force methods, particularly when dealing with large datasets, as it avoids nested loops and unnecessary character comparisons.</p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/","title":"Power of Four","text":"<p>% Easy </p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#problem-statement","title":"Problem statement","text":"<p>Given an integer <code>n</code>, return <code>true</code> if it is a power of four. Otherwise, return <code>false</code>.</p> <p>An integer <code>n</code> is a power of four if there exists an integer <code>x</code> such that <code>n == 4^x</code>.</p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#example-1","title":"Example 1","text":"<pre><code>Input: n = 16\nOutput: true\n</code></pre>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#example-2","title":"Example 2","text":"<pre><code>Input: n = 5\nOutput: false\n</code></pre>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#example-3","title":"Example 3","text":"<pre><code>Input: n = 1\nOutput: true\n</code></pre>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#constraints","title":"Constraints","text":"<ul> <li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#follow-up","title":"Follow up","text":"<ul> <li>Could you solve it without loops/recursion?</li> </ul>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#solution-1-division-by-four","title":"Solution 1: Division by four","text":""},{"location":"source/Bit_Manipulation/342_Power_of_Four/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nbool isPowerOfFour(int n) {\n    // perform the divison by 4 repeatedly\n    while (n % 4 == 0 &amp;&amp; n &gt; 0) {\n        n /= 4;\n    }\n    // if n % 4 != 0, then n &gt; 1\n    return n == 1;\n}\nint main() \n{\n    cout &lt;&lt; isPowerOfFour(16) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfFour(5) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfFour(1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre> <p>This solution repeatedly divides the given number <code>n</code> by 4 until <code>n</code> becomes either 1 or a number that is not divisible by 4. If <code>n</code> becomes 1 after this process, it means that <code>n</code> was originally a power of 4. </p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(logn)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#solution-2-binary-representation","title":"Solution 2: Binary representation","text":"<p>You can write down the binary representation of the powers of four to find the pattern.</p> <pre><code>1   : 1\n4   : 100\n16  : 10000\n64  : 1000000\n256 : 100000000\n...\n</code></pre> <p>You might notice the patterns are n is a positive integer having only one bit <code>1</code> in its binary representation and it is located at the odd positions (starting from the right).</p> <p>How can you formulate those conditions?</p> <p>If <code>n</code> has only one bit <code>1</code> in its binary representation <code>10...0</code>, then <code>n - 1</code> has the complete opposite binary representation <code>01...1</code>. </p> <p>You can use the bit operator AND to formulate this condition</p> <pre><code>n &amp; (n - 1) == 0\n</code></pre> <p>Let <code>A</code> be the number whose binary representation has only bits <code>1</code> at all odd positions, then <code>n &amp; A</code> is never <code>0</code>.</p> <p>In this problem, <code>A &lt; 2^31</code>. You can choose<code>A = 0x55555555</code>, the hexadecimal of <code>0101 0101 0101 0101 0101 0101 0101 0101</code>.</p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nbool isPowerOfFour(int n) {\n    // the condition of the pattern \"n is a positive integer \n    // having only one bit 1 in its binary representation and \n    // it is located at the odd positions\"\n    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0 &amp;&amp; (n &amp; 0x55555555) != 0;\n}\nint main() {\n    cout &lt;&lt; isPowerOfFour(16) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfFour(5) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfFour(1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(1)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#conclusion","title":"Conclusion","text":"<p>Recognizing the unique properties of powers of four, such as their binary representation, can lead to efficient solutions. Solution 2 leverages bitwise operations to check if a number meets the criteria of being a power of four. </p> <p>By examining the binary representation and ensuring that the only set bit is located at an odd position, Solution 2 effectively determines whether the number is a power of four in constant time complexity, without the need for division operations.</p> <p>But in term of readable code, Solution 2 is not easy to understand like Solution 1, where complexity of <code>O(logn)</code> is not too bad.</p>"},{"location":"source/Bit_Manipulation/342_Power_of_Four/#exercise","title":"Exercise","text":"<ul> <li>Power of Two.</li> </ul>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/","title":"Hamming Distance","text":"<p>% Easy </p>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#problem-statement","title":"Problem statement","text":"<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p> <p>Given two integers <code>x</code> and <code>y</code>, return the Hamming distance between them.</p>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#example-1","title":"Example 1","text":"<pre><code>Input: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ^   ^\nThe above arrows point to positions where the corresponding bits are different.\n</code></pre>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#example-2","title":"Example 2","text":"<pre><code>Input: x = 3, y = 1\nOutput: 1\n</code></pre>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= x, y &lt;= 2^31</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#solution-using-bitwise-operator-xor","title":"Solution: Using bitwise operator XOR","text":"<p>You could use {index}<code>bitwise XOR</code> (<code>^</code>) to get the bit positions where <code>x</code> and <code>y</code> are different. Then use {index}<code>bitwise AND</code> operator (<code>&amp;</code>) at each position to count them.</p>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#example-1_1","title":"Example 1","text":"<pre><code>x = 1   (0 0 0 1)\ny = 4   (0 1 0 0)\nz = x^y (0 1 0 1)\n</code></pre>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nint hammingDistance(int x, int y) {\n    // compute the bit difference \n    int z = x ^ y;\n    int count = 0;\n    while (z) {\n        count += z &amp; 1; // e.g. '0101' &amp; '0001'\n        // shift z to the right one position\n        z = z &gt;&gt; 1; // e.g. z = '0101' &gt;&gt; '0010'\n    }\n    return count;\n}\nint main() {\n    std::cout &lt;&lt; hammingDistance(1,4) &lt;&lt; std::endl; // 2\n    std::cout &lt;&lt; hammingDistance(1,3) &lt;&lt; std::endl; // 1\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(1)</code> as the number of bits is at most 32 as constrained.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#conclusion","title":"Conclusion","text":"<p>Utilizing bitwise operations, such as XOR (^) and bitwise AND (&amp;), allows for efficient computation of the Hamming distance between two integers. This approach provides a straightforward and efficient method for calculating the Hamming distance without the need for complex logic or additional data structures.</p>"},{"location":"source/Bit_Manipulation/461_Hamming_Distance/#exercise","title":"Exercise","text":"<ul> <li>Number of 1 Bits.</li> </ul>"},{"location":"source/Counting/136_Single_Number/","title":"Single Number","text":"<p>% Easy</p>"},{"location":"source/Counting/136_Single_Number/#problem-statement","title":"Problem statement","text":"<p>You're provided with a non-empty array of integers called <code>nums</code>. In this array, every element occurs twice except for one element that appears only once. Your task is to identify and find that unique element.</p> <p>To solve this problem, your solution needs to have a linear runtime complexity and utilize only a constant amount of extra space.</p>"},{"location":"source/Counting/136_Single_Number/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [2,2,1]\nOutput: 1\n</code></pre>"},{"location":"source/Counting/136_Single_Number/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [4,1,2,1,2]\nOutput: 4\n</code></pre>"},{"location":"source/Counting/136_Single_Number/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [1]\nOutput: 1\n</code></pre>"},{"location":"source/Counting/136_Single_Number/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code>.</li> <li><code>-3 * 10^4 &lt;= nums[i] &lt;= 3 * 10^4</code>.</li> <li>Each element in the array appears twice except for one element which appears only once.</li> </ul>"},{"location":"source/Counting/136_Single_Number/#solution-1-counting-the-appearances","title":"Solution 1: Counting the appearances","text":"<p>Count how many times each element appears in the array. Then return the one appearing only once.</p>"},{"location":"source/Counting/136_Single_Number/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint singleNumber(const vector&lt;int&gt;&amp; nums) {\n    unordered_map&lt;int, int&gt; count;\n    for (auto&amp; n : nums) {\n        count[n]++;\n    }\n    int single;\n    for (auto&amp; pair : count) {\n        if (pair.second == 1) {\n            single = pair.first;\n            break;\n        }\n    }\n    return single;\n}\nint main() {\n    vector&lt;int&gt; nums{2,2,1};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n    nums = {4,1,2,1,2};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n    nums = {1};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n4\n1\n</code></pre> <p>This solution effectively finds the single number by counting the occurrences of each element in the array and selecting the one with a count of 1.</p>"},{"location":"source/Counting/136_Single_Number/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Counting/136_Single_Number/#solution-2-bitwise-exclusive-or","title":"Solution 2: Bitwise exclusive OR","text":"<p>You can also use the {index}<code>bitwise XOR</code> operator to cancel out the duplicated elements in the array. The remain element is the single one.</p> <pre><code>a XOR a = 0.\na XOR 0 = a.\n</code></pre>"},{"location":"source/Counting/136_Single_Number/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint singleNumber(const vector&lt;int&gt;&amp; nums) {\n    int single = 0;\n    for (auto&amp; n : nums) {\n        single ^= n;\n    }\n    return single;\n}\nint main() {\n    vector&lt;int&gt; nums{2,2,1};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n    nums = {4,1,2,1,2};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n    nums = {1};\n    cout &lt;&lt; singleNumber(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n4\n1\n</code></pre>"},{"location":"source/Counting/136_Single_Number/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Counting/136_Single_Number/#conclusion","title":"Conclusion","text":"<p>Leveraging bitwise XOR (^) operations offers an efficient solution to find the single number in an array. Solution 2 utilizes the property of XOR where XORing a number with itself results in 0. </p> <p>By XORing all the numbers in the array, Solution 2 effectively cancels out pairs of identical numbers, leaving only the single number behind. This approach achieves a linear time complexity without the need for additional data structures, providing a concise and efficient solution.</p>"},{"location":"source/Counting/136_Single_Number/#exercise","title":"Exercise","text":"<ul> <li>Missing Number.</li> </ul>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/","title":"Max Number of K-Sum Pairs","text":"<p>% Medium</p>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#problem-statement","title":"Problem statement","text":"<p>You're provided with an array of integers called <code>nums</code> and an integer <code>k</code>. Each operation involves selecting two numbers from the array whose sum is equal to <code>k</code>, and then removing them from the array. Your goal is to determine the maximum count of such operations you can perform on the array. </p>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3,4], k = 5\nOutput: 2\nExplanation: Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.\n</code></pre>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [3,1,3,4,3], k = 6\nOutput: 1\nExplanation: Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3's, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation.\n</code></pre>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>1 &lt;= nums[i] &lt;= 10^9</code>.</li> <li><code>1 &lt;= k &lt;= 10^9</code>.</li> </ul>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#solution-count-the-appearances","title":"Solution: Count the appearances","text":"<p>You can use a map to count the appearances of the elements of <code>nums</code>.</p>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#example-2_1","title":"Example 2","text":"<p>For <code>nums = [3,1,3,4,3]</code> and <code>k = 6</code>:</p> <ul> <li>Initialize <code>count = 0</code>.</li> <li>For <code>i = 0</code>: <code>m[3] = 1</code>; <code>k - 3 = 3</code> but <code>m[3]</code> is only <code>1</code>, not enough to have two numbers.</li> <li>For <code>i = 1</code>: <code>m[1] = 1</code>; <code>k - 1 = 5</code> and <code>m[5] = 0</code>.</li> <li>For <code>i = 2</code>: <code>m[3] = 2</code>; <code>k - 3 = 3</code> and <code>m[3] = 2</code> just enough to have two numbers to perform the sum. <code>count = 1</code>. Erase those two values <code>3</code>'s from the map: <code>m[3] = 0</code>.</li> <li>For <code>i = 3</code>: <code>m[4] = 1</code>; <code>k - 4 = 2</code> and <code>m[2] = 0</code>.</li> <li>For <code>i = 4</code>: <code>m[3] = 1</code>; <code>k - 3 = 3</code> but <code>m[3]</code> is only <code>1</code>, not enough to have two numbers.</li> <li>Final <code>count = 1</code>.</li> </ul>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint maxOperations(const vector&lt;int&gt;&amp; nums, int k) {\n    unordered_map&lt;int,int&gt; m;\n    int count = 0;\n    for (auto&amp; a : nums) {\n        m[a]++; // count a's occurences\n        if (m[k - a] &gt; 0) {\n            // k-a appears in nums\n            if (a != k - a || m[a] &gt;= 2) {\n                // if a == k - a, a is required to appear at least twice\n                count++;\n                m[a]--;\n                m[k - a]--;\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3,4};\n    cout &lt;&lt; maxOperations(nums, 5) &lt;&lt; endl;\n    nums = {3,1,3,4,3};\n    cout &lt;&lt; maxOperations(nums, 6) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n</code> is the number of elements in the <code>nums</code> array.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#conclusion","title":"Conclusion","text":"<p>This solution utilizes an unordered map to store the frequency of each element encountered while iterating through <code>nums</code>. </p> <p>By examining each element <code>a</code> in <code>nums</code>, it checks if <code>k - a</code> exists in the map and if its frequency is greater than 0. If so, it increments the count of pairs and decrements the frequency of both <code>a</code> and <code>k - a</code>, ensuring that each pair is counted only once. </p> <p>This approach optimizes the computation by efficiently tracking the frequencies of elements and identifying valid pairs whose sum equals the target value without requiring additional space proportional to the size of the array.</p>"},{"location":"source/Counting/1679_Max_Number_of_K-Sum_Pairs/#exercise","title":"Exercise","text":"<ul> <li>Two Sum.</li> </ul>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/","title":"First Unique Character in a String","text":"<p>% Easy</p>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#problem-statement","title":"Problem statement","text":"<p>You have a string called <code>s</code>. Your objective is to locate the index of the first character in the string that does not repeat anywhere else in the string. If such a character doesn't exist, return <code>-1</code>.</p>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"leetcode\"\nOutput: 0\n</code></pre>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"loveleetcode\"\nOutput: 2\n</code></pre>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"aabb\"\nOutput: -1\n</code></pre>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length &lt;= 10^5</code>.</li> <li><code>s</code> consists of only lowercase English letters.</li> </ul>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#solution-1-using-a-map-to-store-the-appearances","title":"Solution 1: Using a map to store the appearances","text":""},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint firstUniqChar(const string&amp; s) {\n    unordered_map&lt;char, int&gt; count;\n    for (auto&amp; c : s) {\n        count[c]++;\n    }\n    for (int i = 0; i &lt; s.length(); i++) {\n        if (count[s[i]] == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\nint main() {\n    cout &lt;&lt; firstUniqChar(\"leetcode\") &lt;&lt; endl;\n    cout &lt;&lt; firstUniqChar(\"loveleetcode\") &lt;&lt; endl;\n    cout &lt;&lt; firstUniqChar(\"aabb\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n2\n-1\n</code></pre> <p>This solution finds the index of the first non-repeating character in a string by using an unordered map to count the occurrences of each character. </p> <p>By iterating through the string and populating the unordered map with the count of each character, it constructs the character count. Then, it iterates through the string again and returns the index of the first character with a count of 1, indicating that it is non-repeating. </p> <p>This approach optimizes the computation by efficiently tracking the count of each character and identifying the first non-repeating character without requiring additional space proportional to the length of the string.</p>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n</code> is the length of the string <code>s</code>.</li> <li>Extra space: <code>O(1)</code> as the problem considers only 26 lowercase English letters.</li> </ul>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#solution-2-using-an-array-to-store-the-appearances","title":"Solution 2: Using an array to store the appearances","text":"<p>From the constraints \"<code>s</code> consists of only lowercase English letters\", you can use an array of 26 elements to store the counts.</p>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint firstUniqChar(const string&amp; s) {\n    // map 'a'-&gt;0, 'b'-&gt;1, .., 'z'-&gt;25\n    // initializes an array of 26 elements, all set to zero\n    std::array&lt;int, 26&gt; count{};\n    for (auto&amp; c : s) {\n        count[c - 'a']++;\n    }\n    for (int i = 0; i &lt; s.length(); i++) {\n        if (count[s[i] - 'a'] == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\nint main() {\n    cout &lt;&lt; firstUniqChar(\"leetcode\") &lt;&lt; endl;\n    cout &lt;&lt; firstUniqChar(\"loveleetcode\") &lt;&lt; endl;\n    cout &lt;&lt; firstUniqChar(\"aabb\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n2\n-1\n</code></pre>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = s.length</code>.</li> <li>Extra space: <code>O(1)</code> as the array is fixed regardless of how big <code>n</code> is.</li> </ul>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#conclusion","title":"Conclusion","text":"<p>Utilizing hash maps or arrays to count the frequency of characters in a string provides an efficient way to identify the first unique character. Both solutions use this approach to iterate through the string and count the occurrences of each character. </p> <p>By storing the counts in a data structure indexed by the character value, the solutions achieve a linear time complexity proportional to the length of the string. Solution 2 further optimizes memory usage by employing an array with a fixed size corresponding to the lowercase English alphabet, avoiding the overhead associated with hash maps.</p>"},{"location":"source/Counting/387_First_Unique_Character_in_a_String/#exercise","title":"Exercise","text":"<ul> <li>First Letter to Appear Twice.</li> </ul>"},{"location":"source/Dynamic_Programming/120_Triangle/","title":"Triangle","text":""},{"location":"source/Dynamic_Programming/120_Triangle/#problem-statement","title":"Problem statement","text":"<p>You're provided with a <code>triangle</code> array. Your goal is to find the smallest possible sum of a path from the top of the triangle to the bottom.</p> <p>At each step, you have the option to move to an adjacent number in the row below. Specifically, if you're at index <code>i</code> in the current row, you can move to either index <code>i</code> or index <code>i + 1</code> in the next row. </p>"},{"location":"source/Dynamic_Programming/120_Triangle/#example-1","title":"Example 1","text":"<pre><code>Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n</code></pre>"},{"location":"source/Dynamic_Programming/120_Triangle/#example-2","title":"Example 2","text":"<pre><code>Input: triangle = [[-10]]\nOutput: -10\n</code></pre>"},{"location":"source/Dynamic_Programming/120_Triangle/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= triangle.length &lt;= 200</code>.</li> <li><code>triangle[0].length == 1</code>.</li> <li><code>triangle[i].length == triangle[i - 1].length + 1</code>.</li> <li><code>-10^4 &lt;= triangle[i][j] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/120_Triangle/#follow-up","title":"Follow up","text":"<ul> <li>Could you do this using only <code>O(n)</code> extra space, where <code>n</code> is the total number of rows in the triangle?</li> </ul>"},{"location":"source/Dynamic_Programming/120_Triangle/#solution-1-store-all-minimum-paths","title":"Solution 1: Store all minimum paths","text":"<p>You can store all minimum paths at every positions <code>(i,j)</code> so you can compute the next ones with this relationship.</p> <pre><code>minPath[i][j] = triangle[i][j] + min(minPath[i - 1][j - 1], minPath[i - 1][j]);\n</code></pre>"},{"location":"source/Dynamic_Programming/120_Triangle/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint minimumTotal(const vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n    const int n = triangle.size(); // triangle's height\n    vector&lt;vector&lt;int&gt;&gt; minPath(n);\n    minPath[0] = triangle[0];\n    for (int i = 1; i &lt; n; i++) {\n        const int N = triangle[i].size();\n        minPath[i].resize(N);\n        // left most number\n        minPath[i][0] = triangle[i][0] + minPath[i-1][0];\n        for (int j = 1; j &lt; N - 1; j++) {\n            minPath[i][j] = triangle[i][j] + min(minPath[i-1][j-1], minPath[i-1][j]);\n        }\n        // right most number\n        minPath[i][N-1] = triangle[i][N-1] + minPath[i-1][N-2];\n\n    }\n    // pick the min path among the ones (begin -&gt; end)\n    // go to the bottom (n-1)\n    return *min_element(minPath[n-1].begin(), minPath[n-1].end());\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; triangle{{2},{3,4},{6,5,7},{4,1,8,3}};\n    cout &lt;&lt; minimumTotal(triangle) &lt;&lt; endl;\n    triangle = {{-10}};\n    cout &lt;&lt; minimumTotal(triangle) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n11\n-10\n</code></pre> <p>This solution finds the minimum path sum from the top to the bottom of a triangle, represented as a vector of vectors. It uses dynamic programming to calculate the minimum path sum.</p> <p>The algorithm initializes a <code>minPath</code> vector of vectors to store the minimum path sum for each element in the <code>triangle</code>. It starts by setting the first row of <code>minPath</code> to be the same as the first row of the <code>triangle</code>.</p> <p>Then, it iterates through the rows of the <code>triangle</code> starting from the second row. For each element in the current row, it calculates the minimum path sum by considering the two possible paths from the previous row that lead to that element. It takes the minimum of the two paths and adds the value of the current element. This way, it accumulates the minimum path sum efficiently.</p> <p>The algorithm continues this process until it reaches the last row of the <code>triangle</code>. Finally, it returns the minimum element from the last row of <code>minPath</code>, which represents the minimum path sum from top to bottom.</p>"},{"location":"source/Dynamic_Programming/120_Triangle/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of rows in the <code>triangle</code>.</li> <li>Extra space: <code>O(n^2)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/120_Triangle/#solution-2-store-only-the-minimum-paths-of-each-row","title":"Solution 2: Store only the minimum paths of each row","text":"<p>You do not need to store all paths for all rows. The computation of the next row only depends on its previous one.</p>"},{"location":"source/Dynamic_Programming/120_Triangle/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint minimumTotal(const vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {\n    const int n = triangle.size();\n    // store only min path for each row\n    vector&lt;int&gt; minPath(n);\n    minPath[0] = triangle[0][0];\n    for (int i = 1; i &lt; n; i++) {\n        // right most number\n        minPath[i] = triangle[i][i] + minPath[i - 1];\n        for (int j = i - 1; j &gt; 0; j--) {\n            minPath[j] = triangle[i][j] + min(minPath[j - 1], minPath[j]);\n        }\n        // left most number\n        minPath[0] = triangle[i][0] + minPath[0];\n    }\n    return *min_element(minPath.begin(), minPath.end());\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; triangle{{2},{3,4},{6,5,7},{4,1,8,3}};\n    cout &lt;&lt; minimumTotal(triangle) &lt;&lt; endl;\n    triangle = {{-10}};\n    cout &lt;&lt; minimumTotal(triangle) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n11\n-10\n</code></pre>"},{"location":"source/Dynamic_Programming/120_Triangle/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of rows in the triangle.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/","title":"Largest Divisible Subset","text":""},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#problem-statement","title":"Problem statement","text":"<p>You have a collection of positive integers called <code>nums</code>, where each integer is distinct. Your task is to find the largest subset <code>answer</code> from this collection, such that for every pair of elements <code>(answer[i], answer[j])</code> within this subset:</p> <ul> <li>Either <code>answer[i]</code> is a multiple of <code>answer[j]</code> (i.e., <code>answer[i] % answer[j] == 0</code>), or</li> <li><code>answer[j]</code> is a multiple of <code>answer[i]</code> (i.e., <code>answer[j] % answer[i] == 0</code>).</li> </ul> <p>If there are multiple possible solutions, you can return any of them.</p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] is also accepted.\n</code></pre>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,2,4,8]\nOutput: [1,2,4,8]\n</code></pre>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 1000</code>.</li> <li><code>1 &lt;= nums[i] &lt;= 2 * 10^9</code>.</li> <li>All the integers in <code>nums</code> are unique.</li> </ul>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#solution-1-bruteforce-with-dynamic-programming","title":"Solution 1: Bruteforce with Dynamic programming","text":"<p>Note that the condition <code>a % b == 0</code> is called <code>a</code> is divisible by <code>b</code>. In mathematics, it can also be called <code>b</code> divides <code>a</code> and be written as <code>b | a</code>.</p> <p>The symmetry of the divisibility criteria means it does not count the ordering of the <code>answer</code>. You could sort the vector <code>nums</code> before trying to find the longest subset <code>answer = [answer[0], answer[1], ..., answer[m]]</code> where <code>answer[i] | answer[j]</code> with all <code>0 &lt;= i &lt;= j &lt;= m</code>.</p> <p>Now assuming the <code>nums</code> were sorted. For each <code>i</code>, you need to find the largest subset <code>maxSubset[i]</code> starting from <code>nums[i]</code>. And the final answer is the largest one among them. </p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [2, 4, 3, 9, 8].\nSorted nums = [2, 3, 4, 8, 9]. \nmaxSubset[0] = [2, 4, 8].\nmaxSubset[1] = [3, 9].\nmaxSubset[2] = [4, 8].\nmaxSubset[3] = [8].\nmaxSubset[4] = [9].\nOutput: [2, 4, 8].\n</code></pre> <p>Note that for a sorted <code>nums</code>, if <code>nums[i] | nums[j]</code> for some <code>i &lt; j</code>, then <code>maxSubset[j]</code> is a subset of <code>maxSubset[i]</code>. </p> <p>For example, <code>maxSubset[2]</code> is a subset of <code>maxSubset[0]</code> in Example 3 because <code>nums[0] = 2 | 4 = nums[2]</code>.</p> <p>That might lead to some unnecessary recomputing. To avoid it, you could use dynamic programming to store the <code>maxSubset[j]</code> you have already computed.</p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n//! @return the max divisible subset starting from nums[i] \n//!         and store it to _map[i]\n//! @param nums a sorted array of unique positive integers \nvector&lt;int&gt; largestDivisibleSubsetOf(vector&lt;int&gt;&amp; nums, \n            int i, unordered_map&lt;int, vector&lt;int&gt; &gt;&amp; _map) {\n    if (_map.find(i) != _map.end()) {\n        // already computed!\n        return _map[i];\n    }\n    vector&lt;int&gt; maxSubset{nums[i]}; // start with nums[i]\n    if (i == nums.size() - 1) {\n        // largest value in nums\n        _map.insert({i, maxSubset});\n        return maxSubset;\n    }\n    for (int j = i + 1; j &lt; nums.size(); j++) {\n        if (nums[j] % nums[i] == 0) {\n            // compute the max divisble subset starting from nums[j]\n            auto subset = largestDivisibleSubsetOf(nums, j, _map);\n\n            // add nums[i] to subset as it might become maxSubset\n            subset.push_back(nums[i]);\n            if (maxSubset.size() &lt; subset.size()) {\n                // update maxSubset\n                maxSubset = subset;\n            }\n        }\n    }\n    // store what have been calculated in _map\n    _map.insert({i, maxSubset});\n    return maxSubset;\n}\nvector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {\n    if (nums.size() &lt;= 1) {\n        return nums; \n    } \n    unordered_map&lt;int, vector&lt;int&gt; &gt; _map;\n    sort(nums.begin(), nums.end());\n    vector&lt;int&gt; answer;\n    for (int i = 0; i &lt; nums.size(); i++) {\n        auto maxSubset = largestDivisibleSubsetOf(nums, i, _map);\n        if (answer.size() &lt; maxSubset.size()) {\n            // update the maximal subset\n            answer = maxSubset;\n        }\n    }\n    return answer;        \n}\nvoid printSolution(const vector&lt;int&gt;&amp; result) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; v : result) {\n        cout &lt;&lt; v &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\" &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums{2,1,3};\n    auto answer = largestDivisibleSubset(nums);\n    printSolution(answer);\n    nums = {1,2,4,8};\n    answer = largestDivisibleSubset(nums);\n    printSolution(answer);\n}\n</code></pre> <pre><code>Output:\n[2,1,]\n[8,4,2,1,]\n</code></pre> <p>This solution uses dynamic programming with {index}<code>memoization</code> to find the largest divisible subset of a given set of numbers. </p> <p>The <code>largestDivisibleSubsetOf</code> function recursively computes the largest divisible subset starting from a particular index <code>i</code> in the sorted array <code>nums</code>. It memoizes the computed subsets in an unordered map <code>_map</code> to avoid redundant computations. By iteratively calling <code>largestDivisibleSubsetOf</code> for each index <code>i</code> in the sorted array and updating the <code>answer</code> with the largest subset found so far, the <code>largestDivisibleSubset</code> function computes the largest divisible subset of the input array <code>nums</code>. </p> <p>This approach optimizes the computation by avoiding repeated calculations and leveraging dynamic programming techniques to efficiently explore the solution space.</p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of elements in the <code>nums</code> vector.</li> <li>Extra space: <code>O(n^2)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#solution-2-store-only-the-representative-of-the-maxsubset","title":"Solution 2: Store only the representative of the <code>maxSubset</code>","text":"<p>In the brute-force solution above, you used a big <code>map</code> to log all <code>maxSubset[i]</code> though you need only the largest one at the end.</p> <p>One way to save memory (and eventually improve performance) is just storing the representative of the chain relationship between the values <code>nums[i]</code> of the <code>maxSubset</code> through their indices mapping. </p> <p>That means if <code>maxSubset[i] = [nums[i0] | nums[i1] | ... | nums[iN1]] | nums[iN]]</code>, you could log <code>pre[iN] = iN1</code>, ...,  <code>prev[i1] = i0</code>. </p> <p>Then all you need to find is only the last index <code>iN</code> of the largest <code>maxSubset</code>. </p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#example-3_1","title":"Example 3","text":"<pre><code>Input: nums = [2, 4, 3, 9, 8].\nsorted nums = [2, 3, 4, 8, 9]. \npre[0] = -1 (there is no nums[i] | nums[0]).\npre[1] = -1 (there is no nums[i] | nums[1]).\npre[2] = 0 (nums[0] is the only divisor of nums[2]).\npre[3] = 2 (for the largest subset though nums[0] and nums[2] are both divisors of nums[3]). \npre[4] = 1 (nums[1] is the only divisor of nums[4]).\niN = 3 ([2 | 4 | 8] is the largest maxSubset).\nOutput: [8, 4, 2].\n</code></pre>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nvector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {\n    if (nums.size() &lt;= 1) {\n        return nums; \n    }\n    sort(nums.begin(), nums.end());\n    // the size of the resulting subset\n    int maxSize = 0;    \n\n    // nums[maxindex] is the largest value of the resulting subset\n    int maxindex = 0;   \n\n    // subsetSize[i] stores the size of the largest subset\n    // having the biggest number nums[i]\n    vector&lt;int&gt; subsetSize(nums.size(), 1); \n\n    // pre[i] stores the previous index of i in their largest subset\n    vector&lt;int&gt; pre(nums.size(), -1);       \n    for (int i = 0; i &lt; nums.size(); i++) {\n        // find the previous nums[j] that make subsetSize[i] largest\n        for (int j = i - 1; j &gt;= 0; j--) {\n\n            if (nums[i] % nums[j] == 0 &amp;&amp; \n                subsetSize[j] + 1 &gt; subsetSize[i]) \n            {\n                subsetSize[i] = subsetSize[j] + 1;\n                pre[i] = j;\n            }\n        }\n        // update the largest subset\n        if (maxSize &lt; subsetSize[i]) {\n            maxSize = subsetSize[i];\n            maxindex = i;\n        }\n    }\n    vector&lt;int&gt; result;\n    while (maxindex != -1) {\n        result.push_back(nums[maxindex]);\n        maxindex = pre[maxindex];\n    }\n    return result;        \n}\nvoid printSolution(const vector&lt;int&gt;&amp; result) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; v : result) {\n        cout &lt;&lt; v &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\" &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums{2,1,3};\n    auto result = largestDivisibleSubset(nums);\n    printSolution(result);\n    nums = {1,2,4,8};\n    result = largestDivisibleSubset(nums);\n    printSolution(result);\n}\n</code></pre> <pre><code>Output:\n[2,1,]\n[8,4,2,1,]\n</code></pre> <p>This solution finds the largest divisible subset of a given set of numbers by dynamically updating the size of the subsets and maintaining the previous index of each element in their largest subset. </p> <p>It iterates through the sorted array of numbers, updating the size of the largest subset that ends with each element by considering the previous elements that are factors of the current element. By keeping track of the maximum subset size and the index of the largest element in the subset, it constructs the largest divisible subset. </p> <p>This approach optimizes the computation by avoiding redundant calculations and leveraging dynamic programming techniques to efficiently explore the solution space.</p>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of elements in the <code>nums</code> vector. The nested loop searches for previous elements with divisibility relationships, which may lead to quadratic time complexity in the worst case. However, it maintains information about subset sizes and elements, reducing redundant calculations and improving performance.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/368_Largest_Divisible_Subset/#key-takeaway","title":"Key takeaway","text":"<p>In this interesting problem, the index mapping is used to simplify everything. That improves the performance in both runtime and memory.</p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/","title":"{index}<code>Fibonacci Number</code>","text":""},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#problem-statement","title":"Problem statement","text":"<p>The Fibonacci numbers make up a sequence denoted as <code>F(n)</code>, known as the Fibonacci sequence. Each number in this sequence is the sum of the two preceding numbers, with the sequence starting from <code>0</code> and <code>1</code>. In other words:</p> <pre><code>F(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n &gt; 1.\n</code></pre> <p>Your task is to calculate the value of <code>F(n)</code> given an integer <code>n</code>. </p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#example-1","title":"Example 1","text":"<pre><code>Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n</code></pre>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#example-2","title":"Example 2","text":"<pre><code>Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n</code></pre>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#example-3","title":"Example 3","text":"<pre><code>Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n</code></pre>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= n &lt;= 30</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#solution-1-recursive","title":"Solution 1: Recursive","text":""},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nint fib(int n) {\n    if (n &lt;= 1) {\n        return n;\n    } \n    return fib(n - 1) + fib(n - 2);\n}\nint main() {\n    std::cout &lt;&lt; fib(2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(4) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n2\n3\n</code></pre> <p>This solution computes the nth Fibonacci number using a recursive approach. </p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#complexity","title":"Complexity","text":"<p>The time complexity of this solution is exponential, specifically <code>O(2^n)</code>. This is because it repeatedly makes two recursive calls for each <code>n</code>, resulting in an exponential number of function calls and calculations. As <code>n</code> grows larger, the execution time increases significantly. </p> <p>The space complexity of the given recursive Fibonacci solution is <code>O(n)</code>. This space complexity arises from the function call stack when making recursive calls.</p> <p>When you call the <code>fib</code> function with a value of <code>n</code>, it generates a call stack with a depth of <code>n</code>, as each call to <code>fib</code> leads to two more recursive calls (one for <code>n - 1</code> and one for <code>n - 2</code>) until <code>n</code> reaches the base cases (0 or 1). The space required to store the function call stack is proportional to the depth of the recursion, which is <code>n</code>.</p> <p>Therefore, the space complexity is linearly related to the input value <code>n</code>, making it <code>O(n)</code>. This can be a concern for large values of <code>n</code> because it could lead to a stack overflow if <code>n</code> is too large. </p> <ul> <li>Runtime: <code>O(2^n)</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#solution-2-dynamic-programming","title":"Solution 2: Dynamic programming","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nint fib(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n    // store all computed Fibonacci numbers\n    std::vector&lt;int&gt; f(n + 1);\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        f[i] = f[i - 1] + f[i - 2];\n    }\n    return f[n];\n}\nint main() {\n    std::cout &lt;&lt; fib(2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(4) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n2\n3\n</code></pre> <p>This solution uses dynamic programming to avoid redundant calculations by storing and reusing previously computed Fibonacci numbers.</p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#solution-3-reduce-space-for-dynamic-programming","title":"Solution 3: Reduce space for dynamic programming","text":""},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nint fib(int n) {\n    if (n &lt;= 1) {\n        return n;\n    }\n    // store only two previous Fibonacci numbers\n    int f0 = 0;\n    int f1 = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        int f2 = f1 + f0;\n        // update for next round\n        f0 = f1;\n        f1 = f2;\n    }\n    return f1;\n}\nint main() {\n    std::cout &lt;&lt; fib(2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; fib(4) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n2\n3\n</code></pre> <p>This solution calculates the nth Fibonacci number iteratively using two variables to keep track of the last two Fibonacci numbers. </p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#conclusion","title":"Conclusion","text":"<p>The Fibonacci sequence can be efficiently computed using various techniques, including recursion with memoization, bottom-up dynamic programming, or even optimizing space usage by storing only the necessary previous Fibonacci numbers. </p> <p>Solutions 2 and 3 demonstrate dynamic programming approaches, where Fibonacci numbers are computed iteratively while storing intermediate results to avoid redundant computations. </p> <p>Solution 3 further optimizes space usage by only storing the necessary previous Fibonacci numbers, resulting in a space complexity of <code>O(1)</code>. Understanding these different approaches and their trade-offs is essential for selecting the most appropriate solution based on the problem constraints and requirements.</p>"},{"location":"source/Dynamic_Programming/509_Fibonacci_Number/#exercise","title":"Exercise","text":"<ul> <li>N-th Tribonacci Number.</li> </ul>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/","title":"Unique Paths","text":"<p>% Medium https://leetcode.com/problems/unique-paths/</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#problem-statement","title":"Problem statement","text":"<p>A robot starts at the top-left corner of a grid with dimensions <code>m x n</code>. It can move either down or right at each step. The robot's goal is to reach the bottom-right corner of the grid.</p> <p>The problem is to determine the number of unique paths the robot can take to reach the bottom-right corner.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#example-1","title":"Example 1","text":"<pre><code>Input: m = 3, n = 7\nOutput: 28\n</code></pre>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#example-2","title":"Example 2","text":"<pre><code>Input: m = 3, n = 2\nOutput: 3\nExplanation:\nFrom the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down\n</code></pre>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#example-3","title":"Example 3","text":"<pre><code>Input: m = 7, n = 3\nOutput: 28\n</code></pre>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#example-4","title":"Example 4","text":"<pre><code>Input: m = 3, n = 3\nOutput: 6\n</code></pre>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= m, n &lt;= 100</code>.</li> <li>It's guaranteed that the answer will be less than or equal to <code>2*10^9</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#solution-1-recursive","title":"Solution 1: Recursive","text":"<p>At each point, the robot has two ways of moving: right or down. Let <code>P(m,n)</code> is the wanted result. Then you have a recursive relationship:</p> <pre><code>P(m,n) = P(m-1, n) + P(m, n-1)\n</code></pre> <p>If the grid has only one row or only one column, then there is only one possible path.</p> <pre><code>P(1, n) = P(m, 1) = 1.\n</code></pre> <p>Here's a recursive implementation.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint uniquePaths(int m, int n) {\n    if (m == 1 || n == 1) {\n        return 1;\n    }\n    return uniquePaths(m - 1, n) + uniquePaths(m, n - 1);\n}\nint main() {\n    std::cout &lt;&lt; uniquePaths(3,7) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(7,3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,3) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n28\n28\n3\n6\n</code></pre> <p>This is a recursive solution that breaks down the problem into two subproblems:</p> <ul> <li><code>uniquePaths(m-1, n)</code> </li> <li><code>uniquePaths(m, n-1)</code></li> </ul> <p>Each recursive call reduces either the <code>m</code> or <code>n</code> value by 1. </p> <p>The base case is when <code>m == 1</code> or <code>n == 1</code>, where there is only 1 unique path.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#complexity","title":"Complexity","text":"<p>To calculate the complexity, let's look at the recursion tree:</p> <ul> <li><code>uniquePaths(m,n)</code> calls:</li> <li><code>uniquePaths(m-1,n)</code></li> <li><code>uniquePaths(m, n-1)</code></li> <li>Each of those calls two more calls and so on.</li> </ul> <p>The height of the tree will be <code>max(m,n)</code>. At each level, there are 2 branches.</p> <p>So the total number of nodes in the tree will be <code>2^max(m,n)</code>.</p> <p>Since each node represents a function call, the runtime complexity is <code>O(2^max(m,n))</code>.</p> <p>The space complexity is <code>O(max(m,n))</code> due to the call stack.</p> <p>In summary, the complexities are:</p> <ul> <li>Runtime: <code>O(2^max(m,n)</code>, where <code>m x n</code> is the size of the grid.</li> <li>Extra space: <code>O(max(m,n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#solution-2-dynamic-programming","title":"Solution 2: Dynamic programming","text":"<p>The recursive implementation repeats a lot of computations.</p> <p>For example, <code>uniquePaths(2,2)</code> was recomputed in both <code>uniquePaths(2,3)</code> and <code>uniquePaths(3,2)</code> when you compute <code>uniquePaths(3,3)</code>.</p> <p>One way of storing what has been computed is by using dynamic programming.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint uniquePaths(int m, int n) {\n    // store what have been calculated in dp\n    vector&lt;vector&lt;int&gt; &gt; dp(m, vector&lt;int&gt;(n,1));\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\nint main() {\n    std::cout &lt;&lt; uniquePaths(3,7) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(7,3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,3) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n28\n28\n3\n6\n</code></pre> <p>This solution uses dynamic programming to efficiently compute the number of unique paths in an <code>m x n</code> grid. It creates a 2D vector <code>dp</code> of size <code>m x n</code> and initializes all its values to 1 because there's exactly one way to reach any cell in the first row or first column.</p> <p>Then, it iterates through the grid, starting from the second row and second column (i.e., indices (1, 1)), and for each cell, it calculates the number of unique paths to reach that cell. This is done by summing the number of paths from the cell above it and the cell to the left of it, as these are the only two possible directions to reach the current cell.</p> <p>Finally, the value at <code>dp[m-1][n-1]</code> contains the total number of unique paths to reach the bottom-right corner of the grid, which is returned as the result.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m*n)</code>, where <code>m x n</code> is the size of the grid.</li> <li>Extra space: <code>O(m*n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#solution-3-reduced-dynamic-programming","title":"Solution 3: Reduced dynamic programming","text":"<p>You can rephrase the relationship inside the loop like this:</p> <p>\"new value\" = \"old value\" + \"previous value\";</p> <p>Then you do not have to store all values of all rows.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#code_2","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint uniquePaths(int m, int n) {\n    // store the number of unique paths for each column in each row\n    vector&lt;int&gt; dp(n, 1);\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[j] += dp[j - 1];\n        }\n    }\n    return dp[n - 1];\n}\nint main() {\n    std::cout &lt;&lt; uniquePaths(3,7) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(7,3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,2) &lt;&lt; std::endl;\n    std::cout &lt;&lt; uniquePaths(3,3) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n28\n28\n3\n6\n</code></pre>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime <code>O(m*n)</code>, where <code>m x n</code> is the size of the grid.</li> <li>Memory <code>O(n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#conclusion","title":"Conclusion","text":"<p>Solution 3 uses only a 1D vector <code>dp</code> of size <code>n</code> to store the number of unique paths for each column.</p> <p>First, it initializes all elements of <code>dp</code> to 1, as there's exactly one way to reach any cell in the first row or first column.</p> <p>Then, it iterates through the grid, starting from the second row and second column (i.e., indices (1, 1)). For each cell, it updates the value in <code>dp</code> by adding the value from the cell directly above it and the value from the cell to the left of it. This step efficiently accumulates the number of unique paths to reach the current cell.</p> <p>Finally, the value at <code>dp[n-1]</code> contains the total number of unique paths to reach the bottom-right corner of the grid, which is returned as the result.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#a-bit-of-wonder","title":"A bit of wonder","text":"<p>I am wondering if there is some mathematics behind this problem. Please share your finding if you find a formula for the solution to this problem.</p>"},{"location":"source/Dynamic_Programming/62_Unique_Paths/#exercise","title":"Exercise","text":"<ul> <li>Minimum Path Sum.</li> </ul>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/","title":"Unique Paths II","text":""},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#problem-statement","title":"Problem statement","text":"<p>You're given an <code>m x n</code> grid represented as an integer array called <code>grid</code>. In this grid, there is a robot initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot's goal is to move to the bottom-right corner (i.e., <code>grid[m-1][n-1]</code>). The robot is allowed to move only downwards or to the right at any given point.</p> <p>The grid contains obstacles and empty spaces, which are marked as <code>1</code> or <code>0</code> respectively. The robot cannot pass through squares marked as obstacles.</p> <p>Your task is to determine the number of unique paths the robot can take to reach the bottom-right corner while avoiding obstacles.</p> <p>It's important to note that the test cases are designed in such a way that the answer will always be less than or equal to <code>2 * 10^9</code>. </p>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#example-1","title":"Example 1","text":"<pre><code>Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: 2\nExplanation: There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -&gt; Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right -&gt; Right\n</code></pre>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#example-2","title":"Example 2","text":"<pre><code>Input: obstacleGrid = [[0,1],[0,0]]\nOutput: 1\n</code></pre>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#constraints","title":"Constraints","text":"<ul> <li><code>m == obstacleGrid.length</code>.</li> <li><code>n == obstacleGrid[i].length</code>.</li> <li><code>1 &lt;= m, n &lt;= 100</code>.</li> <li><code>obstacleGrid[i][j]</code> is <code>0</code> or <code>1</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#solution-dynamic-programming-in-place","title":"Solution: Dynamic programming in place","text":"<p>Let us find the relationship between the positions.</p> <p>If there is no obstacle at the position <code>(row = i, col = j)</code>, the number of paths <code>np[i][j]</code> that the robot can take to reach this position is:</p> <pre><code>np[i][j] = np[i - 1][j] + np[i][j - 1]\n</code></pre> <ul> <li> <p>As long as there is no obstacle in the first row, <code>np[0][j] = 1</code>. Otherwise, <code>np[0][k] = 0</code> for all <code>k &gt;= j0</code>, where <code>(0, j0)</code> is the position of the first obstacle in the first row.</p> </li> <li> <p>Similarly, as long as there is no obstacle in the first column, <code>np[i][0] = 1</code>. Otherwise, <code>np[k][0] = 0</code> for all <code>k &gt;= i0</code>, where <code>(i0, 0)</code> is the position of the first obstacle in the first column.</p> </li> </ul>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint uniquePathsWithObstacles(const vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) {\n    const int row = obstacleGrid.size();\n    const int col = obstacleGrid[0].size();\n    vector&lt;vector&lt;int&gt;&gt; np(row, vector&lt;int&gt;(col, 0));    \n    for (int i = 0; i &lt; row &amp;&amp; obstacleGrid[i][0] == 0; i++) {\n        // can move as long as there is no obstacle\n        np[i][0] = 1;\n    }    \n    for (int j = 0; j &lt; col &amp;&amp; obstacleGrid[0][j] == 0; j++) {\n        // can move as long as there is no obstacle\n        np[0][j] = 1;\n    }\n    for (int i = 1; i &lt; row; i++) {\n        for (int j = 1; j &lt; col; j++) {\n            if (obstacleGrid[i][j] == 0) {\n                // can move since there is obstacle\n                np[i][j] = np[i - 1][j] + np[i][j - 1];\n            }\n        }\n    }\n    return np[row - 1][col - 1]; \n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; obstacleGrid = {{0,0,0},{0,1,0},{0,0,0}};\n    cout &lt;&lt; uniquePathsWithObstacles(obstacleGrid) &lt;&lt; endl;\n    obstacleGrid = {{0,1},{0,0}};\n    cout &lt;&lt; uniquePathsWithObstacles(obstacleGrid) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m*n)</code>, where <code>m</code> and <code>n</code> are the dimensions of the grid.</li> <li>Extra space: <code>O(m*n)</code>.</li> </ul>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#conclusion","title":"Conclusion","text":"<p>This solution computes the number of unique paths in an <code>m x n</code> grid with obstacles using dynamic programming. It initializes a 2D vector <code>np</code> of the same size as <code>obstacleGrid</code> to store the number of unique paths for each cell.</p> <p>First, it initializes the top row and left column of <code>np</code>. If there are no obstacles in the top row or left column of <code>obstacleGrid</code>, it sets the corresponding cells in <code>np</code> to 1 because there's only one way to reach any cell in the top row or left column.</p> <p>Then, it iterates through the grid starting from the second row and second column (i.e., indices (1, 1)). For each cell, if there's no obstacle (<code>obstacleGrid[i][j] == 0</code>), it updates the value in <code>np</code> by summing up the values from the cell directly above it and the cell to the left of it. This step efficiently accumulates the number of unique paths while avoiding obstacles.</p> <p>Finally, the value at <code>np[row-1][col-1]</code> contains the total number of unique paths to reach the bottom-right corner of the grid, which is returned as the result.</p>"},{"location":"source/Dynamic_Programming/63_Unique_Paths_II/#exercise","title":"Exercise","text":"<ul> <li>Minimum Path Cost in a Grid.</li> </ul>"},{"location":"source/Graph/785_Is_Graph_Bipartite/","title":"Is Graph Bipartite?","text":""},{"location":"source/Graph/785_Is_Graph_Bipartite/#problem-statement","title":"Problem statement","text":"<p>There is an undirected graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p> <ul> <li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li> <li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li> <li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li> <li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li> </ul> <p>A graph is bipartite if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that every edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p> <p>Return <code>true</code> if and only if it is a {index}<code>bipartite graph</code>.</p>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#example-1","title":"Example 1","text":"<pre><code>Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.\n</code></pre>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#example-2","title":"Example 2","text":"<pre><code>Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}.\n</code></pre>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#constraints","title":"Constraints","text":"<ul> <li><code>graph.length == n</code>.</li> <li><code>1 &lt;= n &lt;= 100</code>.</li> <li><code>0 &lt;= graph[u].length &lt; n</code>.</li> <li><code>0 &lt;= graph[u][i] &lt;= n - 1</code>.</li> <li><code>graph[u]</code> does not contain <code>u</code>.</li> <li>All the values of <code>graph[u]</code> are unique.</li> <li>If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>.</li> </ul>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#solution-coloring-the-nodes-by-indexdepth-first-search","title":"Solution: Coloring the nodes by {index}<code>Depth First Search</code>","text":"<p>You could color the nodes in set A with one color and those in B with another color. Then two ends of every edge have different colors.</p> <p>Now you can use the DFS algorithm to perform the coloring on each connected component of the graph. </p> <p>During the traversal, if there is an edge having the same color at two ends then return <code>false</code>.</p>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nbool isBipartite(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\n    vector&lt;int&gt; color(graph.size(), 0);\n    for (int i = 0; i &lt; graph.size(); i++) {\n        if (color[i] != 0) continue;\n        vector&lt;int&gt; s;\n        s.push_back(i);\n        color[i] = 1;\n        while (!s.empty()) {\n            int u = s.back();\n            s.pop_back();\n            for (int v : graph[u]) {\n                if (color[v] == 0) {\n                    color[v] = -color[u];\n                    s.push_back(v);\n                } else if (color[v] == color[u]) {\n                    return false;\n                }          \n            }\n        }\n\n    }\n    return true;\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; graph{{1,2,3},{0,2},{0,1,3},{0,2}};\n    cout &lt;&lt; isBipartite(graph) &lt;&lt; endl;\n    graph = {{1,3},{0,2},{1,3},{0,2}};\n    cout &lt;&lt; isBipartite(graph) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n1\n</code></pre>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = graph.length</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Graph/785_Is_Graph_Bipartite/#implementation-tips","title":"Implementation tips","text":"<ul> <li> <p>This is the non-recursive implementation of DFS algorithm where you could use the stack data structure to avoid the recursion.</p> </li> <li> <p>The stack's methods needed in the DFS algorithm are only <code>push</code> and <code>pop</code>. There are similar ones in <code>std::vector</code>. They are push_back and pop_back which you could use well in this case.</p> </li> </ul>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/","title":"All Paths From Source to Target","text":""},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#problem-statement","title":"Problem statement","text":"<p>Given a directed acyclic graph (DAG) of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>, find all possible paths from node <code>0</code> to node <code>n - 1</code> and return them in any order.</p> <p>The graph is given as follows: <code>graph[i]</code> is a list of all nodes you can visit from node <code>i</code> (i.e., there is a directed edge from node <code>i</code> to node <code>graph[i][j]</code>).</p>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#example-1","title":"Example 1","text":"<pre><code>Input: graph = [[1,2],[3],[3],[]]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: There are two paths: `0 -&gt; 1 -&gt; 3` and `0 -&gt; 2 -&gt; 3`.\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#example-2","title":"Example 2","text":"<pre><code>Input: graph = [[4,3,1],[3,2,4],[3],[4],[]]\nOutput: [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#example-3","title":"Example 3","text":"<pre><code>Input: graph = [[1],[]]\nOutput: [[0,1]]\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#example-4","title":"Example 4","text":"<pre><code>Input: graph = [[1,2,3],[2],[3],[]]\nOutput: [[0,1,2,3],[0,2,3],[0,3]]\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#example-5","title":"Example 5","text":"<pre><code>Input: graph = [[1,3],[2],[3],[]]\nOutput: [[0,1,2,3],[0,3]]\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#constraints","title":"Constraints","text":"<ul> <li><code>n == graph.length</code>.</li> <li><code>2 &lt;= n &lt;= 15</code>.</li> <li><code>0 &lt;= graph[i][j] &lt; n</code>.</li> <li><code>graph[i][j] != i</code> (i.e., there will be no self-loops).</li> <li>All the elements of <code>graph[i]</code> are unique.</li> <li>The input graph is guaranteed to be a DAG.</li> </ul>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#solution-depth-first-search-dfs","title":"Solution: Depth First Search (DFS)","text":"<p>This problem is exactly the Depth-first search algorithm.</p>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvoid DFS(vector&lt;vector&lt;int&gt;&gt;&amp; graph, \n         vector&lt;vector&lt;int&gt;&gt;&amp; paths, \n         vector&lt;int&gt;&amp; path) {\n    for (auto&amp; node : graph[path.back()]) {\n        path.push_back(node);\n        if (node == graph.size() - 1) {\n            paths.push_back(path);\n            path.pop_back();\n        } else {\n            DFS(graph, paths, path);\n        }\n    }\n    path.pop_back();\n}\nvector&lt;vector&lt;int&gt;&gt; allPathsSourceTarget(vector&lt;vector&lt;int&gt;&gt;&amp; graph) {\n    vector&lt;vector&lt;int&gt;&gt; paths;\n    vector&lt;int&gt; path = {0};\n    DFS(graph, paths, path);\n    return paths;\n}\nvoid printPaths(vector&lt;vector&lt;int&gt;&gt;&amp; paths) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; p : paths) {\n        cout &lt;&lt; \"[\";\n        for (auto&amp; node : p) {\n            cout &lt;&lt; node &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"],\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; graph = {{1,2},{3},{3},{}};\n    auto paths = allPathsSourceTarget(graph);\n    printPaths(paths);\n    graph = {{4,3,1},{3,2,4},{3},{4},{}};\n    paths = allPathsSourceTarget(graph);\n    printPaths(paths); \n}\n</code></pre> <pre><code>Output:\n[[0,1,3,],[0,2,3,],]\n[[0,4,],[0,3,4,],[0,1,3,4,],[0,1,2,3,4,],[0,1,4,],]\n</code></pre>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#code-explanation","title":"Code explanation","text":"<p>This code performs a {index}<code>Depth First Search</code> (DFS) to find all possible paths from the source node (0) to the target node (<code>graph.size() - 1</code>) in a given directed graph represented as an adjacency list. </p> <p>The <code>DFS</code> function explores the graph starting from the current node, and if it reaches the target node, it adds the path to the <code>paths</code> vector. Otherwise, it continues the DFS exploration from the neighboring nodes. </p> <p>The <code>allPathsSourceTarget</code> function initializes the <code>paths</code> vector and a <code>path</code> vector that starts at the source node (0). It then calls the <code>DFS</code> function to traverse the graph, and once the traversal is complete, it returns the <code>paths</code> vector containing all possible paths from the source to the target node.</p>"},{"location":"source/Graph/797_All_Paths_From_Source_to_Target/#complexity","title":"Complexity","text":"<p>The runtime complexity depends on a few factors:</p> <ul> <li>Number of nodes (<code>N</code>) and edges (<code>E</code>) in the graph.</li> <li>Number of paths between the two nodes.</li> </ul> <p>In the worst case, DFS will explore all nodes in the graph. This happens when:</p> <ul> <li>The graph is dense (high <code>E</code> compared to <code>N</code>).</li> <li>There are many paths between the two nodes.</li> </ul> <p>To find all paths between two nodes, DFS will have to explore the entire search space. So in the worst case, the complexity is <code>O(N + E)</code>.</p> <ul> <li>Runtime: <code>O(N + E)</code>, where <code>N = graph.length</code> and <code>E</code> is the number of the graph's edges.</li> <li>Extra space: <code>O(N)</code> (the vector <code>path</code>).</li> </ul>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/","title":"Minimum Deletions to Make Character Frequencies Unique","text":""},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#problem-statement","title":"Problem statement","text":"<p>A string <code>s</code> is considered \"good\" if there are no two different characters in the string that have the same frequency, meaning each character appears a unique number of times.</p> <p>You're given a string <code>s</code>, and your task is to determine the minimum number of characters you need to delete from <code>s</code> to make it a \"good\" string.</p> <p>The frequency of a character in a string is the count of times that character appears in the string. For instance, in the string <code>\"aab\"</code>, the frequency of <code>'a'</code> is <code>2</code>, and the frequency of <code>'b'</code> is <code>1</code>.</p>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"aab\"\nOutput: 0\nExplanation: s is already good.\n</code></pre>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"aaabbbcc\"\nOutput: 2\nExplanation: You can delete two 'b's resulting in the good string \"aaabcc\".\nAnother way is to delete one 'b' and one 'c' resulting in the good string \"aaabbc\".\n</code></pre>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"ceabaacb\"\nOutput: 2\nExplanation: You can delete both 'c's resulting in the good string \"eabaab\".\nNote that we only care about characters that are still in the string at the end (i.e. frequency of 0 is ignored).\n</code></pre>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length &lt;= 10^5</code>.</li> <li><code>s</code> contains only lowercase English letters.</li> </ul>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#solution-delete-the-frequencies-in-sorted-order","title":"Solution: Delete the frequencies in sorted order","text":"<p>Your goal is to make all the frequencies be different.</p> <p>One way of doing that is by sorting the frequencies and performing the deletion.</p>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#example-4","title":"Example 4","text":"<p>For <code>s = \"ceaacbb\"</code>, the frequencies of the characters are: <code>freq['a'] = 2, freq['b'] = 2, freq['c'] = 2</code> and <code>freq['e'] = 1</code>. They are already in sorted order.</p> <ul> <li>Let the current frequency be the first frequency <code>freq['a'] = 2</code>.</li> <li>The next frequency is <code>freq['b'] = 2</code>, equal to the current frequency. Delete one appearance to make the current frequency be <code>1</code>.</li> <li>The next frequency is <code>freq['c'] = 2</code>, bigger than the current frequency. Delete two appearances to make the current frequency be <code>0</code>.</li> <li>Because the current frequency is <code>0</code>, delete all appearances of the remaining frequencies, which is <code>freq['e'] = 1</code>.</li> <li>In total, there are <code>4</code> deletions.</li> </ul>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#code","title":"Code","text":"<pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint minDeletions(string&amp; s) {\n    // map 'a'-&gt;0, 'b'-&gt;1, ..,'z'-&gt;25\n    vector&lt;int&gt; freq(26, 0);\n    for (char&amp; c: s) {\n        // count the frequency of character c\n        freq[c - 'a']++;\n    }\n    // sort freq in descending order\n    sort(freq.begin(), freq.end(), greater&lt;int&gt;());\n    int deletion = 0;\n    int currentFreq = freq.at(0); // start with the max frequency\n    for (int i = 1; i &lt; freq.size() &amp;&amp; freq.at(i) &gt; 0; i++) {\n        if (currentFreq == 0) {\n            // delete all remaining characters\n            deletion += freq.at(i);\n        } else if (freq[i] &gt;= currentFreq) {\n            // delete just enough to make the freq[i] &lt; currentFreq\n            deletion += freq.at(i) - currentFreq + 1;\n            currentFreq--;\n        } else {\n            // do not delete on freq[i] &lt; currentFreq\n            currentFreq = freq.at(i);\n        }\n    }\n    return deletion;\n}\nint main() {\n    cout &lt;&lt; minDeletions(\"aab\") &lt;&lt; endl;\n    cout &lt;&lt; minDeletions(\"aaabbbcc\") &lt;&lt; endl;\n    cout &lt;&lt; minDeletions(\"ceabaacb\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n2\n2\n</code></pre>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>;</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#conclusion","title":"Conclusion","text":"<p>The problem of determining the minimum number of deletions required to make character frequencies unique can be efficiently solved by counting the frequencies of characters and iteratively adjusting the frequencies to ensure uniqueness. </p> <p>This solution achieves this by first counting the frequencies of characters and then sorting them in descending order. By iteratively processing the sorted frequencies, the solution ensures that each character frequency is unique while minimizing the number of deletions required.</p>"},{"location":"source/Greedy/1647_Minimum_Deletions_to_Make_Character_Frequencies_Unique/#exercise","title":"Exercise","text":"<ul> <li>Minimum Deletions to Make Array Beautiful.</li> </ul>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/","title":"Partitioning Into Minimum Number Of Deci-Binary Numbers","text":""},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#problem-statement","title":"Problem statement","text":"<p>A decimal number is called deci-binary if each of its digits is either <code>0</code> or <code>1</code> without any leading zeros. For example, <code>101</code> and <code>1100</code> are deci-binary, while <code>112</code> and <code>3001</code> are not.</p> <p>Given a string <code>n</code> that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to <code>n</code>.</p>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#example-1","title":"Example 1","text":"<pre><code>Input: n = \"32\"\nOutput: 3\nExplanation: 10 + 11 + 11 = 32\n</code></pre>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#example-2","title":"Example 2","text":"<pre><code>Input: n = \"82734\"\nOutput: 8\n</code></pre>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#example-3","title":"Example 3","text":"<pre><code>Input: n = \"27346209830709182346\"\nOutput: 9\n</code></pre>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n.length &lt;= 10^5</code>.</li> <li><code>n</code> consists of only digits.</li> <li><code>n</code> does not contain any leading zeros and represents a positive integer.</li> </ul>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#solution-identify-the-maximum-digit-of-n","title":"Solution: Identify the maximum digit of <code>n</code>","text":"<p>Any digit <code>d</code> can be obtained by summing the digit <code>1</code> <code>d</code> times.</p> <p>The problem turns into identifying the maximum digit of <code>n</code>.</p>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#example-2_1","title":"Example 2","text":"<p>For <code>n = \"82734\"</code> the answer is 8 because:</p> <pre><code>  82734\n= 11111 \n+ 11111 \n+ 10111 \n+ 10101 \n+ 10100\n+ 10100\n+ 10100\n+ 10000\n</code></pre>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint minPartitions(const string&amp; n) {\n    char maxDigit = '0';\n    for (auto&amp; d : n) {\n        maxDigit = max(maxDigit, d);\n    }\n    return maxDigit - '0';\n}\nint main() {\n    cout &lt;&lt; minPartitions(\"32\") &lt;&lt; endl;\n    cout &lt;&lt; minPartitions(\"82734\") &lt;&lt; endl;\n    cout &lt;&lt; minPartitions(\"27346209830709182346\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n8\n9\n</code></pre>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = n.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Greedy/1689_Partitioning_Into_Minimum_Number_Of_Deci-Binary_Numbers/#conclusion","title":"Conclusion","text":"<p>This problem can be efficiently solved by identifying the maximum digit in the string. Since each deci-binary number can only contain digits from 0 to 9, the maximum digit determines the minimum number of deci-binary numbers needed. </p> <p>By finding the maximum digit in the string and converting it to an integer, the solution effectively determines the minimum number of deci-binary numbers required.</p>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/","title":"Maximum Units on a Truck","text":""},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#problem-statement","title":"Problem statement","text":"<p>You are assigned to put some amount of boxes onto one truck. You are given a 2D array <code>boxTypes</code>, where <code>boxTypes[i] = [numberOfBoxes_i, numberOfUnitsPerBox_i]</code>:</p> <ul> <li><code>numberOfBoxes_i</code> is the number of boxes of type <code>i</code>.</li> <li><code>numberOfUnitsPerBox_i</code> is the number of units in each box of the type <code>i</code>.</li> </ul> <p>You are also given an integer <code>truckSize</code>, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed <code>truckSize</code>.</p> <p>Return the maximum total number of units that can be put on the truck.</p>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#example-1","title":"Example 1","text":"<pre><code>Input: boxTypes = [[1,3],[2,2],[3,1]], truckSize = 4\nOutput: 8\nExplanation: There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 * 3) + (2 * 2) + (1 * 1) = 8.\n</code></pre>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#example-2","title":"Example 2","text":"<pre><code>Input: boxTypes = [[5,10],[2,5],[4,7],[3,9]], truckSize = 10\nOutput: 91\nExplanation: (5 * 10) + (3 * 9) + (2 * 7) = 91.\n</code></pre>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= boxTypes.length &lt;= 1000</code>.</li> <li><code>1 &lt;= numberOfBoxes_i, numberOfUnitsPerBox_i &lt;= 1000</code>.</li> <li><code>1 &lt;= truckSize &lt;= 10^6</code>.</li> </ul>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#solution-greedy-algorithm","title":"Solution: Greedy algorithm","text":"<p>Put the boxes having more units first.</p>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint maximumUnits(vector&lt;vector&lt;int&gt;&gt;&amp; boxTypes, int truckSize) {\n    // sort for the boxes based on their number of units\n    sort(boxTypes.begin(), boxTypes.end(), \n         [](const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n            return a[1] &gt; b[1];\n         });\n    int maxUnits = 0;\n    int i = 0;\n    while (truckSize &gt; 0 &amp;&amp; i &lt; boxTypes.size()) {\n        if (boxTypes[i][0] &lt;= truckSize) {\n            // put all boxTypes[i] if there is still room\n            maxUnits += boxTypes[i][0] * boxTypes[i][1];\n            truckSize -= boxTypes[i][0];\n        } else {\n            // can put only truckSize &lt; boxTypes[i][0] of boxTypes[i]\n            maxUnits += truckSize * boxTypes[i][1];\n            break;\n        }\n        i++;\n    }\n    return maxUnits;\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; boxTypes{{1,3},{2,2},{3,1}};\n    cout &lt;&lt; maximumUnits(boxTypes, 4) &lt;&lt; endl;\n    boxTypes = {{5,10},{2,5},{4,7},{3,9}};\n    cout &lt;&lt; maximumUnits(boxTypes, 10) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n8\n91\n</code></pre> <p>This solution optimally loads boxes onto a truck to maximize the total number of units that can be transported, considering both the number of boxes available and their units per box.</p>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*logN)</code>, where <code>N = boxTypes.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#modern-c-stl-notes","title":"Modern C++ STL notes","text":"<p>Note that two <code>vector</code>s can be compared. That is why you can sort them.</p> <p>But in this case you want to sort them based on the number of units. That is why you need to define the comparison function like the code above. Otherwise, the {index}<code>std::sort</code> algorithm will use the dictionary order to sort them by default.  </p>"},{"location":"source/Greedy/1710_Maximum_Units_on_a_Truck/#exercise","title":"Exercise","text":"<ul> <li>Maximum Bags With Full Capacity of Rocks.</li> </ul>"},{"location":"source/Greedy/376_Wiggle_Subsequence/","title":"Wiggle Subsequence","text":""},{"location":"source/Greedy/376_Wiggle_Subsequence/#problem-statement","title":"Problem statement","text":"<p>A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.</p> <ul> <li>For example, <code>[1, 7, 4, 9, 2, 5]</code> is a wiggle sequence because the differences <code>(6, -3, 5, -7, 3)</code> alternate between positive and negative.</li> <li>In contrast, <code>[1, 4, 7, 2, 5]</code> and <code>[1, 7, 4, 5, 5]</code> are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.</li> </ul> <p>A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.</p> <p>Given an integer array <code>nums</code>, return the length of the longest wiggle subsequence of <code>nums</code>.</p>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n</code></pre>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length.\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\n</code></pre>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\n</code></pre>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 1000</code>.</li> <li><code>0 &lt;= nums[i] &lt;= 1000</code>.</li> </ul>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#follow-up","title":"Follow up","text":"<ul> <li>Could you solve this in <code>O(n)</code> time?</li> </ul>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#solution-counting-the-local-extrema-of-nums","title":"Solution: Counting the local extrema of <code>nums</code>","text":"<p>First, if you pick all local extrema (minima and maxima) of <code>nums</code> to form a subsequence <code>e</code>, then it is wiggle. Let us call it an extrema subsequence.</p>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#example-2_1","title":"Example 2","text":"<p>For <code>nums = [1,17,5,10,13,15,10,5,16,8]</code>, the local extrema are <code>[1,17,5,15,5,16,8]</code>. It is wiggle and called extrema subsequence.</p> <p>Note that if <code>nums.length = n</code> then <code>nums[0]</code> and <code>nums[n - 1]</code> are always the first and the last extremum.</p> <p>Second, given any two successive local extrema <code>a</code> and <code>b</code>, you cannot have any wiggle subsequence between them. Because the elements between them are either monotonic increasing or decreasing. </p> <p>That proves the extrema subsequence is the longest wiggle one.</p>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint wiggleMaxLength(const vector&lt;int&gt;&amp; nums) {\n    // nums[0] is always the first extremum\n    // start to find the second extremum\n    int i = 1;\n    while (i &lt; nums.size() &amp;&amp; nums[i] == nums[i - 1]) {\n        i++;\n    }\n    if (i == nums.size()) {\n        // all nums[i] are equal\n        return 1;\n    }\n    int sign = nums[i] &gt; nums[i - 1] ? 1 : -1;\n    int count = 2;\n    i++;\n    while (i &lt; nums.size()) {\n        if ((nums[i] - nums[i - 1]) * sign &lt; 0) {\n            // nums[i] is an extremum\n            count++;\n            sign = -sign;\n        }\n        i++;\n    }\n    return count;\n}\nint main() {\n    vector&lt;int&gt; nums{1,7,4,9,2,5};\n    cout &lt;&lt; wiggleMaxLength(nums) &lt;&lt; endl;\n    nums = {1,17,5,10,13,15,10,5,16,8};\n    cout &lt;&lt; wiggleMaxLength(nums) &lt;&lt; endl;\n    nums = {1,2,3,4,5,6,7,8,9};\n    cout &lt;&lt; wiggleMaxLength(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n6\n7\n2\n</code></pre>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Greedy/376_Wiggle_Subsequence/#conclusion","title":"Conclusion","text":"<p>The problem of finding the length of the longest wiggle subsequence can be efficiently solved using a greedy approach. The solution iterates through the input array, identifying alternating extremums (peaks and valleys) to form the wiggle subsequence. </p> <p>By keeping track of the current trend direction (increasing or decreasing), the solution efficiently identifies extremums and increments the count accordingly. This greedy approach ensures that each extremum contributes to increasing the length of the wiggle subsequence, maximizing its overall length.</p>"},{"location":"source/Greedy/605_Can_Place_Flowers/","title":"Can Place Flowers","text":""},{"location":"source/Greedy/605_Can_Place_Flowers/#problem-statement","title":"Problem statement","text":"<p>You are presented with a long flowerbed containing plots, some of which are planted with flowers (denoted by <code>1</code>) and some are empty (denoted by <code>0</code>). Flowers cannot be planted in adjacent plots. You are given an integer array <code>flowerbed</code> representing the layout of the flowerbed, and an integer <code>n</code> representing the number of new flowers you want to plant.</p> <p>Your task is to determine if it is possible to plant <code>n</code> new flowers in the <code>flowerbed</code> without violating the rule of no-adjacent-flowers. If it is possible, return <code>true</code>; otherwise, return <code>false</code>.</p>"},{"location":"source/Greedy/605_Can_Place_Flowers/#example-1","title":"Example 1","text":"<pre><code>Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true\n</code></pre>"},{"location":"source/Greedy/605_Can_Place_Flowers/#example-2","title":"Example 2","text":"<pre><code>Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\n</code></pre>"},{"location":"source/Greedy/605_Can_Place_Flowers/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= flowerbed.length &lt;= 2 * 10^4</code>.</li> <li><code>flowerbed[i]</code> is <code>0</code> or <code>1</code>.</li> <li>There are no two adjacent flowers in <code>flowerbed</code>.</li> <li><code>0 &lt;= n &lt;= flowerbed.length</code>.</li> </ul>"},{"location":"source/Greedy/605_Can_Place_Flowers/#solution-check-the-no-adjacent-flowers-rule","title":"Solution: Check the no-adjacent-flowers rule","text":"<p>A new flower can be planted at position <code>i</code> only if </p> <pre><code>flowerbed[i - 1] == 0 &amp;&amp; flowerbed[i] == 0 &amp;&amp; flowerbed[i + 1] == 0.\n</code></pre> <p>If the condition is satisfied, the flower can be planted at position <code>i</code>. <code>flowerbed[i]</code> is now assigned to <code>1</code>. Then you can skip checking the rule for the position <code>i + 1</code> and go directly to position <code>i + 2</code>. </p>"},{"location":"source/Greedy/605_Can_Place_Flowers/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {\n    if (n == 0) {\n        return true;\n    }\n    flowerbed.insert(flowerbed.begin(), 0);\n    flowerbed.push_back(0);\n    int i = 1;\n    while (i &lt; flowerbed.size() - 1) {\n        if (flowerbed[i - 1] == 0 &amp;&amp; flowerbed[i] == 0 &amp;&amp; flowerbed[i + 1] == 0) {\n            // plant i if it satisfies the no-adjacent condition\n            flowerbed[i] = 1;\n            n--;\n            i+=2;\n        } else {\n            i++;\n        }\n    }\n    return n &lt;= 0; // have planted all n\n}\nint main() {\n    vector&lt;int&gt; flowerbed{1,0,0,0,1};\n    cout &lt;&lt; canPlaceFlowers(flowerbed, 1) &lt;&lt; endl;\n    flowerbed = {1,0,0,0,1};\n    cout &lt;&lt; canPlaceFlowers(flowerbed, 2) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n</code></pre> <p>This solution efficiently iterates through the flowerbed, planting flowers wherever possible while adhering to the constraints. It returns <code>true</code> if it's possible to plant all the required flowers and <code>false</code> otherwise.</p>"},{"location":"source/Greedy/605_Can_Place_Flowers/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = flowerbed.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Greedy/605_Can_Place_Flowers/#implementation-tips","title":"Implementation tips","text":"<ul> <li> <p>In this implementation, you could insert element <code>0</code> to the front and the back of vector <code>flowerbed</code> to avoid writing extra code for checking the no-adjacent-flowers rule at <code>i = 0</code> and <code>i = flowerbed.size() - 1</code>.</p> </li> <li> <p>There are a few ways to insert an element to a vector. Here you can see an example of using the methods <code>insert</code> and <code>push_back</code> of a <code>std::vector</code>.</p> </li> </ul>"},{"location":"source/Greedy/605_Can_Place_Flowers/#ecercise","title":"Ecercise","text":"<ul> <li>Teemo Attacking.</li> </ul>"},{"location":"source/Hash_Table/13_Roman_to_Integer/","title":"Roman to Integer","text":""},{"location":"source/Hash_Table/13_Roman_to_Integer/#problem-statement","title":"Problem statement","text":"<p>Roman numerals utilize seven symbols: <code>I</code>, <code>V</code>, <code>X</code>, <code>L</code>, <code>C</code>, <code>D</code>, and <code>M</code> to represent numbers. </p> <pre><code>Symbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n</code></pre> <p>For example, <code>2</code> is denoted as <code>II</code>, which is essentially two ones added together. Similarly, <code>12</code> is represented as <code>XII</code>, indicating <code>X + II</code>. The number <code>27</code> is written as <code>XXVII</code>, which stands for <code>XX + V + II</code>.</p> <p>Roman numerals are generally written from the largest value to the smallest value, moving from left to right. However, there are exceptions to this pattern. For instance, the numeral for <code>4</code> is <code>IV</code> instead of <code>IIII</code>, where <code>I</code> is placed before <code>V</code> to subtract <code>1</code> from <code>5</code>. Similarly, <code>9</code> is <code>IX</code>, representing the subtraction of <code>1</code> from <code>10</code>. There are six such subtraction instances:</p> <ul> <li><code>I</code> before <code>V</code> (<code>5</code>) or <code>X</code> (<code>10</code>) forms <code>4</code> and <code>9</code>.</li> <li><code>X</code> before <code>L</code> (<code>50</code>) or <code>C</code> (<code>100</code>) forms <code>40</code> and <code>90</code>.</li> <li><code>C</code> before <code>D</code> (<code>500</code>) or <code>M</code> (<code>1000</code>) forms <code>400</code> and <code>900</code>.</li> </ul> <p>Your task is to convert a given Roman numeral into its equivalent integer value.  </p>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"III\"\nOutput: 3\nExplanation: III = 3.\n</code></pre>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n</code></pre>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n</code></pre>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length &lt;= 15</code>.</li> <li><code>s</code> contains only the characters <code>'I'</code>, <code>'V'</code>, <code>'X'</code>, <code>'L'</code>, <code>'C'</code>, <code>'D'</code>, <code>'M'</code>.</li> <li>It is guaranteed that <code>s</code> is a valid Roman numeral in the range <code>[1, 3999]</code>.</li> </ul>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#solution-mapping-and-summing-the-values","title":"Solution: Mapping and summing the values","text":"<p>To treat the subtraction cases easier you can iterate the string <code>s</code> backward.</p>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nconst unordered_map&lt;char, int&gt; value = {\n    {'I', 1},   {'V', 5},\n    {'X', 10},  {'L', 50},\n    {'C', 100}, {'D', 500},\n    {'M', 1000}\n};\nint romanToInt(const string&amp; s) {\n\n    // starting from the end character of the string s\n    int i = s.length() - 1;\n    int result = value.at(s[i--]);\n    while (i &gt;= 0) {\n        // In cases of subtraction\n        if (value.at(s[i]) &lt; value.at(s[i+1])) {\n            result -= value.at(s[i--]); \n        } else {\n            result += value.at(s[i--]);\n        }\n    }\n    return result;\n}\nint main() {\n    cout &lt;&lt; romanToInt(\"III\") &lt;&lt; endl;\n    cout &lt;&lt; romanToInt(\"LVIII\") &lt;&lt; endl;\n    cout &lt;&lt; romanToInt(\"MCMXCIV\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n58\n1994\n</code></pre>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code> where <code>N = s.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#conclusion","title":"Conclusion","text":"<p>This problem can be solved using a map to store the values of each Roman numeral character. This solution iterates through the string from right to left, accumulating the integer value based on the corresponding Roman numeral characters. </p> <p>By comparing the current character's value with the previous one, the solution handles cases of subtraction (e.g., IV, IX, etc.) by subtracting the value if it's smaller and adding it otherwise.</p>"},{"location":"source/Hash_Table/13_Roman_to_Integer/#exercise","title":"Exercise","text":"<ul> <li>Integer to Roman.</li> </ul>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/","title":"Maximum Erasure Value","text":""},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#problem-statement","title":"Problem statement","text":"<p>You have an array of positive integers called <code>nums</code>, and you wish to remove a subarray from it that consists of distinct elements. The score you achieve by removing this subarray is the sum of its elements.</p> <p>Your goal is to determine the highest possible score attainable by erasing exactly one subarray from the provided array.</p> <p>A subarray, denoted as <code>b</code>, is considered part of another array, <code>a</code>, if it appears consecutively within <code>a</code>, i.e., if it is equivalent to <code>a[l], a[l+1], ..., a[r]</code> for some indices <code>(l, r)</code>.</p>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [4,2,4,5,6]\nOutput: 17\nExplanation: The optimal subarray here is [2,4,5,6].\n</code></pre>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [5,2,1,2,5,2,1,2,5]\nOutput: 8\nExplanation: The optimal subarray here is [5,2,1] or [1,2,5].\n</code></pre>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>1 &lt;= nums[i] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#solution-store-the-position-of-the-visited-elements","title":"Solution: Store the position of the visited elements","text":"<p>You can use a map to store the position of the elements of <code>nums</code>. Then when iterating <code>nums</code> you can identify if an element has been visited before. That helps you to decide if a subarray contains unique elements.</p>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint maximumUniqueSubarray(const vector&lt;int&gt;&amp; nums) {\n    // sum stores the running sum of nums\n    // i.e., sum[i] = nums[0] + ... + nums[i]\n    vector&lt;int&gt; sum(nums.size(), 0);\n    sum[0] = nums.at(0);\n\n    // store the maximum sum of the maximum subarray\n    int maxSum = sum.at(0);\n\n    // position[a] keeps track of latest index i whose nums[i] = a\n    unordered_map&lt;int, int&gt; position;\n    position[nums.at(0)] = 0;\n\n    // the starting index of the current subarray\n    int start = -1;\n    for (int i = 1; i &lt; nums.size(); i++) {\n        sum[i] = sum.at(i - 1) + nums.at(i);\n\n        // check if the current subarray's elements are still distinct\n        auto it = position.find(nums.at(i));\n\n        // found the value nums[i] in the map position\n        if (it != position.end()) {\n            // a new subarray now starts from i\n            start = max(start, it-&gt;second);\n\n            // clear the latest index of the value nums[i]\n            // by updating it to i \n            it-&gt;second = i;\n        } else {\n            // current subarray continues with nums[i]\n            position.insert({nums.at(i), i});\n        }            \n        if (start == -1) {\n            // still on the first subarray nums[0]..nums[i]\n            maxSum = sum.at(i);\n        } else {\n            // update maxSum with the sum of subarray nums[start]..nums[i]\n            maxSum = max(maxSum, sum.at(i) - sum.at(start));\n        }\n    }\n    return maxSum;\n}\nint main() {\n    vector&lt;int&gt; nums{4,2,4,5,6};\n    cout &lt;&lt; maximumUniqueSubarray(nums) &lt;&lt; endl;\n    nums = {5,2,1,2,5,2,1,2,5};\n    cout &lt;&lt; maximumUniqueSubarray(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n17\n8\n</code></pre>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = nums.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Hash_Table/1695_Maximum_Erasure_Value/#conclusion","title":"Conclusion","text":"<p>This solution computes the maximum sum of a subarray containing unique elements. </p> <p>It uses a {index}<code>sliding window</code> approach to maintain a running sum of the elements encountered so far and a hashmap to keep track of the positions of previously seen elements. By updating the starting index of the window when a repeated element is encountered, it ensures that the current subarray contains only unique elements. </p> <p>This approach optimizes the computation of the maximum sum by handling the sliding window and updating the sum accordingly, resulting in an overall efficient solution.</p>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/","title":"Find and Replace Pattern","text":""},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#problem-statement","title":"Problem statement","text":"<p>You are provided with a list of strings named <code>words</code> and a string named <code>pattern</code>. Your task is to find the strings from <code>words</code> that match the given <code>pattern</code>. The order in which you return the answers does not matter.</p> <p>A word is considered to match the pattern if there is a mapping <code>p</code> of the letters such that, when each letter <code>x</code> in the pattern is replaced with <code>p(x)</code>, the word is formed.</p> <p>Keep in mind that a permutation of letters is a one-to-one correspondence from letters to letters, where each letter is mapped to a distinct letter, and no two letters are mapped to the same letter. </p>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#example-1","title":"Example 1","text":"<pre><code>Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\"\nOutput: [\"mee\",\"aqq\"]\nExplanation: \"mee\" matches the pattern because there is a permutation {a -&gt; m, b -&gt; e, ...}. \n\"ccc\" does not match the pattern because {a -&gt; c, b -&gt; c, ...} is not a permutation, since a and b map to the same letter.\n</code></pre>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#example-2","title":"Example 2","text":"<pre><code>Input: words = [\"a\",\"b\",\"c\"], pattern = \"a\"\nOutput: [\"a\",\"b\",\"c\"]\n</code></pre>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= pattern.length &lt;= 20</code>.</li> <li><code>1 &lt;= words.length &lt;= 50</code>.</li> <li><code>words[i].length == pattern.length</code>.</li> <li><code>pattern</code> and <code>words[i]</code> are lowercase English letters.</li> </ul>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#solution-construct-the-bijection-and-check-the-condition","title":"Solution: Construct the bijection and check the condition","text":""},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nvector&lt;string&gt; findAndReplacePattern(const vector&lt;string&gt;&amp; words, const string&amp; pattern) {\n    vector&lt;string&gt; result;  \n    // need two maps for the bijection\n    unordered_map&lt;char,char&gt; w_to_p, p_to_w;\n    int i;\n    for (auto&amp; w : words) {\n        w_to_p.clear();\n        p_to_w.clear();\n        i = 0;\n        while (i &lt; w.length()) {\n            if (w_to_p.find(w[i]) != w_to_p.end()) {\n                // w[i] was mapped to some letter x\n                // but x != pattern[i]\n                if (w_to_p[w[i]] != pattern[i]) {\n                    break;\n                }\n            } else {\n                if (p_to_w.find(pattern[i]) != p_to_w.end()) {\n                    // w[i] was not mapped to any letter yet\n                    // but pattern[i] was already mapped to some letter\n                    break;\n                }\n                // build the bijection w[i] &lt;-&gt; pattern[i]\n                w_to_p[w[i]] = pattern[i];\n                p_to_w[pattern[i]] = w[i];\n            }\n            i++;\n        }\n        if (i == w.length()) {\n            result.push_back(w);\n        }\n    }\n    return result;\n}\nvoid printResult(const vector&lt;string&gt;&amp; result) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; s : result) {\n        cout &lt;&lt; s &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;string&gt; words{\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"};\n    auto result = findAndReplacePattern(words, \"abb\");\n    printResult(result);\n    words = {\"a\", \"b\", \"c\"};\n    result = findAndReplacePattern(words, \"abb\");\n    printResult(result);\n}\n</code></pre> <pre><code>Output:\n[mee,aqq,]\n[a,b,c,]\n</code></pre>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(NL)</code>, where <code>N = words.length</code> and <code>L = pattern.length</code>.</li> <li>Extra space: <code>O(1)</code>. The maps <code>w_to_p</code> and <code>p_to_w</code> just map between 26 lowercase English letters.</li> </ul>"},{"location":"source/Hash_Table/890_Find_and_Replace_Pattern/#conclusion","title":"Conclusion","text":"<p>This solution efficiently finds and returns words from a vector of strings that match a given pattern in terms of character bijection. It uses two unordered maps to establish and maintain the bijection while iterating through the characters of the words and the pattern. </p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/","title":"Intersection of Two Linked Lists","text":""},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#problem-statement","title":"Problem statement","text":"<p>You are provided with the starting nodes of two singly linked lists, <code>headA</code> and <code>headB</code>. Your task is to find the node where these two lists intersect. If there is no point of intersection, return <code>null</code>. </p> <p>For example, the following two linked lists begin to intersect at node <code>c1</code>:</p> <p></p> <p>Note that the linked lists do not have any cycles, and you must ensure that the original structure of the linked lists remains unchanged after solving this problem.</p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#example-1","title":"Example 1","text":"<pre><code>Input: listA = [4,1,8,4,5], listB = [5,6,1,8,4,5].\nOutput: Intersected at '8'\n</code></pre>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#example-2","title":"Example 2","text":"<pre><code>Input: listA = [1,9,1,2,4], listB = [3,2,4]\nOutput: Intersected at '2'\n</code></pre>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#example-3","title":"Example 3","text":"<pre><code>Input: listA = [2,6,4], listB = [1,5]\nOutput: No intersection.\n</code></pre>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes of <code>listA</code> is in the <code>m</code>.</li> <li>The number of nodes of <code>listB</code> is in the <code>n</code>.</li> <li><code>1 &lt;= m, n &lt;= 3 * 10^4</code>.</li> <li><code>1 &lt;= Node.val &lt;= 10^5</code>. </li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#follow-up","title":"Follow up","text":"<ul> <li>Could you write a solution that runs in <code>O(m + n)</code> time and use only <code>O(1)</code> memory?</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#solution-1-store-the-nodes","title":"Solution 1: Store the nodes","text":"<p>You can store all nodes of <code>listA</code> then iterate <code>listB</code> to determine which node is the intersection. If none is found, the two lists have no intersection.</p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#example-1_1","title":"Example 1","text":"<ul> <li>Store all nodes of <code>listA = [4,1,8,4,5]</code> in a map.</li> <li>Iterate <code>listB</code> and found node <code>'8'</code> was stored.</li> <li>Return <code>'8'</code>.</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    unordered_map&lt;ListNode*, bool&gt; m;\n    ListNode *node = headA;\n    while (node != nullptr) {\n        m[node] = true;\n        node = node-&gt;next;\n    }\n    node = headB;\n    while (node != nullptr) {\n        if (m.find(node) != m.end()) {\n            return node;\n        }\n        node = node-&gt;next;\n    }\n    return nullptr;\n}\nint main() {\n    {   // Example 1\n        ListNode five(5);\n        ListNode four(4);\n        four.next = &amp;five;\n        ListNode eight(8);\n        eight.next = &amp;four;\n\n        ListNode one1(1);\n        one1.next = &amp;eight;\n        ListNode four1(4);\n        four1.next = &amp;one1;\n\n        ListNode one2(1);\n        one2.next = &amp;eight;\n        ListNode six2(6);\n        six2.next = &amp;one2;\n        ListNode five2(5);\n        five2.next = &amp;six2;\n        cout &lt;&lt; (getIntersectionNode(&amp;four1, &amp;five2) == &amp;eight) &lt;&lt; endl;\n    }\n    {   // Example 2\n        ListNode four(4);\n        ListNode two(2);\n        two.next = &amp;four;\n\n        ListNode one12(1);\n        one12.next = &amp;two;\n        ListNode nine1(9);\n        nine1.next = &amp;one12;\n        ListNode one11(1);\n        one11.next = &amp;nine1;\n\n        ListNode three2(3);\n        three2.next = &amp;two;\n        cout &lt;&lt; (getIntersectionNode(&amp;one11, &amp;three2) == &amp;two) &lt;&lt; endl;\n    }\n    {   // Example 3\n        ListNode four(4);\n        ListNode six(6);\n        six.next = &amp;four;\n        ListNode two(2);\n        two.next = &amp;six;\n\n        ListNode five(5);\n        ListNode one(1);\n        one.next = &amp;five;\n        cout &lt;&lt; (getIntersectionNode(&amp;two, &amp;one) == nullptr) &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>Output:\n1\n1\n1\n</code></pre> <p>This code uses an unordered map to store the nodes of <code>headA</code> while traversing it. Then, it traverses <code>headB</code> and checks if each node in <code>headB</code> exists in the map of nodes from <code>headA</code>. If a common node is found, it returns that node as the intersection point; otherwise, it returns <code>nullptr</code> to indicate no intersection. </p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m + n)</code>, where <code>m</code>, <code>n</code> are the number of nodes of <code>listA</code> and <code>listB</code>.</li> <li>Extra space: <code>O(m)</code>.</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#solution-2-reiterating-the-two-lists-at-the-same-time","title":"Solution 2: Reiterating the two lists at the same time","text":"<p>If the two lists do not share the same tail, they have no intersection. Otherwise, they must intersect at some node.</p> <p>After iterating to find the tail node, you know the length of the two lists. That information gives you a hint of how to reiterate to find the intersection node. </p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#example-1_2","title":"Example 1","text":"<ul> <li>After iterating <code>listA = [4,1,8,4,5]</code>, you find the tail node is <code>'5'</code> and <code>listA.length = 5</code>. </li> <li>After iterating <code>listB = [5,6,1,8,4,5]</code>, you find the tail node is the last <code>'5'</code> and <code>listB.length = 6</code>.</li> <li>The two lists share the same tail. They must intersect at some node.</li> <li>To find that intersection node, you have to reiterate the two lists.</li> <li>Since <code>listB.length = 6 &gt; 5 = listA.length</code>, you can start iterating <code>listB</code> first until the number of its remaining nodes is the same as <code>listA</code>. In this case, it is the node <code>'6'</code> of <code>listB</code>.</li> <li>Now you can iterate them at the same time to find which node is shared.</li> <li>Found and return the intersection node <code>'8'</code>.</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) \n{\n    int lengthA = 0;\n    ListNode *nodeA = headA;\n    while (nodeA-&gt;next != nullptr) {\n        lengthA++;\n        nodeA = nodeA-&gt;next;\n    }\n    int lengthB = 0;\n    ListNode *nodeB = headB;\n    while (nodeB-&gt;next != nullptr) {\n        lengthB++;\n        nodeB = nodeB-&gt;next;\n    }\n    // not the same tail -&gt; no intersection\n    if (nodeA != nodeB) {\n        return nullptr;\n    }\n    nodeA = headA;\n    nodeB = headB;\n    // find the nodeA in listA and nodeB in listB\n    // that make two lists have the same length \n    while (lengthA &gt; lengthB) {\n        nodeA = nodeA-&gt;next;\n        lengthA--;\n    }\n    while (lengthB &gt; lengthA) {\n        nodeB = nodeB-&gt;next;\n        lengthB--;\n    }\n    // find the intersection\n    while (nodeA != nodeB) {\n        nodeA = nodeA-&gt;next;\n        nodeB = nodeB-&gt;next;\n    }\n    return nodeA;\n}\nint main() {\n    {   // Example 1\n        ListNode five(5);\n        ListNode four(4);\n        four.next = &amp;five;\n        ListNode eight(8);\n        eight.next = &amp;four;\n\n        ListNode one1(1);\n        one1.next = &amp;eight;\n        ListNode four1(4);\n        four1.next = &amp;one1;\n\n        ListNode one2(1);\n        one2.next = &amp;eight;\n        ListNode six2(6);\n        six2.next = &amp;one2;\n        ListNode five2(5);\n        five2.next = &amp;six2;\n        cout &lt;&lt; (getIntersectionNode(&amp;four1, &amp;five2) == &amp;eight) &lt;&lt; endl;\n    }\n    {   // Example 2\n        ListNode four(4);\n        ListNode two(2);\n        two.next = &amp;four;\n\n        ListNode one12(1);\n        one12.next = &amp;two;\n        ListNode nine1(9);\n        nine1.next = &amp;one12;\n        ListNode one11(1);\n        one11.next = &amp;nine1;\n\n        ListNode three2(3);\n        three2.next = &amp;two;\n        cout &lt;&lt; (getIntersectionNode(&amp;one11, &amp;three2) == &amp;two) &lt;&lt; endl;\n    }\n    {   // Example 3\n        ListNode four(4);\n        ListNode six(6);\n        six.next = &amp;four;\n        ListNode two(2);\n        two.next = &amp;six;\n\n        ListNode five(5);\n        ListNode one(1);\n        one.next = &amp;five;\n        cout &lt;&lt; (getIntersectionNode(&amp;two, &amp;one) == nullptr) &lt;&lt; endl;\n    }\n}\n</code></pre> <pre><code>Output:\n1\n1\n1\n</code></pre> <p>This improved solution finds the intersection of two linked lists by first determining their lengths and adjusting the pointers so that they start from the same relative position to the intersection point. Then, it iterates through both linked lists until it finds the common intersection node. </p>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m + n)</code>, where <code>m</code>, <code>n</code> are the number of nodes of <code>listA</code> and <code>listB</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#implementation-tip","title":"Implementation tip","text":"<ul> <li>The technique used in Solution 2 is known as the Two-pointer technique since you use two pointers to iterate the list at the same time.</li> </ul>"},{"location":"source/Linked_List/160_Intersection_of_Two_Linked_Lists/#exercise","title":"Exercise","text":"<ul> <li>Minimum Index Sum of Two Lists.</li> </ul>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/","title":"Remove Linked List Elements","text":""},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#problem-statement","title":"Problem statement","text":"<p>You are given the starting node, <code>head</code>, of a linked list, and an integer <code>val</code>. Your task is to eliminate all nodes from the linked list that have a value equal to <code>val</code>. After removing these nodes, return the new starting node of the modified linked list.</p>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#example-1","title":"Example 1","text":"<pre><code>Input: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n</code></pre>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#example-2","title":"Example 2","text":"<pre><code>Input: head = [], val = 1\nOutput: []\n</code></pre>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#example-3","title":"Example 3","text":"<pre><code>Input: head = [7,7,7,7], val = 7\nOutput: []\n</code></pre>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the list is in the range <code>[0, 10^4]</code>.</li> <li><code>1 &lt;= Node.val &lt;= 50</code>.</li> <li><code>0 &lt;= val &lt;= 50</code>.</li> </ul>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#linked-list-data-structure","title":"Linked list data structure","text":"<pre><code>struct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n</code></pre>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#solution-1-consider-the-special-case-for-head","title":"Solution 1: Consider the special case for head","text":"<p>Removing a node <code>A</code> in a linked list means instead of connecting the previous node <code>A.pre</code> to <code>A</code>, you connect <code>A.pre</code> to <code>A.next</code>.</p>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* removeElements(ListNode* head, int val) {\n    // remove head if its value matches val\n    while (head &amp;&amp; head-&gt;val == val) {\n        head = head-&gt;next;\n    }\n    if (head == nullptr) return nullptr;\n    ListNode* pre = head;\n    while (pre-&gt;next) {\n        if (pre-&gt;next-&gt;val == val) {\n            // remove pre-&gt;next\n            pre-&gt;next = pre-&gt;next-&gt;next;\n        } else {\n            pre = pre-&gt;next;\n        }\n    }\n    return head;\n}\nvoid print(const ListNode* head) {\n    ListNode* node = head;\n    std::cout &lt;&lt; \"[\";\n    while (node) {\n        std::cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode sixb(6);\n    ListNode five(5, &amp;sixb);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);\n    ListNode sixa(6, &amp;three);\n    ListNode two(2, &amp;sixa);\n    ListNode head(1, &amp;two);\n    ListNode* newHead = removeElements(&amp;head, 6);\n    print(newHead);\n    newHead = removeElements(nullptr, 1);\n    print(newHead);\n    ListNode seven4(7);\n    ListNode seven3(7, &amp;seven4);\n    ListNode seven2(7, &amp;seven3);\n    ListNode seven1(7, &amp;seven2);\n    newHead = removeElements(&amp;seven1, 7);\n    print(newHead);\n}\n</code></pre> <pre><code>Output:\n[1,2,3,4,5,]\n[]\n[]\n</code></pre> <p>This solution efficiently removes nodes with a specified value <code>val</code> from a linked list by using two pointers (<code>head</code> and <code>pre</code>) to traverse the list and update the <code>next</code> pointers to bypass nodes with the specified value. </p>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes.</li> <li>Memory: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#solution-2-create-a-previous-indexdummy-node-for-head","title":"Solution 2: Create a previous {index}<code>dummy node</code> for head","text":"<p><code>head</code> has no <code>pre</code>. You can create a dummy node for <code>head.pre</code> whose values is out of the contraints. </p>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* removeElements(ListNode* head, int val) {\n\n    // create a new head of value 2023 &gt; 50\n    ListNode preHead(2023, head);\n    ListNode* pre = &amp;preHead;\n    while (pre-&gt;next) {\n        if (pre-&gt;next-&gt;val == val) {\n            pre-&gt;next = pre-&gt;next-&gt;next;\n        } else {\n            pre = pre-&gt;next;\n        }\n    }\n    return preHead.next;\n}\nvoid print(const ListNode* head) {\n    ListNode* node = head;\n    std::cout &lt;&lt; \"[\";\n    while (node) {\n        std::cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode sixb(6);\n    ListNode five(5, &amp;sixb);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);\n    ListNode sixa(6, &amp;three);\n    ListNode two(2, &amp;sixa);\n    ListNode head(1, &amp;two);\n    ListNode* newHead = removeElements(&amp;head, 6);\n    print(newHead);\n\n    newHead = removeElements(nullptr, 1);\n    print(newHead);\n\n    ListNode seven4(7);\n    ListNode seven3(7, &amp;seven4);\n    ListNode seven2(7, &amp;seven3);\n    ListNode seven1(7, &amp;seven2);\n    newHead = removeElements(&amp;seven1, 7);\n    print(newHead);\n}\n</code></pre> <pre><code>Output:\n[1,2,3,4,5,]\n[]\n[]\n</code></pre> <p>This solution creates a <code>preHead</code> node with a value of <code>2023</code> (an arbitrary value larger than <code>50</code>) and sets its <code>next</code> pointer to point to the original <code>head</code> of the linked list. </p> <p>The purpose of this <code>preHead</code> node is to serve as the dummy or sentinel node at the beginning of the linked list. Having a <code>preHead</code> node simplifies the code because it eliminates the need to handle the special case of removing nodes from the beginning of the list separately.</p> <p>The remaining code is the same.</p>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes.</li> <li>Memory: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#attention","title":"Attention!","text":"<p>Depending on your real situation, in practice, you might need to deallocate memory for the removed nodes; especially when they were allocated by the <code>new</code> operator.</p> <pre><code>ListNode* removeElements(ListNode* head, int val) {\n    ListNode preHead(2022, head);\n    ListNode* pre = &amp;preHead;\n    while (pre-&gt;next) {\n        if (pre-&gt;next-&gt;val == val) {\n            ListNode* node = pre-&gt;next;\n            pre-&gt;next = node-&gt;next;\n            delete node;\n        } else {\n            pre = pre-&gt;next;\n        }\n    }\n    return preHead.next;\n}\n</code></pre>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#key-takeaway","title":"Key takeaway","text":"<ul> <li>In some linked list problems where <code>head</code> needs to be treated as a special case, you can create a previous dummy node for it to adapt the general algorithm.</li> <li>Be careful with memory leak when removing nodes of the linked list containing pointers. </li> </ul>"},{"location":"source/Linked_List/203_Remove_Linked_List_Elements/#exercise","title":"Exercise","text":"<ul> <li>Delete Node in a Linked List.</li> </ul>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/","title":"Merge Two Sorted Lists","text":""},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#problem-statement","title":"Problem statement","text":"<p>Given the starting nodes of two sorted linked lists, <code>list1</code> and <code>list2</code>, your task is to combine these lists into a single sorted linked list. </p> <p>This merged list should be created by connecting the nodes from both <code>list1</code> and <code>list2</code>. Finally, you should return the starting node of the resulting merged linked list.</p>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#example-1","title":"Example 1","text":"<pre><code>Input: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n</code></pre>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#example-2","title":"Example 2","text":"<pre><code>Input: list1 = [], list2 = []\nOutput: []\n</code></pre>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#example-3","title":"Example 3","text":"<pre><code>Input: list1 = [], list2 = [0]\nOutput: [0]\n</code></pre>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in both lists is in the range <code>[0, 50]</code>.</li> <li><code>-100 &lt;= Node.val &lt;= 100</code>.</li> <li>Both <code>list1</code> and <code>list2</code> are sorted in non-decreasing order.</li> </ul>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#solution-constructing-a-new-list","title":"Solution: Constructing a new list","text":"<p>For each pair of nodes between the two lists, pick the node having smaller value to append to the new list.</p>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n    if (list1 == nullptr) {\n        return list2;\n    } else if (list2 == nullptr) {\n        return list1;\n    }\n    // identify which list is head of the merged one\n    ListNode* head = list1;\n    if (list2-&gt;val &lt; head-&gt;val) {\n        head = list2;\n        list2 = list2-&gt;next;\n    } else {\n        list1 = list1-&gt;next;\n    }\n    ListNode* node = head;\n    while (list1 &amp;&amp; list2) {\n        // pick the smaller node to append to the new list.\n        if (list1-&gt;val &lt; list2-&gt;val) {\n            node-&gt;next = list1;\n            list1 = list1-&gt;next;\n        } else {\n            node-&gt;next = list2;\n            list2 = list2-&gt;next;\n        }\n        node = node-&gt;next;\n    }\n    if (list1 == nullptr) {\n        node-&gt;next = list2;\n    } else {\n        node-&gt;next = list1;\n    }\n    return head;\n}\nvoid printResult(ListNode* head) {\n    std::cout &lt;&lt; \"[\";\n    while (head) {\n        std::cout &lt;&lt; head-&gt;val &lt;&lt; \",\";\n        head = head-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {   \n    ListNode four1(4);\n    ListNode two1(2, &amp;four1);\n    ListNode one1(1, &amp;two1);\n    ListNode four2(4);\n    ListNode three2(3, &amp;four2);\n    ListNode one2(1, &amp;three2);\n    auto newOne = mergeTwoLists(&amp;one1, &amp;one2);\n    printResult(newOne);\n\n    auto empty = mergeTwoLists(nullptr, nullptr);\n    printResult(empty);\n\n    ListNode zero(0);\n    auto z = mergeTwoLists(nullptr, &amp;zero);\n    printResult(z);\n}\n</code></pre> <pre><code>Output:\n[1,1,2,3,4,4,]\n[]\n[0,]\n</code></pre>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = list1.length + list2.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/21_Merge_Two_Sorted_Lists/#conclusion","title":"Conclusion","text":"<p>This solution merges two sorted linked lists efficiently without using extra space. </p> <p>It identifies the head of the merged list by comparing the values of the first nodes of the input lists. Then, it iterates through both lists, linking nodes in ascending order until one list is exhausted. </p> <p>Finally, it appends the remaining nodes from the non-empty list to the merged list, ensuring the resulting list remains sorted.</p>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/","title":"Swap Nodes in Pairs","text":""},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#problem-statement","title":"Problem statement","text":"<p>You are provided with a linked list. Your goal is to exchange every two adjacent nodes in the list and then return the head of the modified list. </p> <p>You must solve this problem without altering the values within the nodes; you should only modify the arrangement of the nodes themselves. </p>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#example-1","title":"Example 1","text":"<pre><code>Input: head = [1,2,3,4]\nOutput: [2,1,4,3]\n</code></pre>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#example-2","title":"Example 2","text":"<pre><code>Input: head = []\nOutput: []\n</code></pre>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#example-3","title":"Example 3","text":"<pre><code>Input: head = [1]\nOutput: [1]\n</code></pre>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the list is in the range <code>[0, 100]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 100</code>.</li> </ul>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#solution","title":"Solution","text":"<p>Draw a picture of the swapping to identify the correct order of the update.</p> <p></p> <p>Denote <code>(cur, next)</code> the pair of nodes you want to swap and <code>prev</code> be the previous node that links to <code>cur</code>. Here are the steps you need to perform for the swapping. 1. Update the links between nodes. 2. Go to the next pair. </p>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* swapPairs(ListNode* head) {\n    // the list does not have enough nodes to swap\n    if (head == nullptr || head-&gt;next == nullptr) {\n        return head;\n    }\n    ListNode* preNode = nullptr;\n    ListNode* curNode = head; \n    ListNode* nextNode = head-&gt;next;  \n    head = nextNode;\n    while (curNode != nullptr &amp;&amp; nextNode != nullptr) {\n\n        // swap curNode and nextNode\n        curNode-&gt;next = nextNode-&gt;next;\n        nextNode-&gt;next = curNode;\n\n        // update links/pointers after swap\n        if (preNode) {\n            preNode-&gt;next = nextNode;\n        }\n\n        // update nodes for next step\n        preNode = curNode;\n        curNode = curNode-&gt;next;       \n        if (curNode) {\n            nextNode = curNode-&gt;next;\n        }\n    }\n    return head;\n}\nvoid print(const ListNode* head) {\n    ListNode* node = head;\n    std::cout &lt;&lt; \"[\";\n    while (node != nullptr) {\n        std::cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\" &lt;&lt; std::endl;\n}\nint main() {\n    ListNode four(4);\n    ListNode three(3, &amp;four);\n    ListNode two(2, &amp;three);\n    ListNode one(1, &amp;two);    \n    print(swapPairs(&amp;one));\n    ListNode five(5);\n    print(swapPairs(nullptr));\n    print(swapPairs(&amp;five));\n}\n</code></pre> <pre><code>Output:\n[2,1,4,3,]\n[]\n[5,]\n</code></pre>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#conclusion","title":"Conclusion","text":"<p>This solution swaps pairs of nodes in a linked list by adjusting the pointers accordingly. </p> <p>It initializes pointers to the current node (<code>curNode</code>), its next node (<code>nextNode</code>), and the previous node (<code>preNode</code>). Then, it iterates through the list, swapping pairs of nodes by adjusting their <code>next</code> pointers and updating the <code>preNode</code> pointer. </p> <p>This approach efficiently swaps adjacent nodes in the list without requiring additional space, effectively transforming the list by rearranging pointers.</p>"},{"location":"source/Linked_List/24_Swap_Nodes_in_Pairs/#exercise","title":"Exercise","text":"<ul> <li>Swapping Nodes in a Linked List.</li> </ul>"},{"location":"source/Linked_List/2_add_two_numbers/","title":"Add Two Numbers","text":""},{"location":"source/Linked_List/2_add_two_numbers/#problem-statement","title":"Problem statement","text":"<p>You have two linked lists that represent non-negative integers. The digits of these numbers are stored in reverse order, with each node containing a single digit. </p> <p>Your task is to add the two numbers represented by these linked lists and return the result as a new linked list. </p> <p>You can assume that the two numbers don't have leading zeros, except for the number 0 itself.</p>"},{"location":"source/Linked_List/2_add_two_numbers/#example-1","title":"Example 1","text":"<pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</code></pre>"},{"location":"source/Linked_List/2_add_two_numbers/#example-2","title":"Example 2","text":"<pre><code>Input: l1 = [0], l2 = [0]\nOutput: [0]\n</code></pre>"},{"location":"source/Linked_List/2_add_two_numbers/#example-3","title":"Example 3","text":"<pre><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n</code></pre>"},{"location":"source/Linked_List/2_add_two_numbers/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in each linked list is in the range <code>[1, 100]</code>.</li> <li><code>0 &lt;= Node.val &lt;= 9</code>.</li> <li>It is guaranteed that the list represents a number that does not have leading zeros.</li> </ul>"},{"location":"source/Linked_List/2_add_two_numbers/#solution-addition-with-remember","title":"Solution: Addition With Remember","text":"<p>Perform the school addition calculation and store the result in one of the lists. </p> <p>Without loss of generality, let us store the result in <code>l1</code>. Then you might need to extend it when <code>l2</code> is longer than <code>l1</code> and when the result requires one additional node (Example 3).</p>"},{"location":"source/Linked_List/2_add_two_numbers/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    // dummy node to hook the head of the list\n    ListNode prehead;\n\n    // let's use l1's nodes to store result\n    ListNode* node = l1;  \n    prehead.next = node;\n    int sum = 0;\n    while (node) {\n\n        // perform the addition\n        if (l1) {\n            sum += l1-&gt;val;\n            l1 = l1-&gt;next;\n        }\n        if (l2) {\n            sum += l2-&gt;val;\n            l2 = l2-&gt;next;\n        }\n        node-&gt;val = sum % 10;\n\n        // keep track the carry\n        sum /= 10;\n        if (!l1) {      // l1 ends        \n            if (l2) {   // l1 is shorter than l2\n                node-&gt;next = l2;\n            } else if (sum == 1) {  \n                // both l1 and l2 end but the remember is not zero \n                ListNode* newNode = new ListNode(sum);\n                node-&gt;next = newNode;\n            }\n        }\n        node = node-&gt;next;\n    }\n    return prehead.next;\n}\nvoid printResult(ListNode* l) {\n    std::cout &lt;&lt; \"[\";\n    while (l) {\n        std::cout &lt;&lt; l-&gt;val &lt;&lt; \",\";\n        l = l-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    {\n        ListNode three(3);\n        ListNode four1(4, &amp;three);\n        ListNode two(2, &amp;four1);\n        ListNode four2(4);\n        ListNode six(6, &amp;four2);\n        ListNode five(5, &amp;six);\n        printResult(addTwoNumbers(&amp;two, &amp;five));\n    }\n    {\n        ListNode zero1(0);\n        ListNode zero2(0);\n        printResult(addTwoNumbers(&amp;zero1, &amp;zero2));\n    }\n    {\n        ListNode nine0(9);\n        ListNode nine1(9, &amp;nine0);\n        ListNode nine2(9, &amp;nine1);\n        ListNode nine3(9, &amp;nine2);\n        ListNode nine4(9, &amp;nine3);\n        ListNode nine5(9, &amp;nine4);\n        ListNode nine6(9, &amp;nine5);\n        ListNode nine7(9);\n        ListNode nine8(9, &amp;nine7);\n        ListNode nine9(9, &amp;nine8);\n        ListNode nine10(9, &amp;nine9);\n        printResult(addTwoNumbers(&amp;nine6, &amp;nine10));\n    }\n}\n</code></pre> <pre><code>Output:\n[7,0,8,]\n[0,]\n[8,9,9,9,0,0,0,1,]\n</code></pre>"},{"location":"source/Linked_List/2_add_two_numbers/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = max(l1.length, l2.length)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Linked_List/2_add_two_numbers/#conclusion","title":"Conclusion","text":"<p>This solution leverages a dummy node (<code>prehead</code>) to simplify the handling of edge cases and to hook the head of the resulting list. </p> <p>By iterating through both input lists simultaneously and performing addition digit by digit while keeping track of carry, it efficiently computes the sum without the need for additional checks for the head of the resulting list. </p> <p>This approach streamlines the addition process, resulting in a concise and straightforward implementation.</p>"},{"location":"source/Linked_List/2_add_two_numbers/#exercise","title":"Exercise","text":"<ul> <li>Double a Number Represented as a Linked List.</li> </ul>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/","title":"Best Time to Buy and Sell Stock","text":""},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#problem-statement","title":"Problem statement","text":"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i-th</code> day.</p> <p>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p> <p>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#example-1","title":"Example 1","text":"<pre><code>Input: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n</code></pre>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#example-2","title":"Example 2","text":"<pre><code>Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n</code></pre>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= prices.length &lt;= 10^5</code>.</li> <li><code>0 &lt;= prices[i] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":"<p>For each day <code>i</code>, find the day <code>j &gt; i</code> that gives maximum profit.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint maxProfit(const vector&lt;int&gt;&amp; prices) {\n    int maxProfit = 0;\n    for (int i = 0; i &lt; prices.size(); i++) {        \n        for (int j = i + 1; j &lt; prices.size(); j++) {\n            if (prices[j] &gt; prices[i]) {\n                maxProfit = max(maxProfit, prices[j] - prices[i]);\n            }\n        }\n    }\n    return maxProfit;\n}\nint main() {\n    vector&lt;int&gt; prices{7,1,5,3,6,4};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {7,6,4,3,1};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n0\n</code></pre> <p>This solution uses a brute force approach to find the maximum profit. It compares the profit obtained by buying on each day with selling on all subsequent days and keeps track of the maximum profit found. </p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N^2)</code>, where <code>N = prices.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#solution-2-smallest-and-largest-prices","title":"Solution 2: Smallest and largest prices","text":"<p>Given a past day <code>i</code>, the future day <code>j &gt; i</code> that gives the maximum profit is the day that has the largest price which is bigger than <code>prices[i]</code>.</p> <p>Conversely, given a future day <code>j</code>, the past day <code>i &lt; j</code> that gives the maximum profit is the day with the smallest price.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint maxProfit(const vector&lt;int&gt;&amp; prices) {\n    int maxProfit = 0;\n    int i = 0;\n    while (i &lt; prices.size()) {\n        // while prices are going down,\n        // find the bottommost one to start\n        while (i &lt; prices.size() - 1 &amp;&amp; prices[i] &gt;= prices[i + 1]) {\n            i++;\n        }\n        // find the largest price in the future\n        auto imax = max_element(prices.begin() + i, prices.end());\n        // find the smallest price in the past\n        auto imin = min_element(prices.begin() + i, imax);\n        maxProfit = max(maxProfit, *imax - *imin);\n        // next iteration starts after the found largest price \n        i = distance(prices.begin(), imax) + 1;\n    }\n    return maxProfit;\n}\nint main() {\n    vector&lt;int&gt; prices{7,1,5,3,6,4};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {7,6,4,3,1};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {2,4,1,7};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {2,4,1};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n0\n6\n2\n</code></pre> <p>This solution optimally finds the maximum profit by iterating through the array only once, avoiding the need for nested loops. </p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = prices.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#solution-3-only-the-smallest-price","title":"Solution 3: Only the smallest price","text":"<p>Given a future day <code>j</code>, the past day <code>i</code> that gives the maximum profit is the day with minimum price.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#code_2","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint maxProfit(const vector&lt;int&gt;&amp; prices) {\n    int maxProfit = 0;\n    // keep track the minimum price so fat\n    int minPrice = prices[0]; \n    for (int i = 1; i &lt; prices.size(); i++)  {\n        // update the minimum price\n        minPrice = min(minPrice, prices[i]);\n        maxProfit = max(maxProfit, prices[i] - minPrice);\n    }\n    return maxProfit;\n}\nint main() {\n    vector&lt;int&gt; prices{7,1,5,3,6,4};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {7,6,4,3,1};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {2,4,1,7};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n    prices = {2,4,1};\n    cout &lt;&lt; maxProfit(prices) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n0\n6\n2\n</code></pre> <p>This solution efficiently computes the maximum profit by iterating through the array only once, maintaining the minimum buying price and updating the maximum profit accordingly.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = prices.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#conclusion","title":"Conclusion","text":"<p>The problem of finding the maximum profit that can be achieved by buying and selling a stock can be efficiently solved using different approaches. Solutions 1, 2, and 3 each offer a different approach to solving the problem, including brute-force iteration, finding local minima and maxima, and maintaining a running minimum price. </p> <p>Solution 3 stands out as the most efficient approach, achieving a linear time complexity by iterating through the prices only once and updating the minimum price seen so far. This approach avoids unnecessary comparisons and achieves the desired result in a single pass through the array.</p>"},{"location":"source/Mathematics/121_Best_Time_to_Buy_and_Sell_Stock/#exercise","title":"Exercise","text":"<ul> <li>Best Time to Buy and Sell Stock II.</li> </ul>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/","title":"Count Sorted Vowel Strings","text":""},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#problem-statement","title":"Problem statement","text":"<p>Given an integer <code>n</code>, return the number of strings of length <code>n</code> that consist only of vowels (<code>a</code>, <code>e</code>, <code>i</code>, <code>o</code>, <code>u</code>) and are lexicographically sorted.</p> <p>A string <code>s</code> is lexicographically sorted if for all valid <code>i</code>, <code>s[i]</code> is the same as or comes before <code>s[i+1]</code> in the alphabet.</p>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#example-1","title":"Example 1","text":"<pre><code>Input: n = 1\nOutput: 5\nExplanation: The 5 sorted strings that consist of vowels only are [\"a\",\"e\",\"i\",\"o\",\"u\"].\n</code></pre>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#example-2","title":"Example 2","text":"<pre><code>Input: n = 2\nOutput: 15\nExplanation: The 15 sorted strings that consist of vowels only are\n[\"aa\",\"ae\",\"ai\",\"ao\",\"au\",\"ee\",\"ei\",\"eo\",\"eu\",\"ii\",\"io\",\"iu\",\"oo\",\"ou\",\"uu\"].\nNote that \"ea\" is not a valid string since 'e' comes after 'a' in the alphabet.\n</code></pre>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#example-3","title":"Example 3","text":"<pre><code>Input: n = 33\nOutput: 66045\n</code></pre>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n &lt;= 50</code>. </li> </ul>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#solution-1-finding-the-pattern","title":"Solution 1: Finding the pattern","text":"<p>Let us find the relationship of the strings between the vowels.</p>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#example-3_1","title":"Example 3","text":"<p>For <code>n = 3</code>:</p> <ul> <li>There is (always) only one string starting from <code>u</code>, which is <code>uuu</code>.</li> <li>There are 3 strings starting from <code>o</code>: <code>ooo</code>, <code>oou</code> and <code>ouu</code>.</li> <li>There are 6 strings starting from <code>i</code>: <code>iii</code>, <code>iio</code>, <code>iiu</code>, <code>ioo</code>, <code>iou</code>, <code>iuu</code>.</li> <li>There are 10 strings starting from <code>e</code>: <code>eee</code>, <code>eei</code>, <code>eeo</code>, <code>eeu</code>, <code>eii</code>, <code>eio</code>, <code>eiu</code>, <code>eoo</code>, <code>eou</code>, <code>euu</code>.</li> <li>There are 15 strings starting from <code>a</code>: <code>aaa</code>, <code>aae</code>, <code>aai</code>, <code>aao</code>, <code>aau</code>, <code>aee</code>, <code>aei</code>, <code>aeo</code>, <code>aeu</code>, <code>aii</code>, <code>aio</code>, <code>aiu</code>, <code>aoo</code>, <code>aou</code>, <code>auu</code>.</li> <li>In total: there are 35 strings that satisfy the problem.</li> </ul>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#findings","title":"Findings","text":"<p>In Example 3, if you ignore the leading vowel of those strings, then the shorted strings of the line above all appear in the ones of the line below and the remaining strings of the line below come from <code>n = 2</code>.</p> <p>More precisely:</p> <ul> <li>All the shorted strings <code>oo</code>, <code>ou</code> and <code>uu</code> starting from <code>o</code> appear on the ones starting from <code>i</code>. The remaining <code>ii</code>, <code>io</code>, <code>iu</code> starting from <code>i</code> come from the strings of length <code>n = 2</code> (see Example 2).</li> <li>Similarly, all shorted strings <code>ii</code>, <code>io</code>, <code>iu</code>, <code>oo</code>, <code>ou</code>, <code>uu</code> starting from <code>i</code> appear on the ones starting from <code>e</code>. The remaining <code>ee</code>, <code>ei</code>, <code>eo</code>, <code>eu</code> come from <code>n = 2</code>.</li> <li>And so on.</li> </ul> <p>That leads to the following recursive relationship.</p> <p>Let <code>S(x, n)</code> be the number of strings of length <code>n</code> starting from a vowel <code>x</code>.  Then</p> <ul> <li><code>S('o', n) = S('o', n - 1) + S('u', n)</code> for all <code>n &gt; 1</code>.</li> <li><code>S('i', n) = S('i', n - 1) + S('o', n)</code> for all <code>n &gt; 1</code>.</li> <li><code>S('e', n) = S('e', n - 1) + S('i', n)</code> for all <code>n &gt; 1</code>.</li> <li><code>S('a', n) = S('a', n - 1) + S('e', n)</code> for all <code>n &gt; 1</code>.</li> <li><code>S(x, 1) = 1</code> for all vowels <code>x</code>.</li> <li><code>S('u', n) = 1</code> for all <code>n &gt;= 1</code>.</li> </ul> <p>For this problem, you want to compute </p> <pre><code>S(n) = S('a', n) + S('e', n) + S('i', n) + S('o', n) + S('u', n).\n</code></pre>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint countVowelStrings(int n) {\n    int a, e, i, o, u;\n    a = e = i = o = u = 1;\n    while (n &gt; 1) {\n        o += u;\n        i += o;\n        e += i;\n        a += e;\n        n--;\n    }\n    return a + e + i + o + u;\n}\nint main() {\n    cout &lt;&lt; countVowelStrings(1) &lt;&lt; endl;\n    cout &lt;&lt; countVowelStrings(2) &lt;&lt; endl;\n    cout &lt;&lt; countVowelStrings(33) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n15\n66045\n</code></pre> <p>This solution efficiently computes the count of vowel strings of length <code>n</code> using dynamic programming, updating the counts based on the previous lengths to avoid redundant calculations. </p>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#solution-2-the-math-behind-the-problem","title":"Solution 2: The math behind the problem","text":"<p>The strings of length <code>n</code> you want to count are formed by a number of <code>'a'</code>, then some number of <code>'e'</code>, then some number of  <code>'i'</code>, then some number of <code>'o'</code> and finally some number of <code>'u'</code>. </p> <p>So it looks like this</p> <pre><code>s = \"aa..aee..eii..ioo..ouu..u\".\n</code></pre> <p>And you want to count how many possibilities of such strings of length <code>n</code>.</p> <p>One way to count it is using combinatorics in mathematics. </p> <p>If you separate the groups of vowels by <code>'|'</code> like this </p> <pre><code>s = \"aa..a|ee..e|ii..i|oo..o|uu..u\",\n</code></pre> <p>the problem becomes counting how many ways of putting those 4 separators <code>'|'</code> to form a string of length <code>n + 4</code>. </p> <p>In combinatorics, the solution is $\\binom{n + 4}{4}$, where $\\binom{n}{k}$ is the binomial coefficient:</p> <p>$$ \\binom{n}{k} = \\frac{n!}{k!(n-k)!}. $$</p> <p>The final number of strings is</p> <p>$$ \\binom{n + 4}{4} = \\frac{(n + 4)!}{4!n!} = \\frac{(n+1)(n+2)(n+3)(n+4)}{24}. $$</p>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint countVowelStrings(int n) {    \n    return (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24;\n}\nint main() {\n    cout &lt;&lt; countVowelStrings(1) &lt;&lt; endl;\n    cout &lt;&lt; countVowelStrings(2) &lt;&lt; endl;\n    cout &lt;&lt; countVowelStrings(33) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n15\n66045\n</code></pre>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(1)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/1641_Count_Sorted_Vowel_Strings/#conclusion","title":"Conclusion","text":"<p>The problem of counting the number of strings of length <code>n</code> that consist of the vowels 'a', 'e', 'i', 'o', and 'u' in sorted order can be efficiently solved using combinatorial techniques. Solution 1 uses dynamic programming to iteratively calculate the count of strings for each length up to <code>n</code>, updating the counts based on the previous counts. This approach efficiently computes the count of sorted vowel strings for the given length <code>n</code> without requiring excessive memory usage or computational overhead.</p> <p>Solution 2 offers a more direct approach by utilizing a combinatorial formula to calculate the count of sorted vowel strings directly based on the given length <code>n</code>. By leveraging the combinatorial formula, this solution avoids the need for iterative calculations and achieves the desired result more efficiently.</p>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/","title":"Concatenation of Consecutive Binary Numbers","text":""},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#problem-statement","title":"Problem statement","text":"<p>Given an integer <code>n</code>, return the decimal value of the binary string formed by concatenating the binary representations of <code>1</code> to <code>n</code> in order, modulo <code>10^9 + 7</code>.</p>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#example-1","title":"Example 1","text":"<pre><code>Input: n = 1\nOutput: 1\nExplanation: \"1\" in binary corresponds to the decimal value 1. \n</code></pre>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#example-2","title":"Example 2","text":"<pre><code>Input: n = 3\nOutput: 27\nExplanation: In binary, 1, 2, and 3 corresponds to \"1\", \"10\", and \"11\".\nAfter concatenating them, we have \"11011\", which corresponds to the decimal value 27.\n</code></pre>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#example-3","title":"Example 3","text":"<pre><code>Input: n = 12\nOutput: 505379714\nExplanation: The concatenation results in \"1101110010111011110001001101010111100\".\nThe decimal value of that is 118505380540.\nAfter modulo 10^9 + 7, the result is 505379714.\n</code></pre>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n &lt;= 10^5</code>.</li> </ul>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#solution-recursive","title":"Solution: Recursive","text":"<p>There must be some relationship between the result of <code>n</code> and the result of <code>n - 1</code>. </p> <p>First, let us list some first values of <code>n</code>.</p> <ul> <li>For <code>n = 1</code>: the final binary string is <code>\"1\"</code>, its decimal value is <code>1</code>.</li> <li>For <code>n = 2</code>: the final binary string is <code>\"110\"</code>, its decimal value is <code>6</code>.</li> <li>For <code>n = 3</code>: the final binary string is <code>\"11011\"</code>, its decimal value is <code>27</code>.</li> </ul> <p>Look at <code>n = 3</code>, you can see the relationship between the decimal value of <code>\"11011\"</code> and the one of <code>\"110\"</code> (of <code>n = 2</code>) is:</p> <pre><code>27 = 6 * 2^2 + 3\nDec(\"11011\") = Dec(\"110\") * 2^num_bits(\"11\") + Dec(\"11\")\nResult(3) = Result(2) * 2^num_bits(3) + 3.\n</code></pre> <p>The same equation for <code>n = 2</code>:</p> <pre><code>6 = 1 * 2^2 + 2\nDec(\"110\") = Dec(\"1\") * 2^num_bits(\"10\") + Dec(\"10\")\nResult(2) = Result(1) * 2^num_bits(2) + 2.\n</code></pre> <p>In general, the recursive relationship between <code>n</code> and <code>n - 1</code> is:</p> <pre><code>Result(n) = Result(n - 1) * 2^num_bits(n) + n.\n</code></pre>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#code","title":"Code","text":"<pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\nint concatenatedBinary(int n) {\n    unsigned long long result = 1;\n    for (int i = 2; i &lt;= n; i++) {\n        const int num_bits = std::log2(i) + 1;        \n        result = ((result &lt;&lt; num_bits) + i) % 1000000007;\n    }\n    return result;\n}\nint main() {\n    std::cout &lt;&lt; concatenatedBinary(1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; concatenatedBinary(3) &lt;&lt; std::endl;\n    std::cout &lt;&lt; concatenatedBinary(12) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n27\n505379714\n</code></pre>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*logn)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/1680_Concatenation_of_Consecutive_Binary_Numbers/#conclusion","title":"Conclusion","text":"<p>This solution efficiently calculates the concatenated binary representation of integers from <code>1</code> to <code>n</code>, using bitwise operations and modular arithmetic. Note that <code>a &lt;&lt; t</code> is equivalent to <code>a * 2^t</code>.</p>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/","title":"Excel Sheet Column Number","text":"<p>% Easy </p>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#problem-statement","title":"Problem statement","text":"<p>Given a string <code>columnTitle</code> that represents the column title as appears in an Excel sheet, return its corresponding column number.</p> <p>For example:</p> <pre><code>A -&gt; 1\nB -&gt; 2\nC -&gt; 3\n...\nZ -&gt; 26\nAA -&gt; 27\nAB -&gt; 28 \n...\n</code></pre>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#example-1","title":"Example 1","text":"<pre><code>Input: columnTitle = \"A\"\nOutput: 1\n</code></pre>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#example-2","title":"Example 2","text":"<pre><code>Input: columnTitle = \"AB\"\nOutput: 28\n</code></pre>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#example-3","title":"Example 3","text":"<pre><code>Input: columnTitle = \"ZY\"\nOutput: 701\n</code></pre>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= columnTitle.length &lt;= 7</code>.</li> <li><code>columnTitle</code> consists only of uppercase English letters.</li> <li><code>columnTitle</code> is in the range <code>[\"A\", \"FXSHRXW\"]</code>.</li> </ul>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#solution-finding-the-pattern","title":"Solution: Finding The Pattern","text":"<p>Let us write down some other <code>columnTitle</code> strings and its value.</p> <pre><code>\"A\"   =  1\n\"Z\"   =  26\n\"AA\"  =  27\n\"AZ\"  =  52\n\"ZZ\"  =  702\n\"AAA\" =  703\n</code></pre> <p>Then try to find the pattern</p> <pre><code>\"A\"   =  1    =  1\n\"Z\"   =  26   =  26\n\"AA\"  =  27   =  26 + 1\n\"AZ\"  =  52   =  26 + 26\n\"ZZ\"  =  702  =  26*26 + 26\n\"AAA\" =  703  =  26*26 + 26 + 1\n</code></pre> <p>If you map <code>'A' = 1, ..., 'Z' = 26</code>, the values can be rewritten as</p> <pre><code>\"A\"   =  1    =  'A'\n\"Z\"   =  26   =  'Z'\n\"AA\"  =  27   =  26*'A' + 'A'\n\"AZ\"  =  52   =  26*'A' + 'Z'\n\"ZZ\"  =  702  =  26*'Z' + 'Z'\n\"AAA\" =  703  =  26*26*'A' + 26*'A' + 'A'\n</code></pre> <p>In general the formula for a string <code>columnTitle = abcd</code> is</p> <pre><code>abcd = 26^3*a + 26^2*b + 26*c + d,\n</code></pre> <p>where <code>a, b, c, d</code> are some uppercase English letters <code>A, ..., Z</code>.</p> <p>Longer <code>columnTitle</code>s will have bigger leading exponents of <code>26</code>.</p>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint titleToNumber(const string&amp; columnTitle) {\n    int column = 0; \n    for (auto&amp; c : columnTitle) {\n        // The ASCII value of 'A' is 65.\n        column = 26*column + (c - 64); \n    }\n    return column;\n}\nint main() {\n    cout &lt;&lt; titleToNumber(\"A\") &lt;&lt; endl;\n    cout &lt;&lt; titleToNumber(\"AB\") &lt;&lt; endl;\n    cout &lt;&lt; titleToNumber(\"ZY\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n28\n701\n</code></pre> <p>The solution calculates the decimal representation of the Excel column title by processing each character and updating the result. </p>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = columnTitle.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#implementation-notes","title":"Implementation notes","text":"<ol> <li> <p>There are many ways to compute the series     <code>text     26^3*a + 26^2*b + 26*c + d.</code>     If you write it as      <code>text     26*(26*(26*(0 + a) + b) + c) + d,</code>     you get the loop in the code above.</p> </li> <li> <p>To map <code>'A' = 1, ..., 'Z' = 26</code>, you can use their ASCII values (<code>'A' = 65, ..., 'Z' = 90</code>) minus <code>64</code>.</p> </li> <li>The parentheses around <code>(c - 64)</code> is needed. Otherwise the value of <code>columnTitle = \"FXSHRXW\"</code> makes <code>26*column + c</code> exceed the limit of <code>int</code> before it subtracts <code>64</code>. </li> </ol>"},{"location":"source/Mathematics/171_Excel_Sheet_Collumn_Number/#exercise","title":"Exercise","text":"<ul> <li>Excel Sheet Column Title.</li> </ul>"},{"location":"source/Mathematics/279_Perfect_Squares/","title":"Perfect Squares","text":""},{"location":"source/Mathematics/279_Perfect_Squares/#problem-statement","title":"Problem statement","text":"<p>Given an integer <code>n</code>, return the least number of perfect square numbers that sum to <code>n</code>.</p> <p>A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-1","title":"Example 1","text":"<pre><code>Input: n = 9\nOutput: 1\nExplanation: 9 is already a perfect square.\n</code></pre>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-2","title":"Example 2","text":"<pre><code>Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n</code></pre>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-3","title":"Example 3","text":"<pre><code>Input: n = 7\nOutput: 4\nExplanation: 7 = 4 + 1 + 1 + 1.\n</code></pre>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-4","title":"Example 4","text":"<pre><code>Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\n</code></pre>"},{"location":"source/Mathematics/279_Perfect_Squares/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= n &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Mathematics/279_Perfect_Squares/#solution-1-dynamic-programming","title":"Solution 1: Dynamic Programming","text":"<p>Let us call the function to be computed <code>numSquares(n)</code>, which calculates the least number of perfect squares that sum to <code>n</code>.</p> <p>Here are the findings. 1. If <code>n</code> is already a perfect square then <code>numSquares(n) = 1</code>. 2. Otherwise, it could be written as <code>n = 1 + (n-1)</code>, or <code>n = 4 + (n-4)</code>, or <code>n = 9 + (n-9)</code>, etc. which means <code>n</code> is a sum of a perfect square (<code>1, 4</code> or <code>9</code>, etc.) and another number <code>m &lt; n</code>. That leads to the problems <code>numSquares(m)</code> of smaller values <code>m</code>. 3. If you have gotten the results of the smaller problems <code>numSquares(n-1)</code>, <code>numSquares(n-4)</code>, <code>numSquares(n-9)</code>, etc. then <code>numSquares(n) = 1 + the minimum of those results</code>.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-4_1","title":"Example 4","text":"<p><code>n = 12</code> is not a perfect square. It can be written as <code>n = 1 + 11 = 4 + 8 = 9 + 3</code>. - For <code>m = 11</code>, it is not a perfect square and can be written as <code>m = 1 + 10 = 4 + 7 = 9 + 2</code>. - For <code>m = 8</code>, it is not a perfect square and can be written as <code>m = 1 + 7 = 4 + 4</code> (matched). You get <code>numSquares(8) = 2</code>. - For <code>m = 3</code>, it is not a perfect square and can be written as <code>m = 1 + 2</code>.</p> <p>You can continue to compute <code>numSquares(m)</code> for other values <code>m</code> in this recursive process. But you can see the case of <code>m = 8</code> was already the best solution. And <code>numSquares(12) = 1 + numSquares(8) = 1 + 2 = 3</code>, which is the case of <code>n = 12 = 4 + 4 + 4</code>.</p> <p>To improve runtime, you can apply dynamic programming to cache the <code>numSquares(n)</code> that you have computed.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\n//! @return         the least number of perfect squares that sum to n\n//! @param[out] ns  a map stores all intermediate results\nint nsq(int n, unordered_map&lt;int, int&gt;&amp; ns) {\n    auto it = ns.find(n);\n    if (it != ns.end()) {\n        return it-&gt;second;\n    }\n    const int sq = sqrt(n);\n    if (sq * sq == n) {\n        // n is already a perfect square\n        ns[n] = 1;\n        return 1;\n    }\n    // if n is written as 1 + 1 + .. + 1,\n    // maximum of result is n\n    int result = n;\n    // finding the minimum nsq(n - i*i) across all i &lt;= sqrt(n)\n    for (int i = 1; i &lt;= sq; i++) {\n        // \n        result = min(result, nsq(n - i*i, ns));\n    }\n    // write n as imin^2 + (n - imin^2)\n    ns[n] = result + 1;\n    return ns[n];\n}\nint numSquares(int n) {\n    unordered_map&lt;int, int&gt; ns;\n    return nsq(n, ns);\n}\nint main() {\n    cout &lt;&lt; numSquares(12) &lt;&lt; endl;\n    cout &lt;&lt; numSquares(13) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre> <p>The key idea of this algorithm is to build the solution incrementally, starting from the smallest perfect squares, and use memoization to store and retrieve intermediate results. By doing this, it efficiently finds the minimum number of perfect squares required to sum up to <code>n</code>. </p>"},{"location":"source/Mathematics/279_Perfect_Squares/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*sqrt(n)) = O(n^(3/2))</code> due to the nested loops and recursive calls.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Mathematics/279_Perfect_Squares/#solution-2-number-theory","title":"Solution 2: Number Theory","text":"<p>The dynamic programming solution above is good enough. But for those who are interested in Algorithmic Number Theory, there is a very interesting theorem that can solve the problem directly without recursion.</p> <p>It is called Lagrange's Four-Square Theorem, which states</p> <p>every natural number can be represented as the sum of four integer\u00a0squares.</p> <p>It was proven by Lagrange in 1770.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-4_2","title":"Example 4","text":"<p><code>n = 12 = 4 + 4 + 4 + 0</code> or <code>12 = 1 + 1 + 1 + 9</code>.</p> <p>Applying to our problem, <code>numSquares(n)</code> can only be 1, 2, 3, or 4. Not more.</p> <p>It turns into the problem of</p> <p>identifying when <code>numSquares(n)</code> returns 1, 2, 3, or 4.</p> <p>Here are the cases. 1. If <code>n</code> is a perfect square, <code>numSquares(n) = 1</code>. 2. There is another theorem, Legendre's Three-Square Theorem, which states that <code>numSquares(n)</code> cannot be 1, 2, or 3 if <code>n</code> can be expressed as</p> <p>$$ n = 4^a(8\\cdot b + 7), $$</p> <p>where $a$, $b$ are nonnegative integers. </p> <p>In other words, <code>numSquares(n) = 4</code> if <code>n</code> is of this form.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#example-3_1","title":"Example 3","text":"<p>$n = 7 = 4^0(8\\cdot 0 + 7)$. It can only be written as <code>7 = 4 + 1 + 1 + 1</code>.</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nbool isSquare(int n) {\n    int sq = sqrt(n);\n    return sq * sq == n;\n}\nint numSquares(int n) {\n    if (isSquare(n)) {\n        return 1;\n    }\n    // Legendre's three-square theorem\n    int m = n;\n    while (m % 4 == 0) {\n        m /= 4;\n    }\n    if (m % 8 == 7) {\n        return 4;\n    }\n    const int sq = sqrt(n);\n    for (int i = 1; i &lt;= sq; i++) {\n        if (isSquare(n - i*i)) {\n            return 2;\n        }\n    }\n    return 3;\n}\nint main() {\n    cout &lt;&lt; numSquares(12) &lt;&lt; endl;\n    cout &lt;&lt; numSquares(13) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre> <p>This solution finds the minimum number of perfect squares required to sum up to the given integer <code>n</code> by first applying mathematical properties and Legendre's three-square theorem to simplify the problem and then using a loop to find possible combinations of two perfect squares. </p>"},{"location":"source/Mathematics/279_Perfect_Squares/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(sqrt(n)) = O(n^(1/2))</code>, and it does not require dynamic programming or memoization.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/279_Perfect_Squares/#solution-3-further-performance-improvement","title":"Solution 3: Further performance improvement","text":"<p>Lagrange's Four-Square Theorem and Legendre's Three-Square Theorem are so powerful to solve this problem. But you can still do a little more algebra to improve further the runtime of the implementation above.</p> <p>Instead of looping over <code>sqrt(n)</code> in the final <code>for</code> loop, you can prove that this loop over <code>sqrt(m)</code> is enough. That will improve runtime a lot since <code>m</code> is much less than <code>n</code>.</p> <p>Let <code>m</code> be the reduced value of <code>n</code> after the Legendre's <code>while</code> loop. It satisfies</p> <p>$$ n = 4^a \\cdot m. $$</p> <p>We will prove that <code>numSquares(n) = numSquares(m)</code>.</p> <p>In fact, if <code>m</code> is written as $m = x^2 + y^2 + z^2$, where $x$, $y$, $z$ are nonnegative integers. Then</p> <p>$$ n = 4^a \\cdot m = (2^a)^2 \\cdot m = (2^a \\cdot x)^2 + (2^a \\cdot y)^2 + (2^a \\cdot z)^2. $$</p> <p>In other words, <code>numSquares(n) = numSquares(m)</code>.</p> <p>Now you can change directly the value <code>n</code> during the Legendre's <code>while</code> loop without affecting the final result. </p>"},{"location":"source/Mathematics/279_Perfect_Squares/#code_2","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\nbool isSquare(int n) {\n    int sq = sqrt(n);\n    return sq * sq == n;\n}\nint numSquares(int n) {\n    if (isSquare(n)) {\n        return 1;\n    }\n    // Legendre's three-square theorem\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    if (n % 8 == 7) {\n        return 4;\n    }\n    const int sq = sqrt(n);\n    for (int i = 1; i &lt;= sq; i++) {\n        if (isSquare(n - i*i)) {\n            return 2;\n        }\n    }\n    return 3;\n}\nint main() {\n    cout &lt;&lt; numSquares(12) &lt;&lt; endl;\n    cout &lt;&lt; numSquares(13) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre>"},{"location":"source/Mathematics/279_Perfect_Squares/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(sqrt(n)) = O(n^(1/2))</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/279_Perfect_Squares/#conclusion","title":"Conclusion","text":"<ul> <li>The title of this coding challenge (Perfect squares) gives you a hint it is more about mathematics than coding technique.</li> <li>It is amazing from Lagrange's Four-Square Theorem there are only four possibilities for the answer to the problem. Not many people knowing it.</li> <li>You can get an optimal solution to a coding problem when you know something about the mathematics behind it.</li> </ul> <p>Hope you learn something interesting from this code challenge.</p> <p>Have fun with coding and mathematics!</p>"},{"location":"source/Mathematics/279_Perfect_Squares/#exercise","title":"Exercise","text":"<ul> <li>Ways to Express an Integer as Sum of Powers.</li> </ul>"},{"location":"source/Mathematics/326_Power_of_Three/","title":"Power of Three","text":""},{"location":"source/Mathematics/326_Power_of_Three/#problem-statement","title":"Problem statement","text":"<p>Given an integer <code>n</code>, return <code>true</code> if it is a power of three. Otherwise, return <code>false</code>.</p> <p>An integer <code>n</code> is a power of three, if there exists an integer <code>x</code> such that <code>n == 3^x</code>.</p>"},{"location":"source/Mathematics/326_Power_of_Three/#example-1","title":"Example 1","text":"<pre><code>Input: n = 27\nOutput: true\nExplanation: 27 = 3^3.\n</code></pre>"},{"location":"source/Mathematics/326_Power_of_Three/#example-2","title":"Example 2","text":"<pre><code>Input: n = 0\nOutput: false\nExplanation: There is no x where 3^x = 0.\n</code></pre>"},{"location":"source/Mathematics/326_Power_of_Three/#example-3","title":"Example 3","text":"<pre><code>Input: n = -1\nOutput: false\nExplanation: There is no x where 3^x = (-1).\n</code></pre>"},{"location":"source/Mathematics/326_Power_of_Three/#constraints","title":"Constraints","text":"<ul> <li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code>.</li> </ul>"},{"location":"source/Mathematics/326_Power_of_Three/#follow-up","title":"Follow up","text":"<ul> <li>Could you solve it without loops/recursion?</li> </ul>"},{"location":"source/Mathematics/326_Power_of_Three/#solution-1-repeat-the-division","title":"Solution 1: Repeat the division","text":""},{"location":"source/Mathematics/326_Power_of_Three/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nbool isPowerOfThree(int n) {\n    while (n % 3 == 0 &amp;&amp; n &gt; 0) {\n        n /= 3;\n    }\n    return n == 1;\n}\nint main() {\n    cout &lt;&lt; isPowerOfThree(27) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfThree(0) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfThree(-1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n0\n</code></pre> <p>This solution repeatedly divides the input by 3 until it either becomes 1 (indicating that it was a power of three) or cannot be divided further by 3.</p>"},{"location":"source/Mathematics/326_Power_of_Three/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(logn)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/326_Power_of_Three/#solution-2-mathematics-and-the-constraints-of-the-problem","title":"Solution 2: Mathematics and the constraints of the problem","text":"<p>A power of three must divide another bigger one, i.e. $3^x | 3^y$ where $0 \\leq x \\leq y$.</p> <p>Because the constraint of the problem is $n \\leq 2^{31} - 1$, you can choose the biggest power of three in this range to test the others.</p> <p>It is $3^{19} = 1162261467$. The next power will exceed $2^{31} = 2147483648$.</p>"},{"location":"source/Mathematics/326_Power_of_Three/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nbool isPowerOfThree(int n) {\n    return n &gt; 0 &amp;&amp; 1162261467 % n == 0;\n}\nint main() {\n    cout &lt;&lt; isPowerOfThree(27) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfThree(0) &lt;&lt; endl;\n    cout &lt;&lt; isPowerOfThree(-1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n0\n</code></pre> <p>This solution effectively checks whether <code>n</code> is a power of three by verifying if it is a divisor of the largest power of three that fits within 32 bits. If the condition is met, it returns <code>true</code>, indicating that <code>n</code> is a power of three; otherwise, it returns <code>false</code>.</p>"},{"location":"source/Mathematics/326_Power_of_Three/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(1)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/326_Power_of_Three/#readable-code","title":"Readable code","text":"<p>Though Solution 2 offers a direct approach without the need for iteration, it is not easy to understand like Solution 1, where complexity of <code>O(logn)</code> is not too bad.</p>"},{"location":"source/Mathematics/326_Power_of_Three/#exercise","title":"Exercise","text":"<ul> <li>Check if Number is a Sum of Powers of Three.</li> </ul>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/","title":"Minimum Moves to Equal Array Elements II","text":""},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#problem-statement","title":"Problem statement","text":"<p>Given an integer array <code>nums</code> of size <code>n</code>, return the minimum number of moves required to make all array elements equal.</p> <p>In one move, you can increment or decrement an element of the array by <code>1</code>.</p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3]\nOutput: 2\nExplanation:\nOnly two moves are needed (remember each move increments or decrements one element):\n[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]\n</code></pre>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,10,2,9]\nOutput: 16\n</code></pre>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#constraints","title":"Constraints","text":"<ul> <li><code>n == nums.length</code>.</li> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code>.</li> </ul>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#solution-1-median-the-math-behind-the-problem","title":"Solution 1: Median - The math behind the problem","text":"<p>You are asked to move all elements of an array to the same value <code>M</code>. The problem can be reduced to identifying what <code>M</code> is.</p> <p>First, moving elements of an unsorted array and moving a sorted one are the same. So you can assume <code>nums</code> is sorted in some order. Let us say it is sorted in ascending order.</p> <p>Second, <code>M</code> must be in between the minimum element and the maximum one. Apparently!</p> <p>We will prove that <code>M</code> will be the median of <code>nums</code>, which is <code>nums[n/2]</code> of the sorted <code>nums</code>. </p> <p>In other words, we will prove that if you choose <code>M</code> a value different from <code>nums[n/2]</code>, then the number of moves will be increased.</p> <p>In fact, if you choose <code>M = nums[n/2] + x</code>, where <code>x &gt; 0</code>, then:</p> <ul> <li>Each element <code>nums[i]</code> that is less than <code>M</code> needs more <code>x</code> moves, while each <code>nums[j]</code> that is greater than <code>M</code> can reduce <code>x</code> moves. </li> <li>But the number of <code>nums[i]</code> is bigger than the number of <code>nums[j]</code>.</li> <li>So the total number of moves is bigger.</li> </ul> <p>The same arguments apply for <code>x &lt; 0</code>.</p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#example-3","title":"Example 3","text":"<p>For <code>nums = [0,1,2,2,10]</code>. Its median is <code>2</code>. The minimum number of moves is <code>2 + 1 + 0 + 0 + 8 = 11</code>.</p> <p>If you choose <code>M = 3</code> (the average value, the mean), the total number of moves is <code>3 + 2 + 1 + 1 + 7 = 14</code>. </p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint minMoves2(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    const int median = nums[nums.size() / 2];\n    int moves = 0;\n    for (int&amp; a: nums) {\n        moves += abs(a - median);\n    }\n    return moves;\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3};\n    cout &lt;&lt; minMoves2(nums) &lt;&lt; endl;\n    nums = {1,10,2,9};\n    cout &lt;&lt; minMoves2(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n16\n</code></pre> <p>This solution leverages the concept of the median to minimize the total absolute differences between each element and the median, resulting in the minimum number of moves to equalize the array. </p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*logn)</code> due to the sorting step, where <code>n</code> is the number of elements in the <code>nums</code> array.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#solution-2-using-stdnth_element-to-compute-the-median","title":"Solution 2: Using <code>std::nth_element</code> to compute the median","text":"<p>What you only need in Solution 1 is the median value. Computing the total number of moves in the <code>for</code> loop does not require the array <code>nums</code> to be fully sorted. </p> <p>In this case, you can use <code>std::nth_element</code> to reduce the runtime complexity.</p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint minMoves2(vector&lt;int&gt;&amp; nums) {\n    const int mid = nums.size() / 2;    \n    // make sure all elements that are less than or equals to nums[mid]\n    // are on the left\n    std::nth_element(nums.begin(), nums.begin() + mid, nums.end());\n    const int median = nums[mid];\n    int moves = 0;\n    for (int&amp; a: nums) {\n        moves += abs(a - median);\n    }\n    return moves;\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3};\n    cout &lt;&lt; minMoves2(nums) &lt;&lt; endl;\n    nums = {1,10,2,9};\n    cout &lt;&lt; minMoves2(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n16\n</code></pre> <p>This solution efficiently finds the median of the <code>nums</code> array in linear time using <code>std::nth_element</code> and then calculates the minimum number of moves to make all elements equal to this median. </p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#modern-c-tips","title":"Modern C++ tips","text":"<p>In the code of Solution 2, the partial sorting algorithm <code>std::nth_element</code> will make sure for all indices <code>i</code> and <code>j</code> that satisfy <code>0 &lt;= i &lt;= mid &lt;= j &lt; nums.length</code>, then</p> <pre><code>nums[i] &lt;= nums[mid] &lt;= nums[j].\n</code></pre> <p>With this property, if <code>mid = nums.length / 2</code>, then the value of <code>nums[mid]</code> is unchanged no matter how <code>nums</code> is sorted or not.</p>"},{"location":"source/Mathematics/462_Minimum_Moves_to_Equal_Array_Elements_II/#exercise","title":"Exercise","text":"<ul> <li>Minimum Moves to Equal Array Elements.</li> </ul>"},{"location":"source/Mathematics/565_Array_Nesting/","title":"Array Nesting","text":""},{"location":"source/Mathematics/565_Array_Nesting/#problem-statement","title":"Problem statement","text":"<p>You are given an integer array <code>nums</code> of length <code>n</code> where <code>nums</code> is a permutation of the numbers in the range <code>[0, n - 1]</code>.</p> <p>You should build a set <code>s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... }</code> subjected to the following rule:</p> <ul> <li>The first element in <code>s[k]</code> starts with the element <code>nums[k]</code>.</li> <li>The next element in <code>s[k]</code> should be <code>nums[nums[k]]</code>, and then <code>nums[nums[nums[k]]]</code>, and so on.</li> <li>We stop adding elements before a duplicate element occurs in <code>s[k]</code>.</li> </ul> <p>Return the length of the longest set <code>s[k]</code>. </p>"},{"location":"source/Mathematics/565_Array_Nesting/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [5,4,0,3,1,6,2]\nOutput: 4\nExplanation: \nnums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.\nOne of the longest sets s[k]:\ns[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}\n</code></pre>"},{"location":"source/Mathematics/565_Array_Nesting/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [0,1,2]\nOutput: 1\n</code></pre>"},{"location":"source/Mathematics/565_Array_Nesting/#constraints","title":"Constraints:","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>0 &lt;= nums[i] &lt; nums.length</code>.</li> <li>All the values of <code>nums</code> are unique.</li> </ul>"},{"location":"source/Mathematics/565_Array_Nesting/#solution-understanding-the-math-behind","title":"Solution: Understanding the math behind","text":"<p>A permutation is a one-to-one mapping from a set of integers to itself.</p> <p>The {index}<code>permutation</code> on the set <code>nums</code> in this problem is defined by the mapping <code>i -&gt; nums[i]</code>. For instance in Example 1, the permutation is defined as following:</p> <pre><code>0 -&gt; 5,\n1 -&gt; 4,\n2 -&gt; 0,\n3 -&gt; 3,\n4 -&gt; 1,\n5 -&gt; 6,\n6 -&gt; 2.\n</code></pre> <p>You can always rearrange the definition of a permutation into groups of cyclic chains (factors). </p> <pre><code>0 -&gt; 5, 5 -&gt; 6, 6 -&gt; 2, 2 -&gt; 0,\n1 -&gt; 4, 4 -&gt; 1,\n3 -&gt; 3\n</code></pre> <p>The set <code>s[k]</code> in this problem is such a chain. In mathematics, it is called a cycle; because the chain <code>(0, 5, 6, 2)</code> is considered the same as <code>(5, 6, 2, 0)</code>, <code>(6, 2, 0, 5)</code> or <code>(2, 0, 5, 6)</code> in Example 1. </p> <p>Assume you have used some elements of the array <code>nums</code> to construct some cycles. To construct another one, you should start with the unused elements.</p> <p>The problem leads to finding the longest cycle of a given permutation.</p>"},{"location":"source/Mathematics/565_Array_Nesting/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint arrayNesting(const vector&lt;int&gt;&amp; nums) {\n    int maxLen{0};\n    vector&lt;bool&gt; visited(nums.size());\n    for (auto&amp; i : nums) {\n        if (visited[i]) {\n            continue;\n        }\n        int len{0};\n        // visit the cycle starting from i\n        while (!visited[i]) {\n            visited[i] = true;\n            i = nums[i];            \n            len++;\n        }\n        maxLen = max(len, maxLen);\n    }\n    return maxLen;\n}\n\nint main() {\n    vector&lt;int&gt; nums = {5,4,0,3,1,6,2}; \n    cout &lt;&lt; arrayNesting(nums) &lt;&lt; endl;\n    nums = {0,1,2}; \n    cout &lt;&lt; arrayNesting(nums) &lt;&lt; endl;\n    nums = {0,2,1}; \n    cout &lt;&lt; arrayNesting(nums) &lt;&lt; endl;\n    nums = {2,0,1}; \n    cout &lt;&lt; arrayNesting(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n4\n1\n2\n3\n</code></pre>"},{"location":"source/Mathematics/565_Array_Nesting/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code> where <code>n</code> is the size of the <code>nums</code> array.</li> <li>Extra space: much less than <code>O(n)</code> since <code>vector&lt;bool&gt;</code> is optimized for space efficiency.</li> </ul>"},{"location":"source/Mathematics/565_Array_Nesting/#conclusion","title":"Conclusion","text":"<p>The problem of finding the length of the longest cycle in an array can be efficiently solved using a cycle detection approach. This solution efficiently detects cycles in the array by using a boolean array to mark visited elements. </p> <p>By iterating through each element in the array and visiting the cycle starting from each unvisited element, the solution identifies the length of each cycle and updates the maximum length accordingly. This approach ensures that each cycle is visited only once and maximizes the length of the longest cycle in the array.</p>"},{"location":"source/Mathematics/78_Subsets/","title":"Subsets","text":""},{"location":"source/Mathematics/78_Subsets/#problem-statement","title":"Problem Statement","text":"<p>Given an integer array <code>nums</code> of unique elements, return all possible subsets (the {index}<code>power set</code>).</p> <p>The solution set must not contain duplicate subsets. Return the solution in any order.</p>"},{"location":"source/Mathematics/78_Subsets/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n</code></pre>"},{"location":"source/Mathematics/78_Subsets/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1]\nOutput: [[],[1]]\n</code></pre>"},{"location":"source/Mathematics/78_Subsets/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10</code>.</li> <li><code>-10 &lt;= nums[i] &lt;= 10</code>.</li> <li>All the numbers of <code>nums</code> are unique.</li> </ul>"},{"location":"source/Mathematics/78_Subsets/#solution","title":"Solution","text":"<p>You might need to find the relationship between the result of the array <code>nums</code> with the result of itself without the last element.</p>"},{"location":"source/Mathematics/78_Subsets/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [1,2]\nOutput: [[],[1],[2],[1,2]]\n</code></pre> <p>You can see the powerset of Example 3 was obtained from the one in Example 2 with additional subsets <code>[2]</code>, <code>[1,2]</code>. These new subsets were constructed from subsets <code>[]</code>, <code>[1]</code> of Example 2 appended with the new element <code>2</code>. </p> <p>Similarly, the powerset of Example 1 was obtained from the one in Example 3 with the additional subsets <code>[3]</code>, <code>[1,3]</code>, <code>[2,3]</code>, <code>[1,2,3]</code>. These new subsets were constructed from the ones of Example 3 appended with the new element <code>3</code>.</p>"},{"location":"source/Mathematics/78_Subsets/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;vector&lt;int&gt;&gt; subsets(const vector&lt;int&gt;&amp; nums) {\n    vector&lt;vector&lt;int&gt;&gt; powerset = {{}};\n    int i = 0;\n    while (i &lt; nums.size()) {\n        vector&lt;vector&lt;int&gt;&gt; newSubsets;\n        for (auto subset : powerset) {\n            subset.push_back(nums[i]);  \n            newSubsets.push_back(subset);\n        }\n        powerset.insert(powerset.end(), newSubsets.begin(), newSubsets.end());\n        i++;\n    }\n    return powerset;\n}\nvoid print(const vector&lt;vector&lt;int&gt;&gt;&amp; powerset) {\n    for (auto&amp; set : powerset ) {\n        cout &lt;&lt; \"[\";\n        for (auto&amp; element : set) {\n            cout &lt;&lt; element &lt;&lt; \",\";\n        }\n        cout &lt;&lt; \"]\";\n    }\n    cout &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3};\n    auto powerset = subsets(nums);\n    print(powerset);\n    nums = {1};\n    powerset = subsets(nums);\n    print(powerset);\n}\n</code></pre> <pre><code>Output:\n[][1,][2,][1,2,][3,][1,3,][2,3,][1,2,3,]\n[][1,]\n</code></pre>"},{"location":"source/Mathematics/78_Subsets/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(2^N)</code>, where <code>N</code> is the number of elements in <code>nums</code>, as it generates all possible subsets.</li> <li>Extra space: <code>O(2^N)</code> due to the space required to store the subsets.</li> </ul>"},{"location":"source/Mathematics/78_Subsets/#conclusion","title":"Conclusion","text":"<p>This solution generates subsets by iteratively adding each element of <code>nums</code> to the existing subsets and accumulating the results.</p> <p>Note that in <code>for (auto subset : powerset)</code> you should not use reference <code>auto&amp;</code> because you might not want to change the subsets that have been created.</p>"},{"location":"source/Mathematics/78_Subsets/#exercise","title":"Exercise","text":"<ul> <li>Subsets II.</li> </ul>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/","title":"Running Sum of 1d Array","text":""},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#problem-statement","title":"Problem statement","text":"<p>Given an array called <code>nums</code>, calculate the running sum of its elements and return the resulting array. The running sum at index <code>i</code> is the sum of elements from index <code>0</code> to <code>i</code> in the <code>nums</code> array.</p>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3,4]\nOutput: [1,3,6,10]\nExplanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].\n</code></pre>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,1,1,1,1]\nOutput: [1,2,3,4,5]\nExplanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].\n</code></pre>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [3,1,2,10,1]\nOutput: [3,4,6,16,17]\n</code></pre>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 1000</code>.</li> <li><code>-10^6 &lt;= nums[i] &lt;= 10^6</code>.</li> </ul>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#solution-1-unchange-nums","title":"Solution 1: Unchange <code>nums</code>","text":""},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; runningSum(const vector&lt;int&gt;&amp; nums) {\n    vector&lt;int&gt; rs;\n    int s = 0;\n    for (auto&amp; n : nums) {\n        s += n;\n        rs.push_back(s);\n    }\n    return rs;\n}\nvoid printResult(const vector&lt;int&gt;&amp; sums) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; s: sums) {\n        cout &lt;&lt; s &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3,4};\n    auto rs = runningSum(nums);\n    printResult(rs);\n    nums = {1,1,1,1,1};\n    rs = runningSum(nums);\n    printResult(rs);\n    nums = {3,1,2,10,1};\n    rs = runningSum(nums);\n    printResult(rs);\n}\n</code></pre> <pre><code>Output:\n[1,3,6,10,]\n[1,2,3,4,5,]\n[3,4,6,16,17,]\n</code></pre> <p>This solution iterates through the input array <code>nums</code>, calculates the running sum at each step, and appends the running sums to a result vector. This approach efficiently computes the running sums in a single pass through the array.</p>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#solution-2-change-nums","title":"Solution 2: Change <code>nums</code>","text":"<p>If <code>nums</code> is allowed to be changed, you could use it to store the result directly.</p>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) {\n    for (int i = 1; i &lt; nums.size(); i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\nvoid printResult(const vector&lt;int&gt;&amp; sums) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; s: sums) {\n        cout &lt;&lt; s &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums{1,2,3,4};\n    auto rs = runningSum(nums);\n    printResult(rs);\n    nums = {1,1,1,1,1};\n    rs = runningSum(nums);\n    printResult(rs);\n    nums = {3,1,2,10,1};\n    rs = runningSum(nums);\n    printResult(rs);\n}\n</code></pre> <pre><code>Output:\n[1,3,6,10,]\n[1,2,3,4,5,]\n[3,4,6,16,17,]\n</code></pre>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/1480_Running_Sum_of_1d_Array/#conclusion","title":"Conclusion","text":"<p>Solution 2 directly modifies the input array <code>nums</code> to store the running sums by iteratively updating each element with the cumulative sum of the previous elements. This approach efficiently calculates the running sums in a single pass through the array.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/","title":"Product of Array Except Self","text":"<p>% Medium </p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#problem-statement","title":"Problem statement","text":"<p>Given an integer array <code>nums</code>, return an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of nums except <code>nums[i]</code>.</p> <p>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer.</p> <p>You must write an algorithm that runs in <code>O(n)</code> time and without using the division operation.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n</code></pre>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n</code></pre>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#constraints","title":"Constraints","text":"<ul> <li><code>2 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>-30 &lt;= nums[i] &lt;= 30</code>.</li> <li>The product of any prefix or suffix of <code>nums</code> is guaranteed to fit in a 32-bit integer.</li> </ul>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#follow-up","title":"Follow up","text":"<ul> <li>Can you solve the problem in <code>O(1)</code> extra space complexity? (The output array does not count as extra space for space complexity analysis.)</li> </ul>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#solution-1-compute-the-prefix-and-suffix-products","title":"Solution 1: Compute the prefix and suffix products","text":"<p>To avoid division operation, you can compute the prefix product and the suffix one of <code>nums[i]</code>.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; productExceptSelf(const vector&lt;int&gt;&amp; nums) {\n    const int n = nums.size();\n    vector&lt;int&gt; prefix(n);\n    prefix[0] = 1;\n    // compute all prefix products nums[0]*nums[1]*..*nums[i-1]\n    for (int i = 1; i &lt; n; i++) {\n        prefix[i] = prefix[i - 1] * nums[i - 1];\n    }\n    vector&lt;int&gt; suffix(n);        \n    suffix[n - 1] = 1;\n    // compute all suffix products nums[i+1]*nums[i+2]*..*nums[n-1]\n    for (int i = n - 2; i &gt;= 0; i--) {\n        suffix[i] = suffix[i + 1] * nums[i + 1];\n    }\n    vector&lt;int&gt; answer(n);\n    for (int i = 0; i &lt; n; i++) {\n        answer[i] = prefix[i] * suffix[i];\n    }\n    return answer;\n}\nvoid print(const vector&lt;int&gt;&amp; nums) {\n    for (auto&amp; v : nums) {\n        cout &lt;&lt; v &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    auto answer = productExceptSelf(nums);\n    print(answer);\n    nums = {-1, 1, 0, -3, 3};\n    answer = productExceptSelf(nums);\n    print(answer);\n}\n</code></pre> <pre><code>Output:\n24 12 8 6 \n0 0 9 0 0\n</code></pre> <p>This solution computes the product of all elements in an array except for the current element. </p> <p>It accomplishes this by first computing two arrays: <code>prefix</code> and <code>suffix</code>. The <code>prefix</code> array stores the product of all elements to the left of the current element, while the <code>suffix</code> array stores the product of all elements to the right of the current element. By multiplying the corresponding elements from <code>prefix</code> and <code>suffix</code> arrays, it effectively computes the product of all elements except for the current element at each index. </p> <p>This approach optimizes the computation by breaking down the problem into smaller subproblems and leveraging the precomputed prefix and suffix arrays to efficiently compute the final result.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#solution-2-use-directly-vector-answer-to-store-the-prefix-product","title":"Solution 2: Use directly vector <code>answer</code> to store the prefix product","text":"<p>In the solution above you can use directly vector <code>answer</code> for <code>prefix</code> and merge the last two loops into one.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; productExceptSelf(const vector&lt;int&gt;&amp; nums) {\n    const int n = nums.size();\n    vector&lt;int&gt; answer(n);\n    answer[0] = 1;\n    // compute all prefix products nums[0]*nums[1]*..*nums[i-1]\n    for (int i = 1; i &lt; n; i++) {\n        answer[i] = answer[i - 1] * nums[i - 1];\n    }\n    int suffix = 1;\n    for (int i = n - 2; i &gt;= 0; i--) {\n        // compute suffix product and the final product the same time\n        suffix *= nums[i + 1];\n        answer[i] *= suffix;\n    }\n    return answer;\n}\nvoid print(const vector&lt;int&gt;&amp; nums) {\n    for (auto&amp; v : nums) {\n        cout &lt;&lt; v &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums = {1, 2, 3, 4};\n    auto answer = productExceptSelf(nums);\n    print(answer);\n    nums = {-1, 1, 0, -3, 3};\n    answer = productExceptSelf(nums);\n    print(answer);\n}\n</code></pre> <pre><code>Output:\n24 12 8 6 \n0 0 9 0 0\n</code></pre> <p>This code efficiently calculates the products of all elements in the <code>nums</code> vector except for the element at each index using two passes through the array. The first pass calculates products to the left of each element, and the second pass calculates products to the right of each element.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#conclusion","title":"Conclusion","text":"<p>The problem of computing the product of all elements in an array except the element at the current index can be efficiently solved using different approaches. Solution 1 utilizes two separate passes through the array to compute prefix and suffix products independently. By first computing prefix products from left to right and then suffix products from right to left, this solution efficiently calculates the product of all elements except the one at the current index.</p> <p>Solution 2 offers a more concise approach by combining the computation of prefix and suffix products into a single pass through the array. By iteratively updating a variable to compute suffix products while simultaneously updating the elements of the answer array, this solution achieves the desired result more efficiently with only one pass through the array.</p>"},{"location":"source/Prefix_Sum/238_Product_of_Array_Except_Self/#exercise","title":"Exercise","text":"<ul> <li>Construct Product Matrix.</li> </ul>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/","title":"Maximum Subarray","text":""},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#problem-statement","title":"Problem statement","text":"<p>You're provided with an array of integers called <code>nums</code>. Your task is to identify a subarray (a consecutive sequence of numbers) that has the highest sum. Once you find this subarray, return the sum of its elements.</p>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: [4,-1,2,1] has the largest sum = 6.\n</code></pre>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1]\nOutput: 1\n</code></pre>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [5,4,-1,7,8]\nOutput: 23\n</code></pre>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^5</code>.</li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#solution","title":"Solution","text":"<p>The subarrays you want to find should not have negative prefix sums. A negative prefix sum would make the sum of the subarray smaller.</p>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#example-1_1","title":"Example 1","text":"<p>For <code>nums = [-2,1,-3,4,-1,2,1,-5,4]</code>, <code>[-2]</code> or <code>[-2,1]</code> or <code>[-2,1,-3]</code> should not be a prefix of the subarrays you want to find. Since it makes the sum of the result smaller.</p>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint maxSubArray(const vector&lt;int&gt;&amp; nums) {\n    int maxSum = -10000; // just chose some negative number to start\n    int currSum = 0; // sum of current subarray\n    for (auto&amp; num : nums) {\n        if (currSum &lt; 0) {\n            // start a new subarray from this num\n            currSum = num;\n        } else {\n            currSum = currSum + num;\n        }\n        // update max sum so far\n        maxSum = max(maxSum, currSum);\n    }\n    return maxSum;\n}\nint main() {\n    vector&lt;int&gt; nums = {-2,1,-3,4,-1,2,1,-5,4};\n    cout &lt;&lt; maxSubArray(nums) &lt;&lt; endl;\n    nums = {1};\n    cout &lt;&lt; maxSubArray(nums) &lt;&lt; endl;\n    nums = {5,4,-1,7,8};\n    cout &lt;&lt; maxSubArray(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n6\n1\n23\n</code></pre>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#complexity","title":"Complexity","text":"<ul> <li>Runtime <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Memory <code>O(1)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#conclusion","title":"Conclusion","text":"<p>This solution is the Kadane's algorithm to find the maximum sum of a contiguous subarray in the given array nums. </p> <p>It iterates through the elements of the array, updating <code>currSum</code> to either the current element or the sum of the current element and the previous <code>currSum</code>, whichever is greater. By considering whether adding the current element improves the overall sum, it effectively handles both positive and negative numbers in the array. Finally, it updates <code>maxSum</code> with the maximum value encountered during the iteration, ensuring it holds the maximum sum of any contiguous subarray within the given array. </p> <p>This approach optimizes the computation by tracking the maximum sum and dynamically updating it as it iterates through the array.</p>"},{"location":"source/Prefix_Sum/53_Maximum_Subarray/#exercise","title":"Exercise","text":"<ul> <li>Maximum Product Subarray.</li> </ul>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/","title":"Subarray Sum Equals K","text":""},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#problem-statement","title":"Problem Statement","text":"<p>You have an array of integers called <code>nums</code> and an integer <code>k</code>. Your task is to determine the count of contiguous subarrays within this array, where the sum of elements in each subarray is equal to the value of <code>k</code>.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,1,1], k = 2\nOutput: 2\n</code></pre>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,2,3], k = 3\nOutput: 2\n</code></pre>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code>.</li> <li><code>-1000 &lt;= nums[i] &lt;= 1000</code>.</li> <li><code>-10^7 &lt;= k &lt;= 10^7</code>.</li> </ul>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":"<p>For each element, for all subarrays starting from it, choose the satisfied ones.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#example-3","title":"Example 3","text":"<p>For <code>nums = [1, -1, 0]</code> and <code>k = 0</code>, you get <code>3</code> subarrays for the result: * There are three subarrays starting from <code>1</code>, which are <code>[1]</code>, <code>[1, -1]</code>, and <code>[1, -1, 0]</code>. Only the last two are satisfied. * There are two subarrays starting from <code>-1</code>, which are <code>[-1]</code> and <code>[-1, 0]</code>. None is satisfied. * Only <code>[0]</code> is the subarray starting from <code>0</code>. It is satisfied.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint subarraySum(const vector&lt;int&gt;&amp; nums, int k) {\n    int count = 0;\n    for (int i = 0; i &lt; nums.size(); i++) {\n        int sum = 0;\n        for (int j = i; j &lt; nums.size(); j++) {\n            sum += nums[j];\n            if (sum == k) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    vector&lt;int&gt; nums{1,1,1};\n    cout &lt;&lt; subarraySum(nums, 2) &lt;&lt; endl;\n    nums = {1,2,3};\n    cout &lt;&lt; subarraySum(nums, 3) &lt;&lt; endl;\n    nums = {1,-1,0};\n    cout &lt;&lt; subarraySum(nums, 0) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n2\n3\n</code></pre> <p>This solution employs a brute-force approach by considering all possible subarrays and checking whether their sum equals the target <code>k</code>. The time complexity of this solution is relatively high due to the nested loops, resulting in an inefficient algorithm for larger input sizes.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#solution-2-prefix-sum","title":"Solution 2: Prefix sum","text":"<p>In the solution above, many sums can be deducted from the previous ones.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#example-4","title":"Example 4","text":"<p>For <code>nums = [1, 2, 3, 4]</code>. Assume the sum of the subarrays <code>[1], [1, 2], [1, 2, 3], [1, 2, 3, 4]</code> were computed in the first loop. Then the sum of any other subarray can be deducted from those values. * <code>sum([2, 3]) = sum([1, 2, 3]) - sum([1])</code>. * <code>sum([2, 3, 4]) = sum([1, 2, 3, 4]) - sum([1])</code>. * <code>sum([3, 4]) = sum(1, 2, 3, 4) - sum(1, 2)</code>.</p> <p>In general, assume you have computed the sum <code>sum[i]</code> for the subarray <code>[nums[0], nums[1], ..., nums[i]]</code> for all <code>0 &lt;= i &lt; nums.length</code>. Then the sum of the subarray <code>[nums[j+1], nums[j+2], ..., nums[i]]</code> for any <code>0 &lt;= j &lt;= i</code> can be computed as <code>sum[i] - sum[j]</code>.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint subarraySum(const vector&lt;int&gt;&amp; nums, int k) {\n    const int n = nums.size();\n    vector&lt;int&gt; sum(n);\n    sum[0] = nums[0];\n    // compute all prefix sums nums[0] + .. + nums[i]\n    for (int i = 1; i &lt; n; i++) {\n        sum[i] = sum[i-1] + nums[i];\n    }\n    int count = 0;\n    for (int i = 0; i &lt; n; i++) {\n        if (sum[i] == k) {\n            // nums[0] + .. + nums[i] = k\n            count++;\n        }\n        for (int j = 0; j &lt; i; j++) {\n            if (sum[i] - sum[j] == k) {\n                // nums[j+1] + nums[j+2] + .. + nums[i] = k\n                count++;\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    vector&lt;int&gt; nums{1,1,1};\n    cout &lt;&lt; subarraySum(nums, 2) &lt;&lt; endl;\n    nums = {1,2,3};\n    cout &lt;&lt; subarraySum(nums, 3) &lt;&lt; endl;\n    nums = {1,-1,0};\n    cout &lt;&lt; subarraySum(nums, 0) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n2\n3\n</code></pre> <p>This solution uses the concept of prefix sum to efficiently calculate the sum of subarrays. It then iterates through the array to find subarrays with a sum equal to <code>k</code>, and the nested loop helps in calculating the sum of various subarray ranges. The time complexity of this solution is improved compared to the brute-force approach.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#solution-3-faster-lookup","title":"Solution 3: Faster lookup","text":"<p>You can rewrite the condition <code>sum[i] - sum[j] == k</code> in the inner loop of the Solution 2 to <code>sum[i] - k == sum[j]</code>. </p> <p>Then that loop can rephrase to \"checking if <code>sum[i] - k</code> was already a value of some computed <code>sum[j]</code>\". </p> <p>Now you can use an <code>unordered_map</code> to store the <code>sums</code> as indices for the fast lookup.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#code_2","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint subarraySum(const vector&lt;int&gt;&amp; nums, int k) {\n    int count = 0;\n    // count the frequency of all subarrays' sums \n    unordered_map&lt;int, int&gt; sums;\n    int sumi = 0;\n    for (int i = 0; i &lt; nums.size(); i++) {\n        sumi += nums[i];\n        if (sumi == k) {\n            count++;\n        }\n        auto it = sums.find(sumi - k);\n        if (it != sums.end()) {\n            // it-&gt;second is the count of j so far \n            // having sum[j] = sum[i] - k\n            count += it-&gt;second;\n        }\n        // store the count of prefix sum sumi\n        sums[sumi]++;\n    }\n    return count;\n}\nint main() {\n    vector&lt;int&gt; nums{1,1,1};\n    cout &lt;&lt; subarraySum(nums, 2) &lt;&lt; endl;\n    nums = {1,2,3};\n    cout &lt;&lt; subarraySum(nums, 3) &lt;&lt; endl;\n    nums = {1,-1,0};\n    cout &lt;&lt; subarraySum(nums, 0) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n2\n3\n</code></pre>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#conclusion","title":"Conclusion","text":"<p>Solution 3 uses an unordered map to efficiently track the frequency of cumulative sums. It utilizes the concept of complement sums to identify subarrays with the desired sum and adds their counts to the overall count. This approach significantly improves the time complexity compared to the brute-force solution.</p>"},{"location":"source/Prefix_Sum/560_Subarray_Sum_Equals_K/#exercise","title":"Exercise","text":"<ul> <li>Find Pivot Index.</li> </ul>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/","title":"Last Stone Weight","text":""},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#problem-statement","title":"Problem statement","text":"<p>You are given an array of integers called <code>stones</code>, where each <code>stones[i]</code> represents the weight of the <code>i-th</code> stone.</p> <p>A game is played with these stones as follows: In each turn, we choose the two heaviest stones and smash them together. Let us say the weights of the two heaviest stones are <code>x</code> and <code>y</code>, where <code>x &lt;= y</code>. The outcome of this smash operation is:</p> <ol> <li>If <code>x</code> is equal to <code>y</code>, both stones are destroyed.</li> <li>If <code>x</code> is not equal to <code>y</code>, the stone with weight <code>x</code> is destroyed, and the stone with weight <code>y</code> now has a new weight of <code>y - x</code>.</li> </ol> <p>The game continues until there is at most one stone left. Your task is to determine the smallest possible weight of the remaining stone after the game ends. If there are no stones left, return <code>0</code>.</p>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#example-1","title":"Example 1","text":"<pre><code>Input: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation: \nWe combine 7 and 8 to get 1, so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2, so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0, so the array converts to [1] then that's the value of the last stone.\n</code></pre>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#example-2","title":"Example 2","text":"<pre><code>Input: stones = [1]\nOutput: 1\n</code></pre>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= stones.length &lt;= 30</code>.</li> <li><code>1 &lt;= stones[i] &lt;= 1000</code>.</li> </ul>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#solution-keeping-the-heaviest-stones-on-top","title":"Solution: Keeping the heaviest stones on top","text":"<p>The only things you want at any time are the two heaviest stones. One way of keeping this condition is by using {index}<code>std::priority_queue</code>.</p>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\nint lastStoneWeight(vector&lt;int&gt;&amp; stones) {\n    priority_queue&lt;int&gt; q(stones.begin(), stones.end());\n    while (q.size() &gt;= 2) {\n        int y = q.top();\n        q.pop();\n        int x = q.top();\n        q.pop();\n        // compare two heaviest stones\n        if (y != x) {\n            q.push(y - x);\n        }\n    }\n    return q.empty() ? 0 : q.top();    \n}\nint main() {\n    vector&lt;int&gt; stones{2,7,4,1,8,1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;\n    stones = {1};\n    cout &lt;&lt; lastStoneWeight(stones) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n1\n</code></pre>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*logn)</code>, where <code>n = stones.length</code>.   </li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Priority_Queue/1046_Last_Stone_Weight/#conclusion","title":"Conclusion","text":"<p>This solution efficiently simulates the process of smashing stones and finding the last remaining stone by using a max-heap (priority queue) to always select the heaviest stones to smash together.</p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/","title":"Construct Target Array With Multiple Sums","text":""},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#problem-statement","title":"Problem statement","text":"<p>You are provided with an array of integers called <code>target</code> with <code>n</code> elements. You start with another array, <code>arr</code>, consisting of <code>n</code> elements, all initialized to <code>1</code>. You have the ability to perform the following operation:</p> <ol> <li>Calculate the sum of all elements in your current array <code>arr</code>, let's call it <code>x</code>.</li> <li>Choose an index <code>i</code> where <code>0 &lt;= i &lt; n</code>, and update the value at index <code>i</code> in <code>arr</code> to be <code>x</code>.</li> </ol> <p>You can repeat this operation as many times as needed. Your task is to determine whether it's possible to transform the initial array <code>arr</code> into the given <code>target</code> array using this operation. If it's possible, return <code>true</code>; otherwise, return <code>false</code>.</p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#example-1","title":"Example 1","text":"<pre><code>Input: target = [9,3,5]\nOutput: true\nExplanation: Start with arr = [1, 1, 1] \n[1, 1, 1], sum = 3 choose index 1\n[1, 3, 1], sum = 5 choose index 2\n[1, 3, 5], sum = 9 choose index 0\n[9, 3, 5] Done\n</code></pre>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#example-2","title":"Example 2","text":"<pre><code>Input: target = [1,1,1,2]\nOutput: false\nExplanation: Impossible to create target array from [1,1,1,1].\n</code></pre>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#example-3","title":"Example 3","text":"<pre><code>Input: target = [8,5]\nOutput: true\n</code></pre>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#constraints","title":"Constraints","text":"<ul> <li><code>n == target.length</code>.</li> <li><code>1 &lt;= n &lt;= 5 * 10^4</code>.</li> <li><code>1 &lt;= target[i] &lt;= 10^9</code>.</li> </ul>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#solution-1-going-backward","title":"Solution 1: Going backward","text":"<p>If you start from <code>arr = [1,1,...,1]</code> and follow the required procedure, the new element <code>x</code> you get for the next state is always the max element of <code>arr</code>. </p> <p>To solve this problem, you can start from the max element of the given <code>target</code> to compute its previous state until you get the <code>arr = [1,1,...,1]</code>.</p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#example-1_1","title":"Example 1","text":"<p>For <code>target = [9,3,5]</code>:</p> <ul> <li>The max element is <code>9</code>, subtract it from the remaining sum: <code>9 - (3 + 5) = 1</code>, you get <code>target = [1,3,5]</code>.</li> <li>The max element is <code>5</code>, subtract it from the remaining sum: <code>5 - (1 + 3) = 1</code>, you get <code>target = [1,3,1]</code>.</li> <li>The max element is <code>3</code>, subtract it from the remaining sum: <code>3 - (1 + 1) = 1</code>, you get <code>target = [1,1,1]</code>.</li> <li>Return <code>true</code>.</li> </ul>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#notes","title":"Notes","text":"<ul> <li>If <code>target = [m,1]</code> or <code>target = [1,m]</code> for any <code>m &gt;= 1</code>, you can always turn it to <code>arr = [1,1]</code>.</li> <li>If the changed value after the subtraction is still the max element of the previous state, you need to redo the subtraction at the same position. In this case, the modulo might be used instead of subtraction.</li> </ul>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool isPossible(const vector&lt;int&gt;&amp; target) {\n    // compute sum of all target's elements\n    unsigned long sum = accumulate(target.begin(), \n                                   target.end(), \n                                   (unsigned long) 0);\n    // find the max element in the target\n    // pmax is the pointer to the max element,\n    // *pmax is the value that pointer points to\n    auto pmax = max_element(target.begin(), target.end());\n    while (*pmax &gt; 1) {\n        // compute the remaining sum\n        sum -= *pmax;\n        if (sum == 1) {\n            // This is the case target = [m,1], \n            // which you can always turn it to [1,1].\n            return true;\n        }        \n        if (*pmax &lt;= sum) {\n            // the next subtraction leads to non-positive values\n            return false;\n        }\n        if (sum == 0) {\n            // cannot change target\n            return false;\n        }\n        // perform the subtraction as much as possible\n        // and update new value for the pointer pmax\n        *pmax %= sum;\n        if (*pmax == 0) {\n            return false;\n        }\n        // compute the sum of the subtracted target\n        sum += *pmax;\n        // find the max element in the subtracted target\n        pmax = max_element(target.begin(), target.end());\n    }\n    // if the final target = [1, .., 1],\n    // its sum equals to its length\n    return sum == target.size();\n}\nint main() {\n    vector&lt;int&gt; target{9,3,5};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n    target = {1,1,1,2};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n    target = {8,5};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre> <p>This solution iteratively reduces the maximum element in the <code>target</code> array while keeping track of the total sum. It checks various conditions to determine whether it's possible to reach an array consisting of only 1s. If all conditions are satisfied, it returns <code>true</code>; otherwise, it returns <code>false</code>.</p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(log N)</code>, where <code>N = max(target)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#solution-2-using-priority_queue","title":"Solution 2: Using priority_queue","text":"<p>In the solution above, the position of the max element in each state is not so important as long as you update exactly it, not the other ones.</p> <p>That might lead to the usage of the {index}<code>std::priority_queue</code>.</p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;numeric&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\nbool isPossible(const vector&lt;int&gt;&amp; target) {\n    // create a heap from the target\n    priority_queue&lt;int&gt; q(target.begin(), target.end());\n    // compute the sum of all elements\n    unsigned long sum = accumulate(target.begin(), \n                                   target.end(), \n                                   (unsigned long) 0);\n    while (q.top() &gt; 1) {\n        // compute the remaining sum\n        sum -= q.top();\n        if (sum == 1) {\n            return true;\n        }\n        if (q.top() &lt;= sum) {\n            return false;\n        }\n        if (sum == 0) {\n            return false;\n        }\n        // perform the subtraction as much as possible\n        int pre = q.top() % sum;\n        if (pre == 0) {\n            return false;\n        }\n        // remove the old max element\n        q.pop();\n        // add subtracted element to the heap\n        q.push(pre);\n        // compute the sum of the subtracted target\n        sum += pre;\n    }\n    return sum == target.size();\n}\nint main() {\n    vector&lt;int&gt; target{9,3,5};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n    target = {1,1,1,2};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n    target = {8,5};\n    cout &lt;&lt; isPossible(target) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(logN)</code>, where <code>N = max(target)</code>.</li> <li>Extra space: <code>O(n)</code>, where <code>n = target.length</code>.</li> </ul>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#conclusion","title":"Conclusion","text":"<p>Solution 2 uses a max heap (<code>priority_queue</code>) to efficiently find and process the maximum element in the <code>target</code> array while keeping track of the total sum. It checks various conditions to determine whether it's possible to reach an array consisting of only 1s. </p>"},{"location":"source/Priority_Queue/1354_Construct_Target_Array_With_Multiple_Sums/#exercise","title":"Exercise","text":"<ul> <li>Minimum Amount of Time to Fill Cups.</li> </ul>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/","title":"Kth Smallest Element in a Sorted Matrix","text":""},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#problem-statement","title":"Problem statement","text":"<p>You are given an <code>n x n</code> matrix where each row and column is sorted in ascending order. Your task is to find the <code>k-th</code> smallest element in this matrix.</p> <p>Please note that we are looking for the <code>k-th</code> smallest element based on its position in the sorted order, and not counting distinct elements.</p> <p>Additionally, it is required to find a solution with a memory complexity better than <code>O(n^2)</code>. </p>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#example-1","title":"Example 1","text":"<pre><code>Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\nOutput: 13\nExplanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13\n</code></pre>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#example-2","title":"Example 2","text":"<pre><code>Input: matrix = [[-5]], k = 1\nOutput: -5\n</code></pre>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#constraints","title":"Constraints","text":"<ul> <li><code>n == matrix.length == matrix[i].length</code>.</li> <li><code>1 &lt;= n &lt;= 300</code>.</li> <li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code>.</li> <li>All the rows and columns of <code>matrix</code> are guaranteed to be sorted in non-decreasing order.</li> <li><code>1 &lt;= k &lt;= n^2</code>.</li> </ul>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#follow-up","title":"Follow up","text":"<ul> <li>Could you solve the problem with a constant memory (i.e., <code>O(1)</code> memory complexity)?</li> <li>Could you solve the problem in <code>O(n)</code> time complexity? The solution may be too advanced for an interview but you may find reading this paper fun.</li> </ul>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#solution-1-transform-the-2-d-matrix-into-a-1-d-vector-then-sort","title":"Solution 1: Transform the 2-D matrix into a 1-D vector then sort","text":"<p>You can implement exactly what Example 1 has explained.</p>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint kthSmallest(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n    vector&lt;int&gt; m;\n    // transform the 2D matrix into a 1D array m\n    for (auto&amp; row : matrix) {\n        m.insert(m.end(), row.begin(), row.end());\n    }\n    // sort the array m\n    sort(m.begin(), m.end());\n    return m.at(k - 1);\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; matrix{{1,5,9},{10,11,13},{12,13,15}};\n    cout &lt;&lt; kthSmallest(matrix, 8) &lt;&lt; endl;\n    matrix = {{-5}};\n    cout &lt;&lt; kthSmallest(matrix, 1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n13\n-5\n</code></pre> <p>The core idea behind this solution is to transform the 2D matrix into a 1D sorted array, making it easier to find the <code>k</code>-th smallest element efficiently. The time complexity of this solution is dominated by the sorting step, which is <code>O(N*logN)</code>, where <code>N</code> is the total number of elements in the matrix.</p>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*logN)</code>, where <code>N = n^2</code> is the total number of elements in the matrix.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#solution-2-build-the-max-heap-and-keep-it-ungrown","title":"Solution 2: Build the max heap and keep it ungrown","text":"<p>Instead of sorting after building the vector in Solution 1, you can do the other way around. It means building up the vector from scratch and keeping it sorted. </p> <p>Since you need only the <code>k-th</code> smallest element, <code>std::priority_queue</code> can be used for this purpose.</p>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;queue&gt;\nusing namespace std;\nint kthSmallest(const vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) {\n    priority_queue&lt;int&gt; q;\n    for (int row = 0; row &lt; matrix.size(); row++) {\n        for (int col = 0; col &lt; matrix[row].size(); col++) {\n            q.push(matrix[row][col]);\n            // maintain q's size does not exceed k\n            if (q.size() &gt; k) {\n                q.pop();\n            }\n        }\n    }\n    return q.top();\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; matrix{{1,5,9},{10,11,13},{12,13,15}};\n    cout &lt;&lt; kthSmallest(matrix, 8) &lt;&lt; endl;\n    matrix = {{-5}};\n    cout &lt;&lt; kthSmallest(matrix, 1) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n13\n-5\n</code></pre>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*logk)</code>, where <code>N = n^2</code> is the total number of elements of the matrix.</li> <li>Extra space: <code>O(k)</code>.</li> </ul>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#conclusion","title":"Conclusion","text":"<p>Solution 2 maintains a priority queue of size <code>k</code>, allowing it to efficiently keep track of the <code>k</code>-th smallest element encountered while iterating through the matrix. </p> <p>This approach is handy for large matrices, as it doesn't require sorting the entire matrix. </p>"},{"location":"source/Priority_Queue/378_Kth_Smallest_Element_in_a_Sorted_Matrix/#exercise","title":"Exercise","text":"<ul> <li>Find K Pairs with Smallest Sums.</li> </ul>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/","title":"Kth Largest Element in a Stream","text":""},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#problem-statement","title":"Problem statement","text":"<p>Create a class that can find the <code>k-th</code> largest element in a stream of integers. This is the <code>k-th</code> largest element when the elements are arranged in sorted order, not the <code>k-th</code> distinct element.</p> <p>The <code>KthLargest</code> class needs to support the following operations:</p> <ol> <li><code>KthLargest(int k, int[] nums)</code>: This initializes the object with an integer <code>k</code> and a stream of integers <code>nums</code>.</li> <li><code>int add(int val)</code>: This method adds the integer <code>val</code> to the stream and returns the element representing the <code>k-th</code> largest element in the stream. </li> </ol>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#example-1","title":"Example 1","text":"<pre><code>Input\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n</code></pre>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= k &lt;= 10^4</code>.</li> <li><code>0 &lt;= nums.length &lt;= 10^4</code>.</li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code>.</li> <li><code>-10^4 &lt;= val &lt;= 10^4</code>.</li> <li>At most <code>10^4</code> calls will be made to add.</li> <li>It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k-th</code> element.</li> </ul>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#solution-1-sort-and-append","title":"Solution 1: Sort and Append","text":"<p>Sort the stream when initialization. And keep it sorted whenever you append a new value.</p>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#example-1_1","title":"Example 1","text":"<p>For <code>nums = [4, 5, 8, 2]</code> and <code>k = 3</code>. * Sort <code>nums = [8, 5, 4, 2]</code>. * Adding <code>3</code> to <code>nums</code>. It becomes <code>[8, 5, 4, 3, 2]</code>. The third largest element is <code>4</code>. * Adding <code>5</code> to <code>nums</code>. It becomes <code>[8, 5, 5, 4, 3, 2]</code>. The third largest element is <code>5</code>.  * Adding <code>10</code> to <code>nums</code>. It becomes <code>[10, 8, 5, 5, 4, 3, 2]</code>. The third largest element is <code>5</code>. * So on and so on.</p>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass KthLargest {\n    vector&lt;int&gt; _nums;\n    int _k;\npublic:\n    KthLargest(int k, vector&lt;int&gt;&amp; nums) : _nums(nums), _k(k) {   \n        // sort the nums when constructed\n        sort(_nums.begin(), _nums.end(), std::greater());\n    }\n\n    int add(int val) {\n        auto it = _nums.begin();\n        // find the position to insert val\n        while (it != _nums.end() &amp;&amp;  val &lt; *it) {\n            it++;\n        }\n        _nums.insert(it, val);\n        // return the k-th largest element\n        return *(_nums.begin() + _k - 1);\n    }\n};\nint main() {\n    vector&lt;int&gt; nums{4,5,8,2};\n    KthLargest a(3, nums);\n    cout &lt;&lt; a.add(3) &lt;&lt; endl;\n    cout &lt;&lt; a.add(5) &lt;&lt; endl;\n    cout &lt;&lt; a.add(10) &lt;&lt; endl;\n    cout &lt;&lt; a.add(9) &lt;&lt; endl;\n    cout &lt;&lt; a.add(4) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n4\n5\n5\n8\n8\n</code></pre> <p>This solution maintains a sorted vector <code>_nums</code> in non-ascending order upon initialization, which stores the elements. When adding a new element <code>val</code>, it inserts it into <code>_nums</code> while maintaining the sorted order. </p> <p>Since <code>_nums</code> is sorted in non-ascending order, the <code>k</code>-th largest element is always at index <code>_k - 1</code>. Thus, upon adding a new element, it returns the value at index <code>_k - 1</code> as the <code>k</code>-th largest element in the collection. </p> <p>This approach optimizes the <code>add</code> operation by leveraging the sorted nature of the data structure, resulting in efficient retrieval of the <code>k</code>-th largest element.</p>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#complexity","title":"Complexity","text":"<ul> <li>Runtime: for the constructor <code>O(N*logN)</code>, where <code>N = nums.length</code>. For the <code>add</code> method, <code>O(N)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#solution-2-priority-queue","title":"Solution 2: Priority queue","text":"<p>There is a data structure that has the property you want in this problem. </p> <p>It is <code>std::priority_queue</code>, which keeps its top element is always the largest one according to the comparison you define for the queue.</p> <p>By default, the \"less than\" comparison is used for {index}<code>std::priority_queue</code> (heap) and the top one is always the biggest element. </p> <p>If you want the top one is always the smallest element, you can use the comparison \"greater than\" for your heap.</p>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;queue&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nclass KthLargest {\n    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; _q;\n    int _k;\npublic:\n    KthLargest(int k, vector&lt;int&gt;&amp; nums)\n    // create the heap when constructed \n    : _q(nums.begin(), nums.end()), _k(k) {\n\n    }\n\n    int add(int val) {\n        _q.push(val);\n\n        // remove elements until _q remains k elements\n        while (_q.size() &gt; _k) {\n            _q.pop();\n        }\n        return _q.top();\n    }\n};\nint main() {\n    vector&lt;int&gt; nums{4,5,8,2};\n    KthLargest a(3, nums);\n    cout &lt;&lt; a.add(3) &lt;&lt; endl;\n    cout &lt;&lt; a.add(5) &lt;&lt; endl;\n    cout &lt;&lt; a.add(10) &lt;&lt; endl;\n    cout &lt;&lt; a.add(9) &lt;&lt; endl;\n    cout &lt;&lt; a.add(4) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n4\n5\n5\n8\n8\n</code></pre>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: for the constructor, <code>O(N*logN)</code>, where <code>N = nums.length</code>. For the <code>add</code> method, <code>O(logN)</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#conclusion","title":"Conclusion","text":"<p>The key insight of Solution 2 is utilizing a min-heap (priority queue with the <code>greater</code> comparator) to find the kth largest element in a collection. </p> <p>Upon initialization, the constructor populates the priority queue with the elements from the input vector <code>nums</code>. When adding a new element <code>val</code>, it inserts it into the priority queue and then removes elements until the size of the priority queue is reduced to <code>_k</code>, ensuring that only the k largest elements are retained in the queue. </p> <p>Finally, it returns the top element of the priority queue, which represents the kth largest element. This approach leverages the properties of a min-heap to track the kth largest element in the collection, resulting in an overall efficient solution.</p>"},{"location":"source/Priority_Queue/703_Kth_Largest_Element_in_a_Stream/#exercise","title":"Exercise","text":"<ul> <li>Kth Largest Element in an Array.</li> </ul>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/","title":"Remove Covered Intervals","text":""},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#problem-statement","title":"Problem statement","text":"<p>You're given an array called <code>intervals</code>, where each element <code>intervals[i]</code> is a pair <code>[li, ri]</code> representing a half-open interval <code>[li, ri)</code>.</p> <p>Your task is to remove all intervals from the list that are completely covered by another interval. An interval <code>[a, b)</code> is considered covered by the interval <code>[c, d)</code> if and only if <code>c</code> is less than or equal to <code>a</code>, and <code>b</code> is less than or equal to <code>d</code>.</p> <p>After removing the covered intervals, you need to return the number of remaining intervals.</p>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#example-1","title":"Example 1","text":"<pre><code>Input: intervals = [[1,4],[3,6],[2,8]]\nOutput: 2\nExplanation: Interval [3,6] is covered by [2,8], therefore it is removed.\n</code></pre>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#example-2","title":"Example 2","text":"<pre><code>Input: intervals = [[1,4],[2,3]]\nOutput: 1\n</code></pre>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= intervals.length &lt;= 1000</code>.</li> <li><code>intervals[i].length == 2</code>.</li> <li><code>0 &lt;= li &lt;= ri &lt;= 10^5</code>.</li> <li>All the given intervals are unique.</li> </ul>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":"<p>For each interval <code>i</code>, find if any other interval <code>j</code> such that <code>j</code> covers <code>i</code> or <code>i</code> covers <code>j</code> then remove the smaller one from <code>intervals</code>.</p>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#example-1_1","title":"Example 1","text":"<p>For <code>intervals = [[1,4],[3,6],[2,8]]</code>. * With interval <code>i = [1,4]</code>, there is no other interval <code>j</code> such that covers <code>i</code> or <code>j</code> covers <code>i</code>. * With interval <code>i = [3,6]</code>, there is interval <code>j = [2,8]</code> convering <code>i</code>. Remove <code>[3,6]</code> from <code>intervals</code>.</p> <p>Final <code>intervals = [[1,4],[2,8]]</code>.</p>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n//! @return true if the interval i is covered by j\ninline bool isCovered(const vector&lt;int&gt;&amp; i, const vector&lt;int&gt;&amp; j) {\n    return j[0] &lt;= i[0] &amp;&amp; i[1] &lt;= j[1];\n}\nint removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    int i = 0;\n    while (i &lt; intervals.size() - 1) {\n        int j = i + 1;\n        bool erase_i = false;\n        while (j &lt; intervals.size()) {\n            if (isCovered(intervals[i], intervals[j])) {\n                // remove intervals[i] from intervals\n                intervals.erase(intervals.begin() + i);\n                erase_i = true;\n                break;\n            } else if (isCovered(intervals[j], intervals[i])) {\n                // remove intervals[j] from intervals\n                intervals.erase(intervals.begin() + j);\n            } else {\n                j++;\n            }\n        }\n        if (!erase_i) {\n            i++;\n        }\n    }\n    return intervals.size();\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals{{1,4},{3,6},{2,8}};\n    cout &lt;&lt; removeCoveredIntervals(intervals) &lt;&lt; endl;\n    intervals = {{1,4},{2,3}};\n    cout &lt;&lt; removeCoveredIntervals(intervals) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre> <p>This solution effectively removes covered intervals and retains only those that do not have others covering them. The time complexity of this solution is <code>O(N^3)</code>, where <code>N</code> is the number of intervals, as it involves nested loops and potential removal of intervals from the list.</p>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N^3)</code>, where <code>N = intervals.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#solution-2-using-indexdictionary-order","title":"Solution 2: Using {index}<code>dictionary order</code>","text":"<p>You might know how to look up words in a dictionary. </p> <p>The word <code>apple</code> appears before <code>candy</code> in the dictionary because the starting letter <code>a</code> of <code>apple</code> appears before <code>c</code> of <code>candy</code> in the English alphabet. </p> <p>And <code>apple</code> appears after <code>animal</code> since the next letter <code>p</code> appears after <code>n</code>.</p> <p>The C++ Standard Library uses that dictionary order to compare two <code>std::vector</code>s.</p>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#example-1_2","title":"Example 1","text":"<p>Rewriting <code>intervals = [[1,4],[3,6],[2,8]]</code> in dictionary order you get <code>intervals = [[1,4],[2,8],[3,6]]</code>. In this order, the left bounds of the <code>intervals</code> are sorted first.</p> <p>If <code>intervals</code> is sorted like that, you can avoid bruteforce in Solution 1 by a simpler algorithm.</p> <p>Check if each interval <code>i</code> covers or is covered by some of the previous ones.</p> <p>Remember that the left bound of interval <code>i</code> is always bigger than or equal to all left bounds of the previous ones. So,</p> <ol> <li><code>i</code> is covered by some previous interval if the right bound of <code>i</code> is less than some of the right bounds before.</li> <li>Otherwise <code>i</code> can only cover its exact previous one that has the same left bound. </li> </ol>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint removeCoveredIntervals(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n    // sort the intervals using dictionary order\n    sort(intervals.begin(), intervals.end());\n    // count the intervals to be removed \n    int count = 0;      \n    // keep track max right bound of all previous intervals\n    int maxRight = -1;  \n    // log the left bound of the previous interval\n    int preLeft = -1;   \n    for (auto&amp; i : intervals) {\n        if (i[1] &lt;= maxRight) { \n            // i's right bound is less than some previous one's\n            count++;\n        } else if (i[0] == preLeft) { \n            // i's left bound is the same as exact previous one's\n            count++;\n        } else {\n            // update previous interval's left bound\n            preLeft = i[0];\n        }\n        // update max right bound\n        maxRight = max(maxRight, i[1]);\n    }\n    return intervals.size() - count;\n}\nint main() {\n    vector&lt;vector&lt;int&gt;&gt; intervals{{1,4},{3,6},{2,8}};\n    cout &lt;&lt; removeCoveredIntervals(intervals) &lt;&lt; endl;\n    intervals = {{1,4},{2,3}};\n    cout &lt;&lt; removeCoveredIntervals(intervals) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*logN)</code>, where <code>N = intervals.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Sorting/1288_Remove_Covered_Intervals/#key-takeaway","title":"Key takeaway","text":"<ul> <li>Two <code>std::vector</code>s can be compared using dictionary order.</li> <li>Solution 2 first sorts the intervals and then iterates through them while keeping track of whether each interval is covered by others or not. The final result is the count of intervals that are not covered. </li> </ul>"},{"location":"source/Sorting/169_Majority_Element/","title":"Majority Element","text":"<p>% Easy</p>"},{"location":"source/Sorting/169_Majority_Element/#problem-statement","title":"Problem statement","text":"<p>You're given an array <code>nums</code> with a total of <code>n</code> elements. Your task is to find and return the majority element.</p> <p>The majority element is the element that appears more frequently in the array than any other element, specifically, it appears more than <code>n / 2</code> times.</p> <p>You can assume that the majority element always exists in the given array.</p>"},{"location":"source/Sorting/169_Majority_Element/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [3,2,3]\nOutput: 3\n</code></pre>"},{"location":"source/Sorting/169_Majority_Element/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [2,2,1,1,1,2,2]\nOutput: 2\n</code></pre>"},{"location":"source/Sorting/169_Majority_Element/#constraints","title":"Constraints","text":"<ul> <li><code>n == nums.length</code>.</li> <li><code>1 &lt;= n &lt;= 5 * 10^4</code>.</li> <li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code>.</li> </ul>"},{"location":"source/Sorting/169_Majority_Element/#follow-up","title":"Follow-up:","text":"<p>Could you solve the problem in linear time and in <code>O(1)</code> space?</p>"},{"location":"source/Sorting/169_Majority_Element/#solution-1-counting-the-frequency","title":"Solution 1: Counting the frequency","text":""},{"location":"source/Sorting/169_Majority_Element/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint majorityElement(const vector&lt;int&gt;&amp; nums) {\n    unordered_map&lt;int,int&gt; freq;\n    const int HALF = nums.size() / 2;\n    for (auto&amp; a : nums) {\n        // count a's occurrences\n        freq[a]++; \n        if (freq[a] &gt; HALF) {\n            return a;\n        }\n    }\n    return nums[0];\n}\nint main() {\n    vector&lt;int&gt; nums{3,2,3};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n    nums = {2,2,1,1,1,2,2};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre> <p>The code effectively counts the occurrences of each integer in the array and checks if any integer appears more than <code>n/2</code> times. If so, it returns that integer as the majority element; otherwise, it defaults to the first element of the array.</p>"},{"location":"source/Sorting/169_Majority_Element/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(n)</code>.</li> </ul>"},{"location":"source/Sorting/169_Majority_Element/#solution-2-sorting-and-picking-the-middle-element","title":"Solution 2: Sorting and picking the middle element","text":""},{"location":"source/Sorting/169_Majority_Element/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint majorityElement(vector&lt;int&gt;&amp; nums) {\n    sort(nums.begin(), nums.end());\n    return nums[nums.size()/2];\n}\nint main() {\n    vector&lt;int&gt; nums{3,2,3};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n    nums = {2,2,1,1,1,2,2};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre> <p>This code leverages the property of a majority element, which guarantees that it occupies the middle position in the sorted list of elements. Sorting the array allows us to easily access this middle element. </p>"},{"location":"source/Sorting/169_Majority_Element/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n*logn)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Sorting/169_Majority_Element/#solution-3-indexpartial-sort","title":"Solution 3: {index}<code>Partial sort</code>","text":"<p>Since you are interested in only the middle element after sorting, the partial sorting algorithm <code>std::nth_element</code> can be used in this case to reduce the cost of the full sorting.</p>"},{"location":"source/Sorting/169_Majority_Element/#code_2","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint majorityElement(vector&lt;int&gt;&amp; nums) {\n    const int mid = nums.size() / 2;\n    // rearrange nums such that all elements less than or equal nums[mid] \n    // are placed before nums[mid]\n    nth_element(nums.begin(), nums.begin() + mid, nums.end());\n    return nums[mid];\n}\nint main() {\n    vector&lt;int&gt; nums{3,2,3};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n    nums = {2,2,1,1,1,2,2};\n    cout &lt;&lt; majorityElement(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n2\n</code></pre> <p>The code uses the {index}<code>std::nth_element</code> function to rearrange the elements in the <code>nums</code> vector such that the element at index <code>mid</code> will be in its correct sorted position, and all elements before it will be less than or equal to it, while all elements after it will be greater than or equal to it.</p>"},{"location":"source/Sorting/169_Majority_Element/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Sorting/169_Majority_Element/#modern-c-tips","title":"Modern C++ tips","text":"<p>In the code of Solution 3, the partial sorting algorithm <code>std::nth_element</code> will make sure for all indices <code>i</code> and <code>j</code> that satisfy <code>0 &lt;= i &lt;= mid &lt;= j &lt; nums.length</code>,</p> <pre><code>nums[i] &lt;= nums[mid] &lt;= nums[j].\n</code></pre> <p>In other words, <code>nums[mid]</code> divides the array <code>nums</code> into two groups: all elements that are less than or equal to <code>nums[mid]</code> and the ones that are greater than or equal to <code>nums[mid]</code>. </p> <p>Those two groups are unsorted. That is why the algorithm is called partial sorting. </p>"},{"location":"source/Sorting/169_Majority_Element/#exercise","title":"Exercise","text":"<ul> <li>Most Frequent Even Element.</li> </ul>"},{"location":"source/Sorting/729_My_Calendar_I/","title":"My Calendar I","text":""},{"location":"source/Sorting/729_My_Calendar_I/#problem-statement","title":"Problem statement","text":"<p>You're creating a program to use as your calendar. You can add new events to the calendar, but only if adding the event will not lead to a double booking.</p> <p>A double booking occurs when two events have some time overlap, meaning there's a shared time period between them.</p> <p>An event is represented as a pair of integers: <code>start</code> and <code>end</code>, which represent the booking on a half-open interval <code>[start, end)</code>. This interval includes all real numbers <code>x</code> such that <code>start &lt;= x &lt; end</code>.</p> <p>You need to implement the <code>MyCalendar</code> class, which has the following functions:</p> <ol> <li><code>MyCalendar()</code>: Initializes the calendar object.</li> <li><code>boolean book(int start, int end)</code>: This function checks if the event with the given <code>start</code> and <code>end</code> can be added to the calendar without causing a double booking. If it's possible to add the event without a double booking, the function returns <code>true</code>. Otherwise, it returns <code>false</code>, and the event is not added to the calendar. </li> </ol>"},{"location":"source/Sorting/729_My_Calendar_I/#example-1","title":"Example 1","text":"<pre><code>Input\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\nOutput\n[null, true, false, true]\n\nExplanation\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False. It can not be booked because time 15 is already booked by another event.\nmyCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.\n</code></pre>"},{"location":"source/Sorting/729_My_Calendar_I/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= start &lt; end &lt;= 10^9</code>.</li> <li>At most <code>1000</code> calls will be made to book.</li> </ul>"},{"location":"source/Sorting/729_My_Calendar_I/#solution-1-vector","title":"Solution 1: Vector","text":"<p>You can store the booked events in a vector and check the intersection condition whenever you add a new event.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nclass MyCalendar {\n    private:\n    vector&lt;pair&lt;int,int&gt;&gt; _events;\npublic:\n    MyCalendar() {}\n    bool book(int start, int end) {\n        for (auto&amp; e : _events) {\n            // check for overlap\n            if (!(e.second &lt;= start || end &lt;= e.first)) {\n                return false;\n            }\n        }\n        _events.push_back({start, end});\n        return true;\n    }\n};\nint main() {\n    MyCalendar c;\n    std::cout &lt;&lt; c.book(10, 20) &lt;&lt; std::endl;\n    std::cout &lt;&lt; c.book(15, 25) &lt;&lt; std::endl;\n    std::cout &lt;&lt; c.book(20, 30) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre> <p>This code essentially maintains a list of events and checks for overlaps when booking a new event. If no overlaps are found, it adds the new event to the list and allows the booking.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#complexity","title":"Complexity","text":"<p>For the <code>book</code> method: * Runtime: <code>O(n)</code>, where <code>n</code>= <code>_events.length</code>. * Extra space: <code>O(1)</code>.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#solution-2-set","title":"Solution 2: Set","text":"<p>Since the events have no intersection, they can be sorted. You can also consider two events to be the same if they intersect.</p> <p>With that in mind, you can use <code>std::set</code> to store the sorted unique events.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\nusing namespace std;\nusing Event = pair&lt;int,int&gt;;\nstruct EventCmp {\n    bool operator()(const Event&amp; lhs, const Event&amp; rhs) const { \n        return lhs.second &lt;= rhs.first; \n    }\n};\nclass MyCalendar {\n    private:\n    // declare a set with custom comparison operator\n    set&lt;Event, EventCmp&gt; _events;\npublic:\n    MyCalendar() {} \n    bool book(int start, int end) {\n        auto result = _events.insert({start, end});\n        // result.second stores a bool indicating \n        // if the insertion was actually performed \n        return result.second; \n    }\n};\nint main() {\n    MyCalendar c;\n    std::cout &lt;&lt; c.book(10, 20) &lt;&lt; std::endl;\n    std::cout &lt;&lt; c.book(15, 25) &lt;&lt; std::endl;\n    std::cout &lt;&lt; c.book(20, 30) &lt;&lt; std::endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n</code></pre>"},{"location":"source/Sorting/729_My_Calendar_I/#complexity_1","title":"Complexity","text":"<p>For the <code>book</code> method: * Runtime: <code>O(logn)</code>, where <code>n = _events.length</code>. * Extra space: <code>O(1)</code>.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#key-takeaway","title":"Key Takeaway","text":"<p>Solution 2 efficiently handles event bookings by maintaining a sorted set of events based on their end times, allowing for quick overlap checks when booking new events.</p>"},{"location":"source/Sorting/729_My_Calendar_I/#exercise","title":"Exercise","text":"<ul> <li>Determine if Two Events Have Conflict.</li> </ul>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/","title":"Remove Duplicates from Sorted Array II","text":""},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#problem-statement","title":"Problem statement","text":"<p>Given an integer array <code>nums</code> already sorted in non-decreasing order, you must remove duplicates so that each unique element appears at most twice. The relative order of the elements should remain unchanged.</p> <p>Since changing the array's length in some programming languages is impossible, you must place the result in the first part of the <code>nums</code> array. In other words, if there are <code>k</code> elements after removing the duplicates, the first <code>k</code> elements of <code>nums</code> should contain the final result. Anything beyond the first <code>k</code> elements is not important.</p> <p>You should return the value of <code>k</code> after placing the final result in the first <code>k</code> slots of the <code>nums</code> array.</p> <p>The key requirement is to accomplish this task without using extra space for another array. It must be done by modifying the input array <code>nums</code> in-place, using only <code>O(1)</code> extra memory.</p>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2, and 3, respectively.\nWhat you leave does not matter beyond the returned k (hence, they are underscores).\n</code></pre>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3, and 3, respectively.\nWhat you leave does not matter beyond the returned k (hence, they are underscores).\n</code></pre>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 3 * 10^4</code>.   </li> <li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code>.</li> <li><code>nums</code> is sorted in non-decreasing order.</li> </ul>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#solution-1-erasing-the-duplicates","title":"Solution 1: Erasing the duplicates","text":"<p>In order for each unique element to appear at most twice, you have to erase the further appearances if they exist.</p> <p>Since the array <code>nums</code> is sorted, you can determine that existence by checking if <code>nums[i] == nums[i-2]</code> for <code>2 &lt;= i &lt; nums.length</code>.</p>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint removeDuplicates(vector&lt;int&gt;&amp; nums) {\n    int i = 2;\n    while (i &lt; nums.size()) {\n        // find the element appearing more than twice\n        if (nums[i] == nums[i-2]) {\n            int j = i;\n            // find all duplicates\n            while (j &lt; nums.size() &amp;&amp; nums[j] == nums[i]) {\n                j++;\n            }\n            // keep nums[i-2] and nums[i-1] remove all later duplicates \n            nums.erase(nums.begin() + i, nums.begin() + j);\n        } else {\n            i++;\n        }\n    }\n    return nums.size();\n}\nvoid printResult(const int k, const vector&lt;int&gt;&amp; nums) {\n    cout &lt;&lt; k &lt;&lt; \", [\";\n    for (int i = 0; i &lt; k ; i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums{1,1,1,2,2,3};\n    printResult(removeDuplicates(nums), nums);\n    nums = {0,0,1,1,1,1,2,3,3};\n    printResult(removeDuplicates(nums), nums);\n}\n</code></pre> <pre><code>Output:\n5, [1,1,2,2,3,]\n7, [0,0,1,1,2,3,3,]\n</code></pre> <p>This solution efficiently removes duplicates from the sorted array by checking for duplicates and erasing the excess occurrences while preserving two instances of each unique element. It then returns the length of the modified array.</p>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#complexity","title":"Complexity","text":"<ul> <li> <p>Runtime:</p> <ul> <li>Worst case: <code>O(N^2/3)</code>, where <code>N = nums.size()</code>. The complexity of the <code>erase()</code> method is linear in <code>N</code>. The worst case is when <code>erase()</code> is called maximum <code>N/3</code> times.</li> </ul> <p><code>text Example of the worst case: nums = [1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6].</code></p> <ul> <li>On average: <code>O(N)</code> since the number of <code>erase()</code> calls is <code>O(1)</code>.</li> </ul> </li> <li> <p>Extra space: <code>O(1)</code>.</p> </li> </ul>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#solution-2-reassigning-the-satisfying-elements","title":"Solution 2: Reassigning the satisfying elements","text":"<p>You might need to avoid the <code>erase()</code> method in the solution above to reduce the complexity. Moreover, after removing the duplicates, the problem only cares about the first <code>k</code> elements of the array <code>nums</code>.</p> <p>If you look at the final result after removing duplication, the expected <code>nums</code> satisfies</p> <pre><code>nums[i] &gt; nums[i-2] for 2 &lt;= i &lt; nums.length.\n</code></pre> <p>You can use this invariant to reassign the array <code>nums</code> only the satisfied elements.</p>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint removeDuplicates(vector&lt;int&gt;&amp; nums) {\n    if (nums.size() &lt;= 2) {\n        return nums.size(); \n    } \n    int k = 2; \n    int i = 2;\n    while (i &lt; nums.size()) {\n        if (nums[i] &gt; nums[k - 2]) {\n            // make sure nums[k] != nums[k-2]\n            nums[k++] = nums[i];\n        }\n        i++;\n    }\n    return k;\n}\nvoid printResult(const int k, const vector&lt;int&gt;&amp; nums) {\n    cout &lt;&lt; k &lt;&lt; \", [\";\n    for (int i = 0; i &lt; k ; i++) {\n        cout &lt;&lt; nums[i] &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums{1,1,1,2,2,3};\n    printResult(removeDuplicates(nums), nums);\n    nums = {0,0,1,1,1,1,2,3,3};\n    printResult(removeDuplicates(nums), nums);\n}\n</code></pre> <pre><code>Output:\nOutput:\n5, [1,1,2,2,3,]\n7, [0,0,1,1,2,3,3,]\n</code></pre>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#complexity_1","title":"Complexity","text":"<ul> <li> <p>Runtime: <code>O(N)</code>, where <code>N = nums.size()</code>.</p> </li> <li> <p>Extra space: <code>O(1)</code>.</p> </li> </ul>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#conclusion","title":"Conclusion","text":"<p>Solution 2 effectively modifies the input array in-place, removing duplicates that occur more than twice while maintaining the desired order of unique elements. It does so in a single pass through the array, resulting in a time complexity of <code>O(N)</code>, where <code>N</code> is the number of elements in the array.</p>"},{"location":"source/Sorting/80_Remove_Duplicates_from_Sorted_Array/#exercise","title":"Exercise","text":"<ul> <li>Remove Duplicates from Sorted Array.</li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/","title":"Merge Sorted Array","text":""},{"location":"source/Sorting/88_Merge_Sorted_Array/#problem-statement","title":"Problem statement","text":"<p>You're given two integer arrays, <code>nums1</code> and <code>nums2</code>, both sorted in non-decreasing order. Additionally, you have two integers, <code>m</code> and <code>n</code>, representing the number of elements in <code>nums1</code> and <code>nums2</code>, respectively.</p> <p>Your task is to merge the elements from <code>nums2</code> into <code>nums1</code> in a way that the resulting array is sorted in non-decreasing order.</p> <p>However, the sorted array should not be returned as a separate result. Instead, the merged elements should be stored inside the <code>nums1</code> array. Here's the setup for that purpose: </p> <ul> <li><code>nums1</code> has a total length of <code>m + n</code>, where the first <code>m</code> elements represent the elements that should be merged, and the last <code>n</code> elements are initialized to <code>0</code> and should be ignored. </li> <li>The <code>nums2</code> array has a length of <code>n</code>, representing the elements to be merged from <code>nums2</code> into the final <code>nums1</code> array. </li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#example-1","title":"Example 1","text":"<pre><code>Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n</code></pre>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#example-2","title":"Example 2","text":"<pre><code>Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n</code></pre>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#example-3","title":"Example 3","text":"<pre><code>Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n</code></pre>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#constraints","title":"Constraints","text":"<ul> <li><code>nums1.length == m + n</code>.</li> <li><code>nums2.length == n</code>.</li> <li><code>0 &lt;= m, n &lt;= 200</code>.</li> <li><code>1 &lt;= m + n &lt;= 200</code>.</li> <li><code>-10^9 &lt;= nums1[i], nums2[j] &lt;= 10^9</code>.</li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#follow-up","title":"Follow up","text":"<ul> <li>Can you come up with an algorithm that runs in <code>O(m + n)</code> time?</li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#solution-1-store-the-result-in-a-new-container","title":"Solution 1: Store the result in a new container","text":""},{"location":"source/Sorting/88_Merge_Sorted_Array/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvoid merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) \n{\n    vector&lt;int&gt; result;\n    int i = 0;\n    int j = 0;\n    while (i &lt; m || j &lt; n) {\n        if (j == n) { \n            // nums2 is done, only nums1 still runs\n            result.push_back(nums1[i++]);\n        } else if (i == m) {\n            // nums1 is done, only nums2 still runs\n            result.push_back(nums2[j++]);\n        } else if (nums1[i] &lt; nums2[j]) {\n            result.push_back(nums1[i++]);\n        } else {\n            result.push_back(nums2[j++]);\n        }\n    }\n    nums1.swap(result);\n}\nvoid printResult(const vector&lt;int&gt;&amp; nums1) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; n : nums1) {\n        cout &lt;&lt; n &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums1 = {1,2,3,0,0,0};\n    vector&lt;int&gt; nums2 = {2,5,6};\n    merge(nums1, 3, nums2, 3);\n    printResult(nums1);\n    nums1 = {1};\n    nums2 = {};\n    merge(nums1, 1, nums2, 0);\n    printResult(nums1);\n    nums1 = {0};\n    nums2 = {1};\n    merge(nums1, 0, nums2, 1);\n    printResult(nums1);\n}\n</code></pre> <pre><code>Output:\n[1,2,2,3,5,6,]\n[1,]\n[1,]\n</code></pre> <p>This solution merges two sorted arrays <code>nums1</code> and <code>nums2</code> into <code>nums1</code> while maintaining sorted order. It iterates through both arrays, comparing elements and adding them to a temporary <code>result</code> vector. After the merging is complete, it replaces the contents of <code>nums1</code> with the merged result. </p>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m+n)</code>, where <code>m = nums1.length</code> and <code>n = nums2.length</code>.</li> <li>Extra space: <code>O(m+n)</code>.</li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#solution-2-reassigning-nums1-backward","title":"Solution 2: Reassigning <code>nums1</code> backward","text":""},{"location":"source/Sorting/88_Merge_Sorted_Array/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nvoid merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) \n{    \n    int k = m + n - 1;\n    int i = m - 1;\n    int j = n - 1;\n    while (k &gt;= 0) {\n        if (j &lt; 0) { \n            // nums2 is done\n            nums1[k--] = nums1[i--];\n        } else if (i &lt; 0) { \n            // nums1 is done\n            nums1[k--] = nums2[j--];\n        } else if (nums1[i] &gt; nums2[j]) {\n            nums1[k--] = nums1[i--]; \n        } else {\n            nums1[k--] = nums2[j--]; \n        }\n    }\n}\nvoid printResult(const vector&lt;int&gt;&amp; nums1) {\n    cout &lt;&lt; \"[\";\n    for (auto&amp; n : nums1) {\n        cout &lt;&lt; n &lt;&lt; \",\";\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    vector&lt;int&gt; nums1 = {1,2,3,0,0,0};\n    vector&lt;int&gt; nums2 = {2,5,6};\n    merge(nums1, 3, nums2, 3);\n    printResult(nums1);\n    nums1 = {1};\n    nums2 = {};\n    merge(nums1, 1, nums2, 0);\n    printResult(nums1);\n    nums1 = {0};\n    nums2 = {1};\n    merge(nums1, 0, nums2, 1);\n    printResult(nums1);\n}\n</code></pre> <pre><code>Output:\n[1,2,2,3,5,6,]\n[1,]\n[1,]\n</code></pre>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(m+n)</code>, where <code>m = nums1.length</code> and <code>n = nums2.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#conclusion","title":"Conclusion","text":"<p>Solution 2 efficiently merges two sorted arrays, <code>nums1</code> and <code>nums2</code>, into <code>nums1</code> while preserving the sorted order. It uses three pointers (<code>k</code>, <code>i</code>, and <code>j</code>) to perform the merge in reverse order, which helps avoid the need for additional space. </p>"},{"location":"source/Sorting/88_Merge_Sorted_Array/#exercise","title":"Exercise","text":"<ul> <li>Squares of a Sorted Array.</li> </ul>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/","title":"Remove All Adjacent Duplicates in String II","text":""},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#problem-statement","title":"Problem statement","text":"<p>You are given a string <code>s</code> and an integer <code>k</code>. A <code>k</code> duplicate removal operation involves selecting <code>k</code> adjacent and identical letters from <code>s</code> and removing them, causing the remaining portions on the left and right of the removed substring to join together.</p> <p>You need to perform the <code>k</code> duplicate removal operation on <code>s</code> repeatedly until it is no longer possible. After completing all such operations, return the resulting string. It is guaranteed that the answer will be unique.</p>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"abcd\", k = 2\nOutput: \"abcd\"\nExplanation: There is nothing to delete.\n</code></pre>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"deeedbbcccbdaa\", k = 3\nOutput: \"aa\"\nExplanation: \nFirst delete \"eee\" and \"ccc\", get \"ddbbbdaa\"\nThen delete \"bbb\", get \"dddaa\"\nFinally delete \"ddd\", get \"aa\"\n</code></pre>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"pbbcggttciiippooaais\", k = 2\nOutput: \"ps\"\n</code></pre>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length &lt;= 10^5</code>.</li> <li><code>2 &lt;= k &lt;= 10^4</code>.</li> <li><code>s</code> only contains lower case English letters.</li> </ul>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#solution-strings-of-adjacent-equal-letters","title":"Solution: Strings of adjacent equal letters","text":"<p>Construct a stack of strings that has adjacent equal letters and perform the removal during building those strings.</p>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#example-2_1","title":"Example 2","text":"<p>For <code>s = \"deeedbbcccbdaa\"</code> and <code>k = 3</code>:</p> <ul> <li>The first built string is <code>\"d\"</code>.</li> <li>Then <code>\"eee\"</code> with the exact length <code>k</code>, remove this string.</li> <li>The next character is <code>'d'</code>, which equals the last character of the last string <code>\"d\"</code>, merge them together. The first string becomes <code>\"dd\"</code>.</li> <li>The next string is <code>\"bb\"</code>.</li> <li>Then <code>\"ccc\"</code> is removed.</li> <li>The next character <code>'b'</code> is merged with the last string (<code>\"bb\"</code>) to become <code>\"bbb\"</code> and be removed.</li> <li>The next character <code>'d'</code> is merged with the last string (<code>\"dd\"</code>) to become <code>\"ddd\"</code> and be removed.</li> <li>The remaining string is <code>\"aa\"</code>.</li> </ul>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nstring removeDuplicates(string&amp; s, int k) {\n    // stk is used as a stack\n    // all letters in each string a of stk are equal \n    // every a's length is less than k\n    vector&lt;string&gt; stk;\n    int i = 0;\n    while (i &lt; s.length()) {\n        // a represents the current string with duplicate letters\n        string a;   \n\n        if (!stk.empty() &amp;&amp; s[i] == stk.back().back()) {\n            // let a be the latest string in stk\n            // because its letters are equal to s[i]\n            a = move(stk.back());\n            stk.pop_back();\n        }\n        int j = i;\n        // iterate all adjacent duplicates of s[i]\n        while (j &lt; s.length() &amp;&amp; s[j] == s[i]) {\n            a += s[j];\n            // remove the k-duplicate\n            if (a.length() == k) {\n                a = \"\";\n            }\n            j++;\n        }\n        // after the loop, the number of duplicates in a is less than k\n        if (!a.empty()) {            \n            stk.push_back(a);\n        }\n        i = j;\n    }\n    // create the final result from stk\n    s = \"\";\n    for (auto&amp; str : stk) {\n        s += str;\n    }\n    return s;\n}\nint main() {\n    cout &lt;&lt; removeDuplicates(\"abcd\", 2) &lt;&lt; endl;\n    cout &lt;&lt; removeDuplicates(\"deeedbbcccbdaa\", 3) &lt;&lt; endl;\n    cout &lt;&lt; removeDuplicates(\"pbbcggttciiippooaais\", 2) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\nabcd\naa\nps\n</code></pre> <p>This solution efficiently removes substrings of consecutive duplicate characters of length <code>k</code> from a given string by using a stack to keep track of the adjacent characters. </p>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#implementation-tips","title":"Implementation tips","text":"<ul> <li> <p>The data structure <code>stk</code> you might need to solve this problem is a stack. But here are the reasons you had better use <code>std::vector</code>:</p> </li> <li> <p><code>std::vector</code> also has methods <code>push_back(value)</code> and <code>pop_back()</code> like the ones in a stack.</p> </li> <li> <p>On the other hand, it is faster for a vector to perform the string concatenation at the end.</p> </li> <li> <p>In the expression <code>stk.back().back()</code>: <code>stk.back()</code> is the latest string <code>a</code> of <code>stk</code>. Then <code>stk.back().back() = a.back()</code> is the last character of <code>a</code>.</p> </li> </ul>"},{"location":"source/Stack/1209_Remove_All_Adjacent_Duplicates_in_String_II/#exercise","title":"Exercise","text":"<ul> <li>Remove All Adjacent Duplicates In String.</li> </ul>"},{"location":"source/Stack/20_Valid_Parentheses/","title":"Valid Parentheses","text":"<p>% Easy</p>"},{"location":"source/Stack/20_Valid_Parentheses/#problem-statement","title":"Problem statement","text":"<p>You are given a string <code>s</code> containing only the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code>, and <code>']'</code>. Your task is to check if the input string is valid.</p> <p>A string is considered valid if the following conditions are satisfied:</p> <ol> <li>Opening brackets must be closed by the same type of brackets.</li> <li>Opening brackets must be closed in the correct order, meaning that the innermost opening bracket should be closed before its surrounding brackets.</li> </ol>"},{"location":"source/Stack/20_Valid_Parentheses/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"()\"\nOutput: true\n</code></pre>"},{"location":"source/Stack/20_Valid_Parentheses/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"()[]{}\"\nOutput: true\n</code></pre>"},{"location":"source/Stack/20_Valid_Parentheses/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"(]\"\nOutput: false\n</code></pre>"},{"location":"source/Stack/20_Valid_Parentheses/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length &lt;= 10^4</code>.</li> <li><code>s</code> consists of parentheses only <code>'()[]{}'</code>.</li> </ul>"},{"location":"source/Stack/20_Valid_Parentheses/#solution-using-a-stack","title":"Solution: Using a stack","text":"<p>For each character <code>c</code> of <code>s</code>:</p> <ol> <li>If it is an open parenthesis (<code>'('</code>, <code>'{'</code>, or <code>'['</code>), push it into the stack.</li> <li>If it is a closed parenthesis (<code>')'</code>, <code>'}'</code>, or <code>']'</code>) but its previous character is not the corresponding open one, return <code>false</code>. End.</li> <li>Otherwise (i.e. match open-closed), erase the pair.</li> <li>Continue the process until all characters of <code>s</code> are visited.</li> <li>Return <code>true</code> if the stack is empty, i.e. all valid pairs are erased.</li> </ol>"},{"location":"source/Stack/20_Valid_Parentheses/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;stack&gt;\nusing namespace std;\nbool isValid(const string&amp; s) {\n    stack&lt;char&gt; stk;\n    for (auto&amp; c : s) {\n        if (c == '(' || c == '[' || c == '{') {\n            stk.push(c);\n        } else if (stk.empty()) {\n            // start with a non-open parenthesis is invalid\n            return false;\n        } else if (c == ')' &amp;&amp; stk.top() != '(' \n              || c == ']' &amp;&amp; stk.top() != '['\n              || c == '}' &amp;&amp; stk.top() != '{') {\n            // the last open parenthesis does not match this closed one\n            return false;\n        } else {\n            // open-close match\n            stk.pop();\n        }\n    }\n    return stk.empty();\n}\nint main() {\n    cout &lt;&lt; isValid(\"()\") &lt;&lt; endl;\n    cout &lt;&lt; isValid(\"(){}[]\") &lt;&lt; endl;\n    cout &lt;&lt; isValid(\"(]\") &lt;&lt; endl;\n    cout &lt;&lt; isValid(\"([)]\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n1\n0\n0\n</code></pre>"},{"location":"source/Stack/20_Valid_Parentheses/#complexity","title":"Complexity:","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Stack/20_Valid_Parentheses/#conclusion","title":"Conclusion","text":"<p>This solution efficiently checks the validity of a string of parentheses, brackets, and curly braces by using a stack to ensure that each opening bracket is correctly matched with its corresponding closing bracket. </p>"},{"location":"source/Stack/20_Valid_Parentheses/#exercise","title":"Exercise","text":"<ul> <li>Check If Word Is Valid After Substitutions.</li> </ul>"},{"location":"source/Stack/682_Baseball_Game/","title":"Baseball Game","text":""},{"location":"source/Stack/682_Baseball_Game/#problem-statement","title":"Problem statement","text":"<p>You are responsible for keeping score in a unique baseball game with special rules. The game involves multiple rounds where the scores of previous rounds can influence the scores of future rounds.</p> <p>At the beginning of the game, your record is empty. You are given a list of operations called <code>ops</code>, where each <code>ops[i]</code> is one of the following:</p> <ol> <li>An integer <code>x</code> - This represents recording a new score of <code>x</code>.</li> <li><code>\"+\"</code> - This represents recording a new score that is the sum of the previous two scores. It is guaranteed that there will always be two previous scores.</li> <li><code>\"D\"</code> - This represents recording a new score that is double the previous score. It is guaranteed that there will always be a previous score.</li> <li><code>\"C\"</code> - This represents invalidating the previous score, removing it from the record. It is guaranteed that there will always be a previous score.</li> </ol> <p>Your task is to calculate and return the sum of all the scores in the record after performing all the operations. </p>"},{"location":"source/Stack/682_Baseball_Game/#example-1","title":"Example 1","text":"<pre><code>Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record; the record is now [5].\n\"2\" - Add 2 to the record; the record is now [5, 2].\n\"C\" - Invalidate and remove the previous score; the record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record; the record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.\n</code></pre>"},{"location":"source/Stack/682_Baseball_Game/#example-2","title":"Example 2","text":"<pre><code>Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record; the record is now [5].\n\"-2\" - Add -2 to the record; the record is now [5, -2].\n\"4\" - Add 4 to the record; the record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score; the record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record; the record is now [5, -2, -4].\n\"9\" - Add 9 to the record; the record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n</code></pre>"},{"location":"source/Stack/682_Baseball_Game/#example-3","title":"Example 3","text":"<pre><code>Input: ops = [\"1\"]\nOutput: 1\n</code></pre>"},{"location":"source/Stack/682_Baseball_Game/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= ops.length &lt;= 1000</code>.</li> <li><code>ops[i]</code> is <code>\"C\"</code>, <code>\"D\"</code>, <code>\"+\"</code>, or a string representing an integer in the range <code>[-3 * 10^4, 3 * 10^4]</code>.</li> <li>For operation <code>\"+\"</code>, there will always be at least two previous scores on the record.</li> <li>For operations <code>\"C\"</code> and <code>\"D\"</code>, there will always be at least one previous score on the record.</li> </ul>"},{"location":"source/Stack/682_Baseball_Game/#solution","title":"Solution","text":""},{"location":"source/Stack/682_Baseball_Game/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;numeric&gt;\nusing namespace std;\nint calPoints(const vector&lt;string&gt;&amp; ops) {\n    vector&lt;int&gt; stk;\n    for (auto&amp; s : ops) {\n        if (s == \"C\") {\n            stk.pop_back();\n        } else if (s == \"D\") {\n            stk.push_back(stk.back()*2);\n        } else if (s == \"+\") {\n            stk.push_back(stk[stk.size() - 1] + stk[stk.size() - 2]);\n        } else { // s is an integer\n            stk.push_back(stoi(s));\n        }\n    }\n    // compute the sum\n    return accumulate(stk.begin(), stk.end(), 0);\n}\nint main() {\n    vector&lt;string&gt; ops{\"5\",\"2\",\"C\",\"D\",\"+\"};\n    cout &lt;&lt; calPoints(ops) &lt;&lt; endl;\n    ops = {\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"};\n    cout &lt;&lt; calPoints(ops) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n30\n27\n</code></pre> <p>This solution simulates the baseball game by processing each round's operation and maintaining a stack of valid points. It accurately calculates the final sum of valid points based on the given operations. </p>"},{"location":"source/Stack/682_Baseball_Game/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = ops.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Stack/682_Baseball_Game/#implementation-tips","title":"Implementation tips","text":"<ol> <li> <p>The data structure <code>stk</code> you might need to solve this problem is a stack. But here are the reasons you had better use <code>std::vector</code>:</p> <ul> <li><code>std::vector</code> has also methods <code>push_back(value)</code> and <code>pop_back()</code> like the ones in stack.</li> <li>On the other hand, a stack does not give easy access to the second last element for the operator <code>\"+\"</code> in this problem.</li> </ul> </li> <li> <p><code>accumulate(stk.begin(), stk.end(), 0)</code> computes the sum of the vector <code>stk</code>.</p> </li> </ol>"},{"location":"source/Stack/682_Baseball_Game/#exercise","title":"Exercise","text":"<ul> <li>Crawler Log Folder.</li> </ul>"},{"location":"source/Stack/844_Backspace_String_Compare/","title":"Backspace String Compare","text":""},{"location":"source/Stack/844_Backspace_String_Compare/#problem-statement","title":"Problem statement","text":"<p>You are provided with two strings, <code>s</code> and <code>t</code>. Your task is to determine if these two strings are equal when typed into an empty text editor, where the character <code>'#'</code> represents a backspace action.</p> <p>Note that applying a backspace action to an empty text does not change the text; it remains empty. Your function should return <code>true</code> if the two strings become equal after considering the backspace actions, otherwise return <code>false</code>. </p>"},{"location":"source/Stack/844_Backspace_String_Compare/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"ab#c\", t = \"ad#c\"\nOutput: true\nExplanation: Both s and t become \"ac\".\n</code></pre>"},{"location":"source/Stack/844_Backspace_String_Compare/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"ab##\", t = \"c#d#\"\nOutput: true\nExplanation: Both s and t become \"\".\n</code></pre>"},{"location":"source/Stack/844_Backspace_String_Compare/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"a#c\", t = \"b\"\nOutput: false\nExplanation: s becomes \"c\" while t becomes \"b\".\n</code></pre>"},{"location":"source/Stack/844_Backspace_String_Compare/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length, t.length &lt;= 200</code>.</li> <li><code>s</code> and <code>t</code> only contain lowercase letters and <code>'#'</code> characters.</li> </ul>"},{"location":"source/Stack/844_Backspace_String_Compare/#follow-up","title":"Follow up","text":"<ul> <li>Can you solve it in <code>O(n)</code> time and <code>O(1)</code> space?</li> </ul>"},{"location":"source/Stack/844_Backspace_String_Compare/#solution-build-and-clean-the-string-using-the-stacks-behaviors","title":"Solution: Build and clean the string using the <code>stack</code>'s behaviors","text":""},{"location":"source/Stack/844_Backspace_String_Compare/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nstring cleanString(const string &amp;s) {\n    vector&lt;char&gt; v;\n    for (int i = 0; i &lt; s.length(); i++) {\n        if (s[i] != '#') { \n            // s[i] is a normal letter\n            v.push_back(s[i]);\n        } else {\n            if (!v.empty()) {\n                // perform the backspace\n                v.pop_back();\n            }\n        }\n    }\n    // create a string from a vector of char\n    return string(v.begin(), v.end());\n}\nbool backspaceCompare(const string&amp; s, const string&amp; t) {\n    return cleanString(s) == cleanString(t);\n}\nint main() {\n    cout &lt;&lt; backspaceCompare(\"ab#c\", \"ad#c\") &lt;&lt; endl;\n    cout &lt;&lt; backspaceCompare(\"ab##\", \"c#d#\") &lt;&lt; endl;\n    cout &lt;&lt; backspaceCompare(\"a#c\", \"b\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n1\n0\n</code></pre> <p>This solution effectively handles backspace characters (<code>'#'</code>) in input strings <code>s</code> and <code>t</code> by constructing cleaned versions of the strings and then comparing the cleaned strings for equality.</p>"},{"location":"source/Stack/844_Backspace_String_Compare/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = max(s.length, t.length)</code>.</li> <li>Extra space: <code>O(n)</code>. </li> </ul>"},{"location":"source/Stack/844_Backspace_String_Compare/#implementation-notes","title":"Implementation notes","text":""},{"location":"source/Stack/844_Backspace_String_Compare/#why-vector-instead-of-stack","title":"Why <code>vector</code> instead of <code>stack</code>?","text":"<p>You can use the methods <code>push</code> and <code>pop</code> of the data structure <code>stack</code> to build and clean the strings. </p> <p>But <code>vector</code> has also such methods: <code>push_back</code> and <code>pop_back</code>.</p> <p>On the other hand, using <code>vector</code> it is easier to construct a <code>string</code> by constructor than using <code>stack</code> after cleaning.</p>"},{"location":"source/Stack/844_Backspace_String_Compare/#can-you-solve-it-in-on-time-and-o1-space","title":"Can you solve it in <code>O(n)</code> time and <code>O(1)</code> space?","text":"<p>Yes, you can. </p> <p>The simplest way is just to perform the erasure directly on strings <code>s</code> and <code>t</code>. But the run time complexity of <code>string::erase</code>  is not constant.</p>"},{"location":"source/Stack/844_Backspace_String_Compare/#exercise","title":"Exercise","text":"<ul> <li>Removing Stars From a String.</li> </ul>"},{"location":"source/String/165_Compare_Version_Numbers/","title":"Compare Version Numbers","text":""},{"location":"source/String/165_Compare_Version_Numbers/#problem-statement","title":"Problem statement","text":"<p>Given two version numbers, <code>version1</code> and <code>version2</code>, your task is to compare them.</p> <p>Version numbers consist of one or more revisions joined by a dot <code>'.'</code>. Each revision is composed of digits and may contain leading zeros. Each revision has at least one character. Revisions are indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on.</p> <p>For instance, <code>2.5.33</code> and <code>0.1</code> are valid version numbers.</p> <p>To compare version numbers, you should compare their revisions in left-to-right order. Revisions are compared using their integer value, ignoring any leading zeros. This means that revisions <code>1</code> and <code>001</code> are considered equal. If a version number does not specify a revision at a particular index, treat that revision as <code>0</code>. For example, version <code>1.0</code> is less than version <code>1.1</code> because their revision 0s are the same, but their revision 1s are <code>0</code> and <code>1</code> respectively, and <code>0</code> is less than <code>1</code>.</p> <p>The function should return the following:</p> <ul> <li>If <code>version1</code> is less than <code>version2</code>, return <code>-1</code>.</li> <li>If <code>version1</code> is greater than <code>version2</code>, return <code>1</code>.</li> <li>If <code>version1</code> and <code>version2</code> are equal, return <code>0</code>. </li> </ul>"},{"location":"source/String/165_Compare_Version_Numbers/#example-1","title":"Example 1","text":"<pre><code>Input: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\n</code></pre>"},{"location":"source/String/165_Compare_Version_Numbers/#example-2","title":"Example 2","text":"<pre><code>Input: version1 = \"1.0\", version2 = \"1.0.0\"\nOutput: 0\nExplanation: version1 does not specify revision 2, which means it is treated as \"0\".\n</code></pre>"},{"location":"source/String/165_Compare_Version_Numbers/#example-3","title":"Example 3","text":"<pre><code>Input: version1 = \"0.1\", version2 = \"1.1\"\nOutput: -1\nExplanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 &lt; 1, so version1 &lt; version2.\n</code></pre>"},{"location":"source/String/165_Compare_Version_Numbers/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= version1.length, version2.length &lt;= 500</code>.</li> <li><code>version1</code> and <code>version2</code> only contain digits and <code>'.'</code>.</li> <li><code>version1</code> and <code>version2</code> are valid version numbers.</li> <li>All the given revisions in <code>version1</code> and <code>version2</code> can be stored in a 32-bit integer.</li> </ul>"},{"location":"source/String/165_Compare_Version_Numbers/#solution","title":"Solution","text":"<p>Each version can be considered as an array of revisions.</p> <pre><code>version = revisions[0].revisions[1].revisions[2]....\n</code></pre> <p>The problem is to compare each <code>revisions[i]</code> between two versions.</p> <p>For example, <code>revisions[0]</code> of <code>version1</code> is less than of <code>version2</code> in Example 3. So the result is <code>-1</code>.</p> <p>All <code>revisions[i]</code> of <code>version1</code> and <code>version2</code> are equal in Example 1. So the result is <code>0</code>.</p> <p>The number of revisions between the versions might not be equal (like in Example 2). </p> <p>If all revisions of the shorter version are equal to the corresponding revisions of the longer one, the version having extra revisions and there exists a non-zero revision among them is the bigger one. Otherwise, the two versions are equal.</p>"},{"location":"source/String/165_Compare_Version_Numbers/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\n#include &lt;numeric&gt;\nusing namespace std;\n//! @return the vector of revisions of the version \n//! @example if version = \"1.02.11\", return {1,2,11}\nvector&lt;int&gt; toVector(const string&amp; version) {\n    vector&lt;int&gt; revisions;\n    string revision;\n    for (auto&amp; c : version) {\n        if (c != '.') {\n            // continue to build current revision \n            revision += c;\n        } else {\n            // current revision completes\n            // uses stoi() to ignore leading zeros\n            revisions.push_back(stoi(revision));\n\n            // start a new revision\n            revision = \"\";\n        }\n    }\n    revisions.push_back(stoi(revision));\n    return revisions;\n}\n\nint compareVersion(const string&amp; version1, const string&amp; version2) { \n    vector&lt;int&gt; r1 = toVector(version1);    \n    vector&lt;int&gt; r2 = toVector(version2);\n\n    int i = 0;\n    // perform the comparison on the revisions\n    while (i &lt; r1.size() &amp;&amp; i &lt; r2.size()) {\n        if (r1[i] &lt; r2[i]) {\n            return -1;\n        } else if (r1[i] &gt; r2[i]) {\n            return 1;\n        }\n        i++;\n    }\n    if (i == r1.size()) {\n        // if version1 is not longer than version2\n        // and version2 still has some valid revisions remain\n        if (accumulate(r2.begin() + i, r2.end(), 0) &gt; 0) {\n            return -1;\n        }\n    } else if (accumulate(r1.begin() + i, r1.end(), 0) &gt; 0) {\n        // if version2 is not longer than version1\n        // and version1 still has some valid revisions remain\n        return 1;\n    }\n    return 0;\n}\nint main() {\n    cout &lt;&lt; compareVersion(\"1.01\", \"1.001\") &lt;&lt; endl;\n    cout &lt;&lt; compareVersion(\"1.0\", \"1.0.0\") &lt;&lt; endl;\n    cout &lt;&lt; compareVersion(\"0.1\", \"1.1\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n0\n0\n-1\n</code></pre>"},{"location":"source/String/165_Compare_Version_Numbers/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code> where <code>N = max(version1.length, version2.length)</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/String/165_Compare_Version_Numbers/#conclusion","title":"Conclusion","text":"<p>This solution first converts the version strings into vectors of integers representing the individual components of the version numbers. This conversion is done by iterating through each character of the version string, accumulating digits until encountering a dot, at which point the accumulated integer is added to the revisions vector. </p> <p>Once both version strings are converted into vectors, the function iterates through the vectors, comparing corresponding elements to determine the relationship between the versions. Additionally, it accounts for any remaining digits in the longer version string after the common components by summing them up and comparing the totals. </p> <p>This approach simplifies the comparison process by breaking down the version strings into easily comparable components.</p>"},{"location":"source/String/165_Compare_Version_Numbers/#c-notes","title":"C++ Notes","text":"<ul> <li> <p><code>std::stoi</code> is used to convert a <code>string</code> to an <code>int</code>. It ignores the leading zeros for you.</p> </li> <li> <p><code>std::accumulate</code> is used to compute the sum of a container. </p> </li> </ul>"},{"location":"source/String/242_Valid_Anagram/","title":"Valid Anagram","text":""},{"location":"source/String/242_Valid_Anagram/#problem-statement","title":"Problem statement","text":"<p>You are given two strings, <code>s</code> and <code>t</code>. Your task is to determine whether <code>t</code> is an anagram of <code>s</code>. If <code>t</code> is an anagram of <code>s</code>, return <code>true</code>; otherwise, return <code>false</code>.</p> <p>An anagram is a term that describes a word or phrase formed by rearranging the letters of another word or phrase, typically using all the original letters exactly once. </p>"},{"location":"source/String/242_Valid_Anagram/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"anagram\", t = \"nagaram\"\nOutput: true\n</code></pre>"},{"location":"source/String/242_Valid_Anagram/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"rat\", t = \"car\"\nOutput: false\n</code></pre>"},{"location":"source/String/242_Valid_Anagram/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= s.length, t.length &lt;= 5 * 10^4</code>.</li> <li><code>s</code> and <code>t</code> consist of lowercase English letters.</li> </ul>"},{"location":"source/String/242_Valid_Anagram/#follow-up","title":"Follow up","text":"<ul> <li>What if the inputs contain Unicode characters? How would you adapt your solution to such a case?</li> </ul>"},{"location":"source/String/242_Valid_Anagram/#solution-1-rearrange-both-s-and-t-into-a-sorted-string","title":"Solution 1: Rearrange both <code>s</code> and <code>t</code> into a sorted string","text":""},{"location":"source/String/242_Valid_Anagram/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nbool isAnagram(string&amp; s, string&amp; t) {\n    // anagrams must have the same length\n    if (s.length() != t.length()) {\n        return false;\n    }\n    sort(s.begin(), s.end());\n    sort(t.begin(), t.end());\n    return s == t;\n}\nint main() {\n    cout &lt;&lt; isAnagram(\"anagram\", \"nagaram\") &lt;&lt; endl;\n    cout &lt;&lt; isAnagram(\"rat\", \"car\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n</code></pre> <p>This solution determines if two strings are anagrams by comparing their sorted versions. If the sorted versions are equal, the original strings are anagrams, and the function returns <code>true</code>. Otherwise, it returns <code>false</code>. </p>"},{"location":"source/String/242_Valid_Anagram/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(NlogN)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/String/242_Valid_Anagram/#solution-2-count-the-appearances-of-each-letter","title":"Solution 2: Count the appearances of each letter","text":""},{"location":"source/String/242_Valid_Anagram/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nbool isAnagram(const string&amp; s, const string&amp; t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    // s and t consist of only lowercase English letters\n    // you can encode 0: 'a', 1: 'b', .., 25: 'z'.\n    int alphabet[26];\n    for (int i = 0; i &lt; 26; i++) {\n        alphabet[i] = 0;\n    }\n    // count the frequency of each letter in s\n    for (auto&amp; c : s) {\n        alphabet[c - 'a']++;\n    }\n    for (auto&amp; c : t) {\n        alphabet[c - 'a']--;\n        // if s and t have the same length but are not anagrams,\n        // there must be some letter in t having higher frequency than s \n        if (alphabet[c - 'a'] &lt; 0) {\n            return false;\n        }\n    }\n    return true;    \n}\nint main() {\n    cout &lt;&lt; isAnagram(\"anagram\", \"nagaram\") &lt;&lt; endl;\n    cout &lt;&lt; isAnagram(\"rat\", \"car\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n</code></pre> <p>This solution efficiently determines if two strings are anagrams by counting the frequency of each character in both strings using an array. If the character frequencies match for both strings, they are anagrams. </p>"},{"location":"source/String/242_Valid_Anagram/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/String/242_Valid_Anagram/#solution-3-if-the-inputs-contain-unicode-characters","title":"Solution 3: If the inputs contain Unicode characters","text":"<p>Replace the array <code>alphabet</code> in Solution 2 with a map.</p>"},{"location":"source/String/242_Valid_Anagram/#code_2","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nbool isAnagram(const string&amp; s, const string&amp; t) {\n    if (s.length() != t.length()) {\n        return false;\n    }\n    // this alphabet can store all UTF-8 characters\n    unordered_map&lt;char, int&gt; alphabet;\n    for (auto&amp; c : s) {\n        alphabet[c]++;\n    }\n    for (auto&amp; c : t) {\n        alphabet[c]--;\n        if (alphabet[c] &lt; 0) {\n            return false;\n        }\n    }\n    return true;    \n}\nint main() {\n    cout &lt;&lt; isAnagram(\"anagram\", \"nagaram\") &lt;&lt; endl;\n    cout &lt;&lt; isAnagram(\"rat\", \"car\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n</code></pre>"},{"location":"source/String/242_Valid_Anagram/#complexity_2","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(c)</code> where <code>c</code> represents the number of unique characters present in both strings <code>s</code> and <code>t</code>.</li> </ul>"},{"location":"source/String/242_Valid_Anagram/#key-takeaway","title":"Key Takeaway","text":"<p>Instead of relying on a fixed-size array like the ASCII-based solutions, Solution 3 uses an <code>unordered_map</code> to store character frequencies. Each character is used as a key in the map, and the count of occurrences is stored as the associated value.</p> <p>Unicode characters values are not restricted to a specific range. The <code>unordered_map</code> approach accommodates this variability by allowing any character to be a key.</p>"},{"location":"source/String/242_Valid_Anagram/#exercise","title":"Exercise","text":"<ul> <li>Find Resultant Array After Removing Anagrams.</li> </ul>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/","title":"Longest Substring Without Repeating Characters","text":""},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#problem-statement","title":"Problem statement","text":"<p>Given a string <code>s</code>, your task is to determine the length of the longest substring within <code>s</code> that does not contain any repeating characters.</p>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#example-1","title":"Example 1","text":"<pre><code>Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with a length of 3.\n</code></pre>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#example-2","title":"Example 2","text":"<pre><code>Input: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n</code></pre>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#example-3","title":"Example 3","text":"<pre><code>Input: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with a length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n</code></pre>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#constraints","title":"Constraints","text":"<ul> <li><code>0 &lt;= s.length &lt;= 5 * 10^4</code>.</li> <li><code>s</code> consists of English letters, digits, symbols and spaces.</li> </ul>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#solution-store-the-position-of-the-visited-characters","title":"Solution: Store the position of the visited characters","text":"<p>Whenever you meet a visited character <code>s[i] == s[j]</code> for some <code>0 &lt;= i &lt; j &lt; s.length</code>, the substring <code>\"s[i]...s[j - 1]\"</code> might be valid, i.e., it consists of only nonrepeating characters.</p> <p>But in case you meet another visited character <code>s[x] == s[y]</code> where <code>x &lt; i &lt; j &lt; y</code>, the substring <code>\"s[x]...s[y - 1]\"</code> is not valid because it consists of repeated character <code>s[i] == s[j]</code>. </p> <p>That shows the substring <code>\"s[i]...s[j - 1]\"</code> is not always a valid one. You might need to find the right starting position <code>start &gt;= i</code> for the valid substring <code>\"s[start]...s[j - 1]\"</code>.</p>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#example-4","title":"Example 4","text":"<p>For the string <code>s = \"babba\"</code>:</p> <ul> <li>When you visit the second letter <code>'b'</code>, the substring <code>\"ba\"</code> is a valid one. </li> <li>When you visit the third letter <code>'b'</code>, the substring of interest should be started by the second letter <code>'b'</code>. It gives you the substring <code>\"b\"</code>.</li> <li>When you visit the second letter <code>'a'</code>, the substring <code>\"abb\"</code> is not a valid one since <code>'b'</code> is repeated. To ensure no repetition, the starting position for this substring should be the latter <code>'b'</code>, which leads to the valid substring <code>\"b\"</code>.</li> <li>The final longest valid substring is <code>\"ba\"</code> with length 2.</li> </ul> <p>Example 4 shows the starting position <code>start</code> for the substring of interest <code>\"s[i]...s[j - 1]\"</code> should be:</p> <pre><code>this_start = max(previous_start, i).\n</code></pre>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\nusing namespace std;\nint lengthOfLongestSubstring(const string&amp; s) {\n    // keep track latest index of a character in s\n    unordered_map&lt;char, int&gt; position;\n\n    // posible maximum length of the longest substring\n    int maxLen = 0;\n\n    // starting index of current substring\n    int start = -1; \n    for (int i = 0; i &lt; s.length(); i++) {\n        auto it = position.find(s.at(i));\n        // found this s[i] has appeared in the map\n        if (it != position.end()) {\n            // start a new substring from this index i\n            start = max(start, it-&gt;second);\n\n            // update latest found position of character s[i] to be i\n            it-&gt;second = i;\n        } else {\n\n            // keep track index of s[i] in the map\n            position.insert({s.at(i), i});\n        }\n        // update the maximum length\n        maxLen = max(maxLen, i - start);\n    }\n    return maxLen;\n}\nint main() {\n    cout &lt;&lt; lengthOfLongestSubstring(\"abcabcbb\") &lt;&lt; endl;\n    cout &lt;&lt; lengthOfLongestSubstring(\"bbbbb\") &lt;&lt; endl;\n    cout &lt;&lt; lengthOfLongestSubstring(\"pwwkew\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n3\n1\n3\n</code></pre>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = s.length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#conclusion","title":"Conclusion","text":"<p>This solution utilizes a {index}<code>sliding window</code> approach to track the starting index of the current substring and an unordered map to store the position of the characters encountered so far. By updating the starting index when a repeating character is encountered, it ensures that the current substring contains only unique characters. </p> <p>This approach optimizes the computation of the length of the longest substring by handling the sliding window and updating the length accordingly, resulting in an overall efficient solution.</p>"},{"location":"source/String/3_Longest_Substring_Without_Repeating_Characters/#exercise","title":"Exercise","text":"<ul> <li>Optimal Partition of String.</li> </ul>"},{"location":"source/String/520_Detect_Capital/","title":"Detect Capital","text":""},{"location":"source/String/520_Detect_Capital/#problem-statement","title":"Problem statement","text":"<p>The task is to determine if the usage of capital letters in a given string, <code>word</code>, is correct according to the following rules:</p> <ol> <li>All letters in the word are capital, like \"USA\".</li> <li>All letters in the word are not capital, like \"leetcode\".</li> <li>Only the first letter in the word is capital, like \"Google\".</li> </ol> <p>If the capitalization in the given word adheres to these rules, the function should return <code>true</code>; otherwise, it should return <code>false</code>. </p>"},{"location":"source/String/520_Detect_Capital/#example-1","title":"Example 1","text":"<pre><code>Input: word = \"USA\"\nOutput: true\n</code></pre>"},{"location":"source/String/520_Detect_Capital/#example-2","title":"Example 2","text":"<pre><code>Input: word = \"FlaG\"\nOutput: false\n</code></pre>"},{"location":"source/String/520_Detect_Capital/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= word.length &lt;= 100</code>,</li> <li><code>word</code> consists of lowercase and uppercase English letters.</li> </ul>"},{"location":"source/String/520_Detect_Capital/#solution","title":"Solution","text":"<p>Only when the first two characters of the <code>word</code> are uppercase, the rest must be the same. Otherwise, the rest is always lowercase.</p>"},{"location":"source/String/520_Detect_Capital/#code","title":"Code","text":"<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n//! @return true if (c is lowercase and isLower is true) \n//!                 or (c is uppercase and isLower is false).\n//!         false, otherwise. \nbool isValidCase(const char&amp; c, const bool isLower) {\n    if (isLower) {\n        return 'a' &lt;= c &amp;&amp; c &lt;= 'z';\n    }\n    return 'A' &lt;= c &amp;&amp; c &lt;= 'Z';\n}\nbool detectCapitalUse(const string&amp; word) {\n    if (word.length() == 1) {\n        return true;\n    }\n    bool isLower = true;\n\n    // if the first two characters are uppercase,\n    // the rest must be uppercase, too.\n    if (isValidCase(word[0], false) &amp;&amp; isValidCase(word[1], false)) {\n        isLower = false;\n    }\n    for (int i = 1; i &lt; word.length(); i++) {\n        if (!isValidCase(word[i], isLower)) {\n            return false;\n        }\n    }\n    return true;\n}\nint main() {\n    cout &lt;&lt; detectCapitalUse(\"USA\") &lt;&lt; endl;\n    cout &lt;&lt; detectCapitalUse(\"FlaG\") &lt;&lt; endl;\n    cout &lt;&lt; detectCapitalUse(\"leetcode\") &lt;&lt; endl;\n    cout &lt;&lt; detectCapitalUse(\"Google\") &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n1\n0\n1\n1\n</code></pre>"},{"location":"source/String/520_Detect_Capital/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = word.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/String/520_Detect_Capital/#conclusion","title":"Conclusion","text":"<p>This solution efficiently checks whether a given word follows one of the specified capitalization rules by iterating through the characters of the word and using the <code>isValidCase</code> function to validate each character's capitalization based on the current capitalization type (<code>isLower</code>). If no violations are found, the word is considered valid, and the function returns <code>true</code>. </p>"},{"location":"source/String/520_Detect_Capital/#exercise","title":"Exercise","text":"<ul> <li>Capitalize the Title.</li> </ul>"},{"location":"source/String/804_Unique_Morse_Code_Words/","title":"Unique Morse Code Words","text":""},{"location":"source/String/804_Unique_Morse_Code_Words/#problem-statement","title":"Problem statement","text":"<p>The problem involves the International Morse Code, which defines a standard way to encode letters with dots and dashes. Each English letter corresponds to a specific sequence in Morse Code, and a full table mapping each letter is provided.</p> <p>For instance, <code>'a'</code> is encoded as <code>\".-\"</code>, <code>'b'</code> as <code>\"-...\"</code>, and so on.</p> <p>The full table for the <code>26</code> letters of the English alphabet is given below:</p> <pre><code>[\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n\"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n\"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n\"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n</code></pre> <p>You are given an array of strings named <code>words</code>, where each word can be represented as a concatenation of the Morse code for each of its letters. For example, the word <code>\"cab\"</code> can be represented as <code>\"-.-..--...\"</code>, which is the concatenation of <code>\"-.-.\"</code>, <code>\".-\"</code>, and <code>\"-...\"</code>. This concatenated Morse code representation is referred to as the \"transformation\" of a word.</p> <p>Your task is to count the number of different transformations that can be obtained from all the words in the given array.</p>"},{"location":"source/String/804_Unique_Morse_Code_Words/#example-1","title":"Example 1","text":"<pre><code>Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\nOutput: 2\nExplanation: The transformation of each word is:\n\"gin\" -&gt; \"--...-.\"\n\"zen\" -&gt; \"--...-.\"\n\"gig\" -&gt; \"--...--.\"\n\"msg\" -&gt; \"--...--.\"\nThere are 2 different transformations: \"--...-.\" and \"--...--.\".\n</code></pre>"},{"location":"source/String/804_Unique_Morse_Code_Words/#example-2","title":"Example 2","text":"<pre><code>Input: words = [\"a\"]\nOutput: 1\n</code></pre>"},{"location":"source/String/804_Unique_Morse_Code_Words/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= words.length &lt;= 100</code>.</li> <li><code>1 &lt;= words[i].length &lt;= 12</code>.</li> <li><code>words[i]</code> consists of lowercase English letters.</li> </ul>"},{"location":"source/String/804_Unique_Morse_Code_Words/#solution-store-the-transformations-in-a-set","title":"Solution: Store the transformations in a set","text":""},{"location":"source/String/804_Unique_Morse_Code_Words/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\nconst vector&lt;string&gt; morse{\n    \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\",\n    \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\",\n    \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\",\n    \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n};\n\nint uniqueMorseRepresentations(const vector&lt;string&gt;&amp; words) {\n    unordered_set&lt;string&gt; transformations;\n    for (auto&amp; w : words) {\n        string s{\"\"};\n        for (auto&amp; c : w) {\n            // concatnate the letter c's Morse code\n            s += morse[c - 'a'];\n        }\n        // only insert the transformation s to the set \n        // if the set did not consist s yet.\n        transformations.insert(s);\n    }\n    return transformations.size();\n}\nint main() {\n    vector&lt;string&gt; words{\"gin\",\"zen\",\"gig\",\"msg\"};\n    cout &lt;&lt; uniqueMorseRepresentations(words) &lt;&lt; endl;\n    words = {\"a\"};\n    cout &lt;&lt; uniqueMorseRepresentations(words) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n1\n</code></pre>"},{"location":"source/String/804_Unique_Morse_Code_Words/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*M)</code>, where <code>N = words.length</code> and <code>M = words[i].length</code>.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/String/804_Unique_Morse_Code_Words/#conclusion","title":"Conclusion","text":"<p>This solution converts each word into Morse code based on a predefined mapping and uses an unordered set to keep track of unique representations. By inserting each representation into the set, it automatically filters out duplicates. The final result is the size of the set, which represents the number of unique Morse code representations among the input words. </p>"},{"location":"source/String/929_Unique_Email_Addresses/","title":"Unique Email Addresses","text":""},{"location":"source/String/929_Unique_Email_Addresses/#problem-statement","title":"Problem statement","text":"<p>Each valid email address is composed of a local name and a domain name, separated by the <code>'@'</code> sign. The local name may contain lowercase letters, one or more <code>'.'</code> characters, and a plus <code>'+'</code> sign. However, the rules for dots and the plus sign do not apply to the domain name.</p> <p>For example, in the email <code>\"alice@leetcode.com\"</code>, <code>\"alice\"</code> is the local name, and <code>\"leetcode.com\"</code> is the domain name.</p> <p>If you insert periods <code>'.'</code> between certain characters in the local name, the email will still be forwarded to the same address without the dots in the local name. This rule does not apply to the domain name.</p> <p>For example, <code>\"alice.z@leetcode.com\"</code> and <code>\"alicez@leetcode.com\"</code> both forward to the same email address.</p> <p>If you include a plus <code>'+'</code> sign in the local name, everything after the first plus sign is ignored, allowing for email filtering. This rule also does not apply to the domain name.</p> <p>For example, <code>\"m.y+name@email.com\"</code> will be forwarded to <code>\"my@email.com\"</code>.</p> <p>It is possible to use both of these rules at the same time.</p> <p>Given an array of strings <code>emails</code>, where each element is an email address to which an email is sent, your task is to determine the number of different addresses that will actually receive the emails after applying the rules described above.</p>"},{"location":"source/String/929_Unique_Email_Addresses/#example-1","title":"Example 1","text":"<pre><code>Input: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]\nOutput: 2\nExplanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails.\n</code></pre>"},{"location":"source/String/929_Unique_Email_Addresses/#example-2","title":"Example 2","text":"<pre><code>Input: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\nOutput: 3\n</code></pre>"},{"location":"source/String/929_Unique_Email_Addresses/#constraints","title":"Constraints","text":"<ul> <li><code>1 &lt;= emails.length &lt;= 100</code>.</li> <li><code>1 &lt;= emails[i].length &lt;= 100</code>.</li> <li><code>emails[i]</code> consist of lowercase English letters, <code>'+'</code>, <code>'.'</code> and <code>'@'</code>.</li> <li>Each <code>emails[i]</code> contains exactly one <code>'@'</code> character.</li> <li>All local and domain names are non-empty.</li> <li>Local names do not start with a <code>'+'</code> character.</li> <li>Domain names end with the <code>\".com\"</code> suffix.</li> </ul>"},{"location":"source/String/929_Unique_Email_Addresses/#solution-1-removing-the-ignored-characters","title":"Solution 1: Removing the ignored characters","text":"<p>Do exactly the steps the problem describes:</p> <ol> <li>Extract the local name.</li> <li>Ignore all characters after <code>'+'</code> in it.</li> <li>Ignore all <code>'.'</code> in it.</li> <li>Combine the local name with the domain one to form the clean email address.</li> </ol>"},{"location":"source/String/929_Unique_Email_Addresses/#code","title":"Code","text":"<pre><code>#include&lt;string&gt;\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\nint numUniqueEmails(const vector&lt;string&gt;&amp; emails) {\n    unordered_set&lt;string&gt; s;\n    for (auto&amp; e: emails) {\n        auto apos = e.find('@');\n\n        // extract the local name\n        string local = e.substr(0, apos);\n\n        // ignore all characters after '+'\n        local = local.substr(0, local.find('+'));   \n        auto it = local.find('.');\n        while (it != string::npos) {\n            // remove each '.' found in local\n            local.erase(it, 1);\n            it = local.find('.');\n        }\n        // combine local name with domain one\n        s.insert(local + e.substr(apos));\n    }\n    return s.size();\n}\nint main() {\n    vector&lt;string&gt; emails{\"test.email+alex@leetcode.com\",\n                        \"test.e.mail+bob.cathy@leetcode.com\",\n                        \"testemail+david@lee.tcode.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n    emails = {\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n    emails = {\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n3\n2\n</code></pre> <p>This solution parses a list of email addresses, normalizes each email address by removing periods and ignoring characters after the plus sign in the local name, and then counts the number of unique email addresses. The use of an unordered set ensures that only unique email addresses are counted.</p>"},{"location":"source/String/929_Unique_Email_Addresses/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*M^2)</code>, where <code>N = emails.length</code> and <code>M = max(emails[i].length)</code>. Explanation: you loop over <code>N</code> emails. Then you might loop over the length of each email, <code>O(M)</code>, to remove the character <code>'.'</code>. The removal might cost <code>O(M)</code>.</li> <li>Extra space: <code>O(N*M)</code> (the set of emails).</li> </ul>"},{"location":"source/String/929_Unique_Email_Addresses/#solution-2-building-the-clean-email-addresses-from-scratch","title":"Solution 2: Building the clean email addresses from scratch","text":"<p>The runtime of removing characters in <code>std::string</code> is not constant. To avoid that complexity you can build up the clean email addresses from scratch.</p>"},{"location":"source/String/929_Unique_Email_Addresses/#code_1","title":"Code","text":"<pre><code>#include&lt;string&gt;\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include &lt;unordered_set&gt;\nusing namespace std;\nint numUniqueEmails(const vector&lt;string&gt;&amp; emails) {\n    unordered_set&lt;string&gt; s;\n    for (auto&amp; e: emails) {\n        string address; \n        int i = 0;\n        // the local name ends here\n        while (e[i] != '@' &amp;&amp; e[i] != '+') {\n            // ignore each '.' found\n            if (e[i++] == '.') {\n                continue;\n            }\n            // add valid characters to local name\n            address += e[i++];                  \n        }\n        // combine local name with domain one\n        address += e.substr(e.find('@', i));    \n        s.insert(address);\n    }        \n    return s.size();\n}\nint main() {\n    vector&lt;string&gt; emails{\"test.email+alex@leetcode.com\",\n                        \"test.e.mail+bob.cathy@leetcode.com\",\n                        \"testemail+david@lee.tcode.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n    emails = {\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n    emails = {\"test.email+alex@leetcode.com\",\"test.email.leet+alex@code.com\"};\n    cout &lt;&lt; numUniqueEmails(emails) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n2\n3\n2\n</code></pre>"},{"location":"source/String/929_Unique_Email_Addresses/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*M)</code>, where <code>N = emails.length</code> and <code>M = max(emails[i].length)</code>.</li> <li>Extra space: <code>O(N*M)</code>.</li> </ul>"},{"location":"source/String/929_Unique_Email_Addresses/#c-notes","title":"C++ Notes","text":"<ul> <li>A <code>string</code> can be concatenated with a <code>char</code> and another <code>string</code> by <code>+</code> operator.</li> </ul> <pre><code>std::string address = \"name\";\naddress += '@';             // \"name@\"\naddress += \"domain.com\";    // \"name@domain.com\"\n</code></pre> <ul> <li><code>string::substr(pos = 0, count = npos)</code> returns the substring of length <code>count</code> starting from the position <code>pos</code> of the string <code>string</code>.</li> </ul> <pre><code>std::string address = \"name@domain.com\";\ncout &lt;&lt; address.substr(address.find('.'));      // \".com\"\ncout &lt;&lt; address.substr(0, address.find('@'));   // \"name\"\n</code></pre> <ul> <li><code>string::find(char, pos=0)</code> returns the position of the first <code>char</code> which appears in the string <code>string</code> starting from <code>pos</code>.</li> </ul>"},{"location":"source/String/929_Unique_Email_Addresses/#high-performance-c","title":"High-performance C++","text":"<ul> <li> <p>Do not use <code>std::set</code> or <code>std::map</code> unless you want the keys to be in order (sorted). Use unordered containers like <code>std::unordered_set</code> or <code>std::unordered_map</code> instead. They use hashed keys for faster lookup.</p> </li> <li> <p>Do not blindly/lazily use <code>string.find(something)</code>. If you know where to start the search, use <code>string.find(something, pos)</code> with a specific <code>pos</code>.</p> </li> </ul>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/","title":"Container With Most Water","text":"<p>% Medium</p>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#problem-statement","title":"Problem statement","text":"<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i-th</code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return the maximum amount of water a container can store.</p> <p>Notice that you may not slant the container.</p>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#example-1","title":"Example 1","text":"<pre><code>Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue/grey section) the container can contain is 49.\n</code></pre>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#example-2","title":"Example 2","text":"<pre><code>Input: height = [1,1]\nOutput: 1\n</code></pre>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#constraints","title":"Constraints","text":"<ul> <li><code>n == height.length</code>.</li> <li><code>2 &lt;= n &lt;= 10^5</code>.</li> <li><code>0 &lt;= height[i] &lt;= 10^4</code>.</li> </ul>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#solution-1-bruteforce","title":"Solution 1: Bruteforce","text":"<p>For each line <code>i</code>, find the line <code>j &gt; i</code> such that it gives the maximum amount of water the container <code>(i, j)</code> can store.</p>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint maxArea(const vector&lt;int&gt;&amp; height) {\n    int maxA = 0;\n    for (int i = 0; i &lt; height.size() - 1; i++) {\n        for (int j = i + 1; j &lt; height.size(); j++) {\n            maxA = max(maxA, min(height[i], height[j]) * (j - i));\n        }\n    }\n    return maxA;\n}\nint main() {\n    vector&lt;int&gt; height{1,8,6,2,5,4,8,3,7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;\n    height = {1,1};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n49\n1\n</code></pre> <p>This solution computes the maximum area of water that can be trapped between two vertical lines by iterating through all possible pairs of lines.  By considering all combinations of lines and calculating the area using the formula <code>(min(height[i], height[j]) * (j - i))</code>, where <code>height[i]</code> and <code>height[j]</code> represent the heights of the two lines and <code>(j - i)</code> represents the width between them, it effectively evaluates the area formed by each pair and updates <code>maxA</code> with the maximum area encountered. </p> <p>This approach optimizes the computation by exhaustively considering all possible pairs of lines and efficiently computing the area without requiring additional space.</p>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n^2)</code>, where <code>n = height.length</code>. This is because it checks all possible pairs of vertical lines, resulting in a quadratic time complexity.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#solution-2-two-pointers","title":"Solution 2: Two pointers","text":"<p>Any container has left line <code>i</code> and right line <code>j</code> satisfying <code>0 &lt;= i &lt; j &lt; height.length</code>. The biggest container you want to find satisfies that condition too.</p> <p>You can start from the broadest container with the left line <code>i = 0</code> and the right line <code>j = height.length - 1</code>. Then by moving <code>i</code> forward and <code>j</code> backward, you can narrow down the container to find which one will give the maximum amount of water it can store.</p> <p>Depending on which line is higher, you can decide which one to move next. Since you want a bigger container, you should move the shorter line.</p>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#example-1_1","title":"Example 1","text":"<p>For <code>height = [1,8,6,2,5,4,8,3,7]</code>: - Starting with <code>i = 0</code> and <code>j = 8</code>.</p> <pre><code>```text\narea = min(height[i], height[j]) * (j - i) = min(1, 7) * (8 - 0) = 8.\nmaxArea = 8.\n```\n</code></pre> <ul> <li> <p><code>height[i] = 1 &lt; 7 = height[j]</code>, move <code>i</code> to <code>1</code>.</p> <p><code>text area = min(8, 7) * (8 - 1) = 49. maxArea = 49.</code> - <code>height[i] = 8 &gt; 7 = height[j]</code>, move <code>j</code> to <code>7</code>.</p> <p><code>text area = min(8, 3) * (7 - 1) = 18. maxArea = 49.</code> - So on and so on. Final <code>maxArea = 49</code>.</p> </li> </ul>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\nint maxArea(const vector&lt;int&gt;&amp; height) {\n    int maxA = 0;\n    int i = 0;\n    int j = height.size() - 1;\n    while (i &lt; j) {\n        if (height[i] &lt; height[j]) {\n            maxA = max(maxA, height[i] * (j - i) );\n            i++;\n        } else {\n            maxA = max(maxA, height[j] * (j - i) );\n            j--;\n        }\n    }\n    return maxA;\n}\nint main() {\n    vector&lt;int&gt; height{1,8,6,2,5,4,8,3,7};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;\n    height = {1,1};\n    cout &lt;&lt; maxArea(height) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n49\n1\n</code></pre>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(n)</code>, where <code>n = height.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/11_Container_With_Most_Water/#conclusion","title":"Conclusion","text":"<p>Solution 2 is the two-pointer approach. By initializing two pointers <code>i</code> and <code>j</code> at the beginning and end of the array respectively, and iteratively moving them towards each other until they converge, it evaluates all possible pairs of lines. At each step, it calculates the area. By moving the pointer corresponding to the shorter line inward at each step, it ensures that the maximum possible area is considered. </p> <p>This approach optimizes the computation by avoiding redundant calculations and efficiently exploring the solution space using two pointers.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/","title":"Linked List Cycle","text":""},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#problem-statement","title":"Problem statement","text":"<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p> <p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#example-1","title":"Example 1","text":"<pre><code>Input: head = [3,2,0,-4], where -4 links next to 2.\nOutput: true\n</code></pre>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#example-2","title":"Example 2","text":"<pre><code>Input: head = [1,2], where 2 links next to 1.\nOutput: true\n</code></pre>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#example-3","title":"Example 3","text":"<pre><code>Input: head = [1], and 1 links to NULL.\nOutput: false\nExplanation: There is no cycle in this linked list.\n</code></pre>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#constraints","title":"Constraints","text":"<ul> <li>The number of the nodes in the list is in the range <code>[0, 10^4]</code>.</li> <li><code>-10^5 &lt;= Node.val &lt;= 10^5</code>.</li> </ul>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#follow-up","title":"Follow up","text":"<ul> <li>Can you solve it using <code>O(1)</code> (i.e. constant) memory?</li> </ul>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#solution-1-storing-the-visited-nodes","title":"Solution 1: Storing the visited nodes","text":""},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#code","title":"Code","text":"<pre><code>#include &lt;unordered_map&gt;\n#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\nbool hasCycle(ListNode *head) {\n    std::unordered_map&lt;ListNode*, bool&gt; m;\n    while (head) {\n        if (m[head]) {\n            // found this node marked in the map\n            return true;\n        }\n        m[head] = true; // mark this node visited\n        head = head-&gt;next;\n    }\n    return false;\n}\nint main() {\n    {\n        ListNode three(3);\n        ListNode two(2);\n        three.next = &amp;two;\n        ListNode zero(0);\n        two.next = &amp;zero;\n        ListNode four(4);\n        zero.next = &amp;four;\n        four.next = &amp;two;\n        std::cout &lt;&lt; hasCycle(&amp;three) &lt;&lt; std::endl;\n    }\n    {\n        ListNode one(1);\n        ListNode two(2);\n        one.next = &amp;two;\n        two.next = &amp;one;\n        std::cout &lt;&lt; hasCycle(&amp;one) &lt;&lt; std::endl;\n    }\n    {\n        ListNode one(1);\n        std::cout &lt;&lt; hasCycle(&amp;one) &lt;&lt; std::endl;\n    }\n}\n</code></pre> <pre><code>Output:\n1\n1\n0\n</code></pre> <p>This solution uses a hash map to track visited nodes while traversing the linked list. </p> <p>By iterating through the linked list and marking pointers to visited nodes in the hash map, it detects cycles in the linked list. If a node is found marked <code>true</code> in the map, it indicates the presence of a cycle, and the function returns <code>true</code>. Otherwise, if the end of the linked list is reached without finding any node marked, it confirms the absence of a cycle, and the function returns <code>false</code>. </p> <p>This approach optimizes the computation by leveraging the hash map to efficiently detect cycles in the linked list without requiring additional space proportional to the length of the list.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the length of the linked list.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#solution-2-indexfast-and-slow-runners","title":"Solution 2: {index}<code>Fast and Slow</code> runners","text":"<p>Imagine there are two runners both start to run along the linked list from the <code>head</code>. One runs twice faster than the other. </p> <p>If the linked list has a cycle in it, they will meet at some point. Otherwise, they never meet each other.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#example-1_1","title":"Example 1","text":"<p>The slower runs <code>[3,2,0,-4,2,0,...]</code> while the faster runs <code>[3,0,2,-4,0,2,...]</code>. They meet each other at node <code>-4</code> after three steps.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#example-2_1","title":"Example 2","text":"<p>The slower runs <code>[1,2,1,2,...]</code> while the faster runs <code>[1,1,1,...]</code>. They meet each other at node <code>1</code> after two steps.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\nbool hasCycle(ListNode *head) {\n    if (head == nullptr) {\n        return false;\n    }\n    ListNode* fast = head;\n    ListNode* slow = head;    \n    while (fast &amp;&amp; fast-&gt;next) {\n        fast = fast-&gt;next-&gt;next;\n        slow = slow-&gt;next;\n        if (fast == slow) {\n            return true;\n        }\n    }\n    return false;\n}\nint main() {\n    {\n        ListNode three(3);\n        ListNode two(2);\n        three.next = &amp;two;\n        ListNode zero(0);\n        two.next = &amp;zero;\n        ListNode four(4);\n        zero.next = &amp;four;\n        four.next = &amp;two;\n        std::cout &lt;&lt; hasCycle(&amp;three) &lt;&lt; std::endl;\n    }\n    {\n        ListNode one(1);\n        ListNode two(2);\n        one.next = &amp;two;\n        two.next = &amp;one;\n        std::cout &lt;&lt; hasCycle(&amp;one) &lt;&lt; std::endl;\n    }\n    {\n        ListNode one(1);\n        std::cout &lt;&lt; hasCycle(&amp;one) &lt;&lt; std::endl;\n    }\n}\n</code></pre> <pre><code>Output:\n1\n1\n0\n</code></pre>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes in the linked list.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#conclusion","title":"Conclusion","text":"<p>Solution 2 uses two pointers, a fast pointer and a slow pointer, to detect cycles in a linked list. </p> <p>Both pointers start from the head of the list, and the fast pointer moves two steps forward while the slow pointer moves one step forward in each iteration. By comparing the positions of the fast and slow pointers, the algorithm detects cycles in the linked list. </p> <p>If the fast pointer catches up with the slow pointer at any point during traversal, it indicates the presence of a cycle, and the function returns <code>true</code>. Otherwise, if the fast pointer reaches the end of the list without intersecting with the slow pointer, it confirms the absence of a cycle, and the function returns <code>false</code>. </p> <p>This approach optimizes the computation by simultaneously advancing two pointers at different speeds to efficiently detect cycles in the linked list.</p>"},{"location":"source/Two_Pointers/141_Linked_List_Cycle/#exercise","title":"Exercise","text":"<ul> <li>Linked List Cycle II.</li> </ul>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/","title":"Remove Nth Node From End of List","text":""},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#problem-statement","title":"Problem statement","text":"<p>Given the <code>head</code> of a linked list, remove the <code>n-th</code> node from the end of the list and return its head.</p>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#example-1","title":"Example 1","text":"<pre><code>Input: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n</code></pre>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#example-2","title":"Example 2","text":"<pre><code>Input: head = [1], n = 1\nOutput: []\n</code></pre>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#example-3","title":"Example 3","text":"<pre><code>Input: head = [1,2], n = 1\nOutput: [1]\n</code></pre>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the list is <code>sz</code>.</li> <li><code>1 &lt;= sz &lt;= 30</code>.</li> <li><code>0 &lt;= Node.val &lt;= 100</code>.</li> <li><code>1 &lt;= n &lt;= sz</code>.</li> </ul>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#follow-up","title":"Follow up","text":"<ul> <li>Could you do this in one pass?</li> </ul>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#solution-1-store-the-nodes","title":"Solution 1: Store the nodes","text":""},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nusing namespace std;\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    vector&lt;ListNode*&gt; nodes;\n    ListNode* node = head;\n    while (node)\n    {\n        nodes.push_back(node);\n        node = node-&gt;next;\n    }    \n    node = nodes[nodes.size() - n];\n\n    if (node == head) {\n        // remove head if n == nodes.size()\n        head = node-&gt;next;\n    } else {\n        ListNode* pre = nodes[nodes.size() - n - 1];\n        pre-&gt;next = node-&gt;next;\n    }\n    return head;\n}\nvoid printList(const ListNode *head) {\n    ListNode* node = head;\n    cout &lt;&lt; \"[\";\n    while (node) {\n        cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode five(5);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);\n    ListNode two(2, &amp;three);\n    ListNode one(1, &amp;two);\n    auto head = removeNthFromEnd(&amp;one, 2);\n    printList(head);\n    head = removeNthFromEnd(&amp;five, 1);\n    printList(head);\n    head = removeNthFromEnd(&amp;four, 1);\n    printList(head);\n}\n</code></pre> <pre><code>Output:\n[1,2,3,5,]\n[]\n[4,]\n</code></pre> <p>This solution uses a vector to store pointers to all nodes in the linked list, enabling easy access to the node to be removed and its predecessor. </p> <p>By iterating through the linked list and storing pointers to each node in the vector, it constructs a representation of the linked list in an array-like structure. Then, it retrieves the node to be removed using its index from the end of the vector. Finally, it handles the removal of the node by updating the <code>next</code> pointer of its predecessor or updating the <code>head</code> pointer if the node to be removed is the head of the linked list. </p> <p>This approach optimizes the computation by sacrificing space efficiency for simplicity of implementation and ease of manipulation of linked list elements.</p>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes in the list.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#solution-2-two-pointers","title":"Solution 2: Two pointers","text":"<p>The distance between the removed node and the end (<code>nullptr</code>) of the list is always <code>n</code>.</p> <p>You can apply the two-pointer technique as follows.</p> <p>Let the slower runner start after the faster one <code>n</code> nodes. Then when the faster reaches the end of the list, the slower reaches the node to be removed.</p>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nusing namespace std;\nListNode* removeNthFromEnd(ListNode* head, int n) {\n    ListNode* fast = head;\n    // let fast goes ahead n nodes \n    for (int i = 0; i &lt; n; i++) {\n        fast = fast-&gt;next;\n    }\n    if (fast == nullptr) {\n        // remove head if n equals the list's length\n        return head-&gt;next;\n    }\n    ListNode* slow = head;\n    while (fast-&gt;next) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next;\n    }\n    // remove slow\n    slow-&gt;next = slow-&gt;next-&gt;next;\n    return head;\n}\nvoid printList(const ListNode *head) {\n    ListNode* node = head;\n    cout &lt;&lt; \"[\";\n    while (node) {\n        cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode five(5);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);\n    ListNode two(2, &amp;three);\n    ListNode one(1, &amp;two);\n    auto head = removeNthFromEnd(&amp;one, 2);\n    printList(head);\n    head = removeNthFromEnd(&amp;five, 1);\n    printList(head);\n    head = removeNthFromEnd(&amp;four, 1);\n    printList(head);\n}\n</code></pre> <pre><code>Output:\n[1,2,3,5,]\n[]\n[4,]\n</code></pre>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes in the list.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#conclusion","title":"Conclusion","text":"<p>Solution 2 uses two pointers, a fast pointer and a slow pointer, to remove the nth node from the end of a linked list. </p> <p>Initially, both pointers start from the head of the list. The fast pointer moves <code>n</code> steps ahead, effectively positioning itself <code>n</code> nodes ahead of the slow pointer. Then, while the fast pointer is not at the end of the list, both pointers move forward simultaneously. This ensures that the slow pointer stays <code>n</code> nodes behind the fast pointer, effectively reaching the node preceding the nth node from the end when the fast pointer reaches the end of the list. Finally, the nth node from the end is removed by updating the <code>next</code> pointer of the node preceding it. </p> <p>This approach optimizes the computation by traversing the linked list only once and using two pointers to efficiently locate the node to be removed.</p>"},{"location":"source/Two_Pointers/19_Remove_Nth_Node_From_End_of_List/#exercise","title":"Exercise","text":"<ul> <li>Swapping Nodes in a Linked List.</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/","title":"Shortest Unsorted Continuous Subarray","text":""},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#problem-statement","title":"Problem statement","text":"<p>Given an integer array <code>nums</code>, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.</p> <p>Return the shortest such subarray and output its length.</p>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\n</code></pre>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [1,2,3,4]\nOutput: 0\n</code></pre>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#example-3","title":"Example 3","text":"<pre><code>Input: nums = [1]\nOutput: 0\n</code></pre>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#constraints","title":"Constraints:","text":"<ul> <li><code>1 &lt;= nums.length &lt;= 10^4</code>.</li> <li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code>.</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#follow-up","title":"Follow up","text":"<ul> <li>Can you solve it in<code>O(n)</code> time complexity?</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#solution-1-sort-and-compare-the-difference","title":"Solution 1: Sort and compare the difference","text":""},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#example-1_1","title":"Example 1","text":"<p>Comparing <code>nums = [2,6,4,8,10,9,15]</code> with its sorted one <code>sortedNums = [2,4,6,8,9,10,15]</code>:</p> <ul> <li>The first position that makes the difference is <code>left = 1</code>, where <code>6 != 4</code>.</li> <li>The last (right) position that makes the difference is <code>right = 5</code>, where <code>9 != 10</code>.</li> <li>The length of that shortest subarray is <code>right - left + 1 = 5</code>.</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#code","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint findUnsortedSubarray(const vector&lt;int&gt;&amp; nums) {\n    vector&lt;int&gt; sortedNums = nums;\n    sort(sortedNums.begin(), sortedNums.end());\n    int left = 0;\n    while (left &lt; nums.size() &amp;&amp; nums[left] == sortedNums[left]) {\n        left++;\n    }\n    int right = nums.size() - 1;\n    while (right &gt;= 0 &amp;&amp; nums[right] == sortedNums[right]) {\n        right--;\n    }\n    return left &gt;= right ? 0 : right - left + 1;\n}\nint main() {\n    vector&lt;int&gt; nums{2,6,4,8,10,9,15};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n    nums = {1,2,3,4};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n    nums = {1};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n0\n0\n</code></pre> <p>This solution compares the original array with a sorted version of itself to identify the unsorted boundaries efficiently.</p>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N*logN)</code> due to the sorting step, where <code>N</code> is the number of elements in the <code>nums</code> vector.</li> <li>Extra space: <code>O(N)</code>.</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#solution-2-comparing-only-maximum-and-minimum-elements","title":"Solution 2: Comparing only maximum and minimum elements","text":"<p>Assume the subarray <code>A = [nums[0], ..., nums[i - 1]]</code> is sorted. What would be the wanted <code>right</code> position for the subarray <code>B = [nums[0], ..., nums[i - 1], nums[i]]</code>? </p> <p>If <code>nums[i]</code> is smaller than <code>max(A)</code>, the longer subarray <code>B</code> is not in ascending order. You might need to sort it, which means <code>right = i</code>.</p> <p>Similarly, assume the subarray <code>C = [nums[j + 1], ..., nums[n - 1]]</code> is sorted. What would be the wanted <code>left</code> position for the subarray <code>D = [nums[j], nums[j + 1], ..., nums[n - 1]]</code>?</p> <p>If <code>nums[j]</code> is bigger than <code>min(C)</code>, the longer subarray <code>D</code> is not in ascending order. You might need to sort it,  which means <code>left = j</code></p>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#code_1","title":"Code","text":"<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nint findUnsortedSubarray(const vector&lt;int&gt;&amp; nums) {\n    const int n = nums.size();\n    int right = 0;\n    int max = nums[0];\n    for (int i = 0; i &lt; nums.size(); i++) {\n        if (nums[i] &lt; max) {\n            right = i;\n        } else {\n            max = nums[i];\n        }\n    }\n    int left = n - 1;\n    int min = nums[n - 1];\n    for (int j = n - 1; j &gt;= 0; j--) {\n        if (nums[j] &gt; min) {\n            left = j;\n        } else {\n            min = nums[j];\n        }\n    }\n    return left &gt;= right ? 0 : right - left + 1;\n}\nint main() {\n    vector&lt;int&gt; nums{2,6,4,8,10,9,15};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n    nums = {1,2,3,4};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n    nums = {1};\n    cout &lt;&lt; findUnsortedSubarray(nums) &lt;&lt; endl;\n}\n</code></pre> <pre><code>Output:\n5\n0\n0\n</code></pre> <p>This solution determines the boundaries of the unsorted subarray by iterating through the array from both ends. It starts by initializing the <code>right</code> boundary to the beginning of the array and tracks the maximum element encountered so far. It iterates from the beginning of the array towards the end, updating the <code>right</code> boundary whenever an element smaller than the current maximum is encountered. This identifies the rightmost position where the array is unsorted.</p> <p>Similarly, it initializes the <code>left</code> boundary to the end of the array and tracking the minimum element encountered so far. It iterates from the end of the array towards the beginning, updating the <code>left</code> boundary whenever an element greater than the current minimum is encountered. This identifies the leftmost position where the array is unsorted.</p> <p>Finally, it returns the length of the unsorted subarray, calculated as <code>right - left + 1</code>, unless the left boundary is greater than or equal to the right boundary, in which case the array is already sorted, and it returns 0.</p> <p>This approach optimizes the computation by traversing the array only twice, once from the end and once from the beginning, to efficiently determine the boundaries of the unsorted subarray.</p>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of elements in the <code>nums</code> vector.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/581_Shortest_Unsorted_Continuous_Subarray/#key-takeaway","title":"Key Takeaway","text":"<p>Solution 2 helped you identify the shortest subarray (by the <code>left</code> and <code>right</code> indices) needed to be sorted in order to sort the whole array.</p> <p>That means in some cases you can sort an array with complexity <code>O(N + m*logm) &lt; O(N*logN)</code> where <code>N</code> is the length of the whole array and <code>m</code> is the length of the shortest subarray.</p>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/","title":"Middle of the Linked List","text":""},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#problem-statement","title":"Problem statement","text":"<p>Given the <code>head</code> of a singly linked list, return the middle node of the linked list.</p> <p>If there are two middle nodes, return the second middle node.</p>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#example-1","title":"Example 1","text":"<pre><code>Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.\n</code></pre>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#example-2","title":"Example 2","text":"<pre><code>Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n</code></pre>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#constraints","title":"Constraints","text":"<ul> <li>The number of nodes in the list is in the range <code>[1, 100]</code>.</li> <li><code>1 &lt;= Node.val &lt;= 100</code>.</li> </ul>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#solution-1-counting-the-number-of-nodes","title":"Solution 1: Counting the number of nodes","text":""},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#code","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* middleNode(ListNode* head) {\n    ListNode *node = head;\n    int count = 0;\n    while (node) {\n        count++;\n        node = node-&gt;next;\n    }\n    int i = 1;\n    node = head;\n    while (i &lt;= count/2) {\n        node = node-&gt;next;\n        i++;\n    }\n    return node;        \n}\nvoid print(const ListNode *head) {\n    ListNode *node = head; \n    std::cout &lt;&lt; \"[\";\n    while (node) {\n        std::cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode five(5);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);    \n    ListNode two(2, &amp;three);\n    ListNode one(1, &amp;two);\n    auto result = middleNode(&amp;one);\n    print(result);\n\n    ListNode six(6);\n    five.next = &amp;six;\n    result = middleNode(&amp;one);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n[3,4,5,]\n[4,5,6,]\n</code></pre> <p>This solution first counts the total number of nodes in the linked list, and then it iterates to the middle node using the <code>count</code> variable. </p>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes in the linked list.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#solution-2-indexfast-and-slow-pointers","title":"Solution 2: {index}<code>Fast and Slow</code> pointers","text":"<p>Use two pointers to go through the linked list. </p> <p>One goes one step at a time. The other goes two steps at a time. When the faster reaches the end, the slower reaches the middle.</p>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#code_1","title":"Code","text":"<pre><code>#include &lt;iostream&gt;\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\nListNode* middleNode(ListNode* head) {\n    ListNode *slow = head;\n    ListNode *fast = head;\n    while (fast &amp;&amp; fast-&gt;next) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next-&gt;next;\n    }\n    return slow;        \n}\nvoid print(const ListNode *head) {\n    ListNode *node = head; \n    std::cout &lt;&lt; \"[\";\n    while (node) {\n        std::cout &lt;&lt; node-&gt;val &lt;&lt; \",\";\n        node = node-&gt;next;\n    }\n    std::cout &lt;&lt; \"]\\n\";\n}\nint main() {\n    ListNode five(5);\n    ListNode four(4, &amp;five);\n    ListNode three(3, &amp;four);    \n    ListNode two(2, &amp;three);\n    ListNode one(1, &amp;two);\n    auto result = middleNode(&amp;one);\n    print(result);\n\n    ListNode six(6);\n    five.next = &amp;six;\n    result = middleNode(&amp;one);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n[3,4,5,]\n[4,5,6,]\n</code></pre> <p>This solution uses two pointers, a slow pointer and a fast pointer, to find the middle node of a linked list. Both pointers start from the head of the list, and in each iteration, the slow pointer moves one step forward while the fast pointer moves two steps forward. This ensures that the slow pointer reaches the middle node of the list when the fast pointer reaches the end. </p> <p>By advancing the pointers at different speeds, the algorithm identifies the middle node of the linked list. If the list has an odd number of nodes, the slow pointer will be positioned at the middle node. If the list has an even number of nodes, the slow pointer will be positioned at the node closer to the middle of the list. </p> <p>Finally, the algorithm returns the slow pointer, which points to the middle node of the linked list. </p> <p>This approach optimizes the computation by traversing the linked list only once and using two pointers to efficiently locate the middle node.</p>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N</code> is the number of nodes in the linked list.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#obs","title":"OBS!","text":"<ul> <li>The approach using slow and fast pointers looks very nice and faster. But it is not suitable to generalize this problem to any relative position (one-third, a quarter, etc.). Moreover, long expressions like <code>fast-&gt;next-&gt;...-&gt;next</code> are not recommended. </li> <li>Though the counting nodes approach does not seem optimized, it is more readable, scalable and maintainable.</li> </ul>"},{"location":"source/Two_Pointers/876_Middle_of_the_Linked_List/#exercise","title":"Exercise","text":"<ul> <li>Delete the Middle Node of a Linked List.</li> </ul>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/","title":"Sort Array By Parity II","text":""},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#problem-statement","title":"Problem statement","text":"<p>Given an array of integers <code>nums</code>, half of the integers in <code>nums</code> are odd, and the other half are even.</p> <p>Sort the array so that whenever <code>nums[i]</code> is odd, <code>i</code> is odd, and whenever <code>nums[i]</code> is even, <code>i</code> is even.</p> <p>Return any answer array that satisfies this condition. </p>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#example-1","title":"Example 1","text":"<pre><code>Input: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n</code></pre>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#example-2","title":"Example 2","text":"<pre><code>Input: nums = [2,3]\nOutput: [2,3]\n</code></pre>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#constraints","title":"Constraints:","text":"<ul> <li><code>2 &lt;= nums.length &lt;= 2 * 10^4</code>.</li> <li><code>nums.length</code> is even.</li> <li>Half of the integers in <code>nums</code> are even.</li> <li><code>0 &lt;= nums[i] &lt;= 1000</code>.</li> </ul>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#solution-1-bubble-sort","title":"Solution 1: Bubble Sort","text":"<p>For each <code>0 &lt;= i &lt; nums.length</code>, if <code>nums[i]</code> has the same parity with <code>i</code>, you do nothing. Otherwise you need to find another <code>nums[j]</code> that has the same parity with <code>i</code> to swap with <code>nums[i]</code>.</p>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#example-1_1","title":"Example 1","text":"<p>For <code>nums = [4,2,5,7]</code>:</p> <ul> <li><code>nums[0] = 4</code> is even like <code>i = 0</code>.</li> <li><code>nums[1] = 2</code> is even, unlike <code>i = 1</code> is odd. Found <code>nums[2] = 5</code> is odd. Swap <code>nums[1] &lt;-&gt; nums[2]</code>. <code>nums[2]</code> becomes <code>2</code> while <code>nums[1]</code> becomes <code>5</code> is odd like <code>i = 1</code>.</li> <li><code>nums[2] = 2</code> is even, like <code>i = 2</code>.</li> <li><code>nums[3] = 7</code> is odd like <code>i = 3</code>.</li> </ul>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#code","title":"Code","text":"<pre><code>#include&lt;vector&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nvector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) {\n    for (int i = 0; i &lt; nums.size(); i++) {\n        if (i % 2 != nums[i] % 2) {\n            // find suitable nums[j] to swap\n            for (int j = i + 1; j &lt; nums.size(); j++) {\n                if (nums[j] % 2 == i % 2) {\n                    swap(nums[i], nums[j]);\n                    break;\n                }\n            }\n        }\n    }\n    return nums;\n}\nvoid print(vector&lt;int&gt;&amp; nums) {\n    for (auto num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums = {4,2,5,7};\n    auto result = sortArrayByParityII(nums);\n    print(result);\n    nums = {1,0,7,3,8,9,2,5,4,1,2,4};\n    result = sortArrayByParityII(nums);\n    print(result);\n    nums = {3,4};\n    result = sortArrayByParityII(nums);\n    print(result);\n    nums = {648,831,560,986,192,424,997,829,897,843};\n    result = sortArrayByParityII(nums);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n4 5 2 7 \n0 1 8 3 2 9 4 5 2 1 4 7\n4 3\n648 831 560 997 192 829 986 897 424 843\n</code></pre> <p>This solution iteratively scans through the array and swap elements to ensure that the parity (even or odd) of each element matches its index modulo 2. </p> <p>The algorithm iterates over each index of the array. For each index <code>i</code>, if the parity of the element at index <code>i</code> does not match <code>i % 2</code>, it implies that the element is in the wrong position. In such cases, the algorithm searches for the next element with the correct parity (i.e., even or odd) starting from index <code>i + 1</code>. Once found, it swaps the elements at indices <code>i</code> and <code>j</code>, where <code>j</code> is the index of the next element with the correct parity. </p> <p>By performing these swaps, the algorithm ensures that each element is at the correct position based on its parity. </p> <p>This approach optimizes the sorting process by performing a single pass through the array and minimizing the number of swaps required to achieve the desired parity arrangement.</p>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#complexity","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N^2)</code>, where <code>N = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#solution-2-two-pointers-make-use-of-the-problems-constraints","title":"Solution 2: Two pointers - Make use of the problem\u2019s constraints","text":"<p>In the Bubble Sort approach, you do not make use of the constraint that half of the integers in <code>nums</code> are even. Because of that, these are unnecessary things:</p> <ol> <li>The loops scan through full <code>nums</code>.</li> <li>The loops are nested. That increases the complexity.</li> <li>The <code>swap(nums[i], nums[j])</code> happens even when <code>nums[j]</code> was already in place, i.e. <code>nums[j]</code> had the same parity with <code>j</code> (Why to move it?).</li> </ol> <p>Here is a two-pointer approach which takes the important constraint into account.</p>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#code_1","title":"Code","text":"<pre><code>#include&lt;vector&gt;\n#include&lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\nvector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; nums) {\n    int N = nums.size();\n    int evenPos = 0;\n    int oddPos = N - 1;\n    while (evenPos &lt; N) {\n        // find the nums[evenPos] that is odd for swapping\n        while (evenPos &lt; N &amp;&amp; nums[evenPos] % 2 == 0) {\n            evenPos += 2;\n        }\n        // If not found, it means all even nums are in place. Done! \n        if (evenPos &gt;= N) {\n            break;\n        }\n        // Otherwise, the problem's constraint makes sure \n        // there must be some nums[oddPos] that is even for swapping\n        while (oddPos &gt;= 0 &amp;&amp; nums[oddPos] % 2 == 1) {\n            oddPos -= 2;\n        } \n        swap(nums[evenPos], nums[oddPos]);\n    }\n    return nums;\n}\nvoid print(vector&lt;int&gt;&amp; nums) {\n    for (auto num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n}\nint main() {\n    vector&lt;int&gt; nums = {4,2,5,7};\n    auto result = sortArrayByParityII(nums);\n    print(result);\n    nums = {1,0,7,3,8,9,2,5,4,1,2,4};\n    result = sortArrayByParityII(nums);\n    print(result);\n    nums = {3,4};\n    result = sortArrayByParityII(nums);\n    print(result);\n    nums = {648,831,560,986,192,424,997,829,897,843};\n    result = sortArrayByParityII(nums);\n    print(result);\n}\n</code></pre> <pre><code>Output:\n4 5 2 7 \n0 1 8 3 2 9 4 5 2 1 4 7\n4 3\n648 831 560 997 192 829 986 897 424 843\n</code></pre>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#complexity_1","title":"Complexity","text":"<ul> <li>Runtime: <code>O(N)</code>, where <code>N = nums.length</code>.</li> <li>Extra space: <code>O(1)</code>.</li> </ul>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#conclusion","title":"Conclusion","text":"<p>Solution 2 uses two pointers, one starting from the beginning of the array (<code>evenPos</code>) and the other starting from the end (<code>oddPos</code>), to efficiently identify misplaced elements. </p> <p>By incrementing <code>evenPos</code> by 2 until an odd element is found and decrementing <code>oddPos</code> by 2 until an even element is found, the algorithm can swap these elements to ensure that even-indexed elements contain even values and odd-indexed elements contain odd values. This process iterates until all even and odd elements are correctly positioned.</p>"},{"location":"source/Two_Pointers/922_Sort_Array_By_Parity_II/#exercise","title":"Exercise","text":"<ul> <li>Rearrange Array Elements by Sign.</li> </ul>"}]}