
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.34">
    
    
      
        <title>Largest Divisible Subset - LeetSolve</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.35f28582.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#largest-divisible-subset" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="LeetSolve" class="md-header__button md-logo" aria-label="LeetSolve" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LeetSolve
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Largest Divisible Subset
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="LeetSolve" class="md-nav__button md-logo" aria-label="LeetSolve" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    LeetSolve
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../index.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Arrays
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Arrays
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Arrays/2_Add_Two_Numbers.md" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    None
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Strings
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Strings
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Strings/3_Longest_Substring_Without_Repeating_Characters/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3 Longest Substring Without Repeating Characters
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#problem-statement" class="md-nav__link">
    <span class="md-ellipsis">
      Problem statement
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Problem statement">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-1" class="md-nav__link">
    <span class="md-ellipsis">
      Example 1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#example-2" class="md-nav__link">
    <span class="md-ellipsis">
      Example 2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constraints" class="md-nav__link">
    <span class="md-ellipsis">
      Constraints
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solution-1-bruteforce-with-dynamic-programming" class="md-nav__link">
    <span class="md-ellipsis">
      Solution 1: Bruteforce with Dynamic programming
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Solution 1: Bruteforce with Dynamic programming">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-3" class="md-nav__link">
    <span class="md-ellipsis">
      Example 3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#code" class="md-nav__link">
    <span class="md-ellipsis">
      Code
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complexity" class="md-nav__link">
    <span class="md-ellipsis">
      Complexity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#solution-2-store-only-the-representative-of-the-maxsubset" class="md-nav__link">
    <span class="md-ellipsis">
      Solution 2: Store only the representative of the maxSubset
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Solution 2: Store only the representative of the maxSubset">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#example-3_1" class="md-nav__link">
    <span class="md-ellipsis">
      Example 3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#code_1" class="md-nav__link">
    <span class="md-ellipsis">
      Code
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complexity_1" class="md-nav__link">
    <span class="md-ellipsis">
      Complexity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#key-takeaway" class="md-nav__link">
    <span class="md-ellipsis">
      Key takeaway
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="largest-divisible-subset">Largest Divisible Subset</h1>
<h2 id="problem-statement"><a href="https://leetcode.com/problems/largest-divisible-subset/">Problem statement</a></h2>
<p>You have a collection of positive integers called <code>nums</code>, where each integer is distinct. Your task is to find the largest subset <code>answer</code> from this collection, such that for every pair of elements <code>(answer[i], answer[j])</code> within this subset:</p>
<ul>
<li>Either <code>answer[i]</code> is a multiple of <code>answer[j]</code> (i.e., <code>answer[i] % answer[j] == 0</code>), or</li>
<li><code>answer[j]</code> is a multiple of <code>answer[i]</code> (i.e., <code>answer[j] % answer[i] == 0</code>).</li>
</ul>
<p>If there are multiple possible solutions, you can return any of them.</p>
<h3 id="example-1">Example 1</h3>
<pre><code class="language-text">Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
</code></pre>
<h3 id="example-2">Example 2</h3>
<pre><code class="language-text">Input: nums = [1,2,4,8]
Output: [1,2,4,8]
</code></pre>
<h3 id="constraints">Constraints</h3>
<ul>
<li><code>1 &lt;= nums.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= nums[i] &lt;= 2 * 10^9</code>.</li>
<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>
</ul>
<h2 id="solution-1-bruteforce-with-dynamic-programming">Solution 1: Bruteforce with Dynamic programming</h2>
<p>Note that the condition <code>a % b == 0</code> is called <em><code>a</code> is divisible by <code>b</code></em>. In mathematics, it can also be called <em><code>b</code> divides <code>a</code></em> and be written as <code>b | a</code>.</p>
<p>The symmetry of the divisibility criteria means it does not count the ordering of the <code>answer</code>. You could sort the vector <code>nums</code> before trying to find the longest subset <code>answer = [answer[0], answer[1], ..., answer[m]]</code> where <code>answer[i] | answer[j]</code> with all <code>0 &lt;= i &lt;= j &lt;= m</code>.</p>
<p>Now assuming the <code>nums</code> were sorted. For each <code>i</code>, you need to find the largest subset <code>maxSubset[i]</code> starting from <code>nums[i]</code>. And the final answer is the largest one among them. </p>
<h3 id="example-3">Example 3</h3>
<pre><code class="language-text">Input: nums = [2, 4, 3, 9, 8].
Sorted nums = [2, 3, 4, 8, 9]. 
maxSubset[0] = [2, 4, 8].
maxSubset[1] = [3, 9].
maxSubset[2] = [4, 8].
maxSubset[3] = [8].
maxSubset[4] = [9].
Output: [2, 4, 8].
</code></pre>
<p>Note that for a sorted <code>nums</code>, if <code>nums[i] | nums[j]</code> for some <code>i &lt; j</code>, then <code>maxSubset[j]</code> is a subset of <code>maxSubset[i]</code>. </p>
<p>For example, <code>maxSubset[2]</code> is a subset of <code>maxSubset[0]</code> in Example 3 because <code>nums[0] = 2 | 4 = nums[2]</code>.</p>
<p>That might lead to some unnecessary recomputing. To avoid it, you could use <em>dynamic programming</em> to store the <code>maxSubset[j]</code> you have already computed.</p>
<h3 id="code">Code</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;algorithm&gt;
using namespace std;

//! @return the max divisible subset starting from nums[i] 
//!         and store it to _map[i]
//! @param nums a sorted array of unique positive integers 
vector&lt;int&gt; largestDivisibleSubsetOf(vector&lt;int&gt;&amp; nums, 
            int i, unordered_map&lt;int, vector&lt;int&gt; &gt;&amp; _map) {
    if (_map.find(i) != _map.end()) {
        // already computed!
        return _map[i];
    }
    vector&lt;int&gt; maxSubset{nums[i]}; // start with nums[i]
    if (i == nums.size() - 1) {
        // largest value in nums
        _map.insert({i, maxSubset});
        return maxSubset;
    }
    for (int j = i + 1; j &lt; nums.size(); j++) {
        if (nums[j] % nums[i] == 0) {
            // compute the max divisble subset starting from nums[j]
            auto subset = largestDivisibleSubsetOf(nums, j, _map);

            // add nums[i] to subset as it might become maxSubset
            subset.push_back(nums[i]);
            if (maxSubset.size() &lt; subset.size()) {
                // update maxSubset
                maxSubset = subset;
            }
        }
    }
    // store what have been calculated in _map
    _map.insert({i, maxSubset});
    return maxSubset;
}
vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {
    if (nums.size() &lt;= 1) {
        return nums; 
    } 
    unordered_map&lt;int, vector&lt;int&gt; &gt; _map;
    sort(nums.begin(), nums.end());
    vector&lt;int&gt; answer;
    for (int i = 0; i &lt; nums.size(); i++) {
        auto maxSubset = largestDivisibleSubsetOf(nums, i, _map);
        if (answer.size() &lt; maxSubset.size()) {
            // update the maximal subset
            answer = maxSubset;
        }
    }
    return answer;        
}
void printSolution(const vector&lt;int&gt;&amp; result) {
    cout &lt;&lt; &quot;[&quot;;
    for (auto&amp; v : result) {
        cout &lt;&lt; v &lt;&lt; &quot;,&quot;;
    }
    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;
}
int main() {
    vector&lt;int&gt; nums{2,1,3};
    auto answer = largestDivisibleSubset(nums);
    printSolution(answer);
    nums = {1,2,4,8};
    answer = largestDivisibleSubset(nums);
    printSolution(answer);
}
</code></pre>
<pre><code class="language-text">Output:
[2,1,]
[8,4,2,1,]
</code></pre>
<p>This solution uses dynamic programming with {index}<code>memoization</code> to find the largest divisible subset of a given set of numbers. </p>
<p>The <code>largestDivisibleSubsetOf</code> function recursively computes the largest divisible subset starting from a particular index <code>i</code> in the sorted array <code>nums</code>. It memoizes the computed subsets in an unordered map <code>_map</code> to avoid redundant computations. By iteratively calling <code>largestDivisibleSubsetOf</code> for each index <code>i</code> in the sorted array and updating the <code>answer</code> with the largest subset found so far, the <code>largestDivisibleSubset</code> function computes the largest divisible subset of the input array <code>nums</code>. </p>
<p>This approach optimizes the computation by avoiding repeated calculations and leveraging dynamic programming techniques to efficiently explore the solution space.</p>
<h3 id="complexity">Complexity</h3>
<ul>
<li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of elements in the <code>nums</code> vector.</li>
<li>Extra space: <code>O(n^2)</code>.</li>
</ul>
<h2 id="solution-2-store-only-the-representative-of-the-maxsubset">Solution 2: Store only the representative of the <code>maxSubset</code></h2>
<p>In the brute-force solution above, you used a big <code>map</code> to log all <code>maxSubset[i]</code> though you need only the largest one at the end.</p>
<p>One way to save memory (and eventually improve performance) is just storing the representative of the chain relationship between the values <code>nums[i]</code> of the <code>maxSubset</code> through their indices mapping. </p>
<p>That means if <code>maxSubset[i] = [nums[i0] | nums[i1] | ... | nums[iN1]] | nums[iN]]</code>, you could log <code>pre[iN] = iN1</code>, ...,  <code>prev[i1] = i0</code>. </p>
<p>Then all you need to find is only the last index <code>iN</code> of the largest <code>maxSubset</code>. </p>
<h3 id="example-3_1">Example 3</h3>
<pre><code class="language-text">Input: nums = [2, 4, 3, 9, 8].
sorted nums = [2, 3, 4, 8, 9]. 
pre[0] = -1 (there is no nums[i] | nums[0]).
pre[1] = -1 (there is no nums[i] | nums[1]).
pre[2] = 0 (nums[0] is the only divisor of nums[2]).
pre[3] = 2 (for the largest subset though nums[0] and nums[2] are both divisors of nums[3]). 
pre[4] = 1 (nums[1] is the only divisor of nums[4]).
iN = 3 ([2 | 4 | 8] is the largest maxSubset).
Output: [8, 4, 2].
</code></pre>
<h3 id="code_1">Code</h3>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {
    if (nums.size() &lt;= 1) {
        return nums; 
    }
    sort(nums.begin(), nums.end());
    // the size of the resulting subset
    int maxSize = 0;    

    // nums[maxindex] is the largest value of the resulting subset
    int maxindex = 0;   

    // subsetSize[i] stores the size of the largest subset
    // having the biggest number nums[i]
    vector&lt;int&gt; subsetSize(nums.size(), 1); 

    // pre[i] stores the previous index of i in their largest subset
    vector&lt;int&gt; pre(nums.size(), -1);       
    for (int i = 0; i &lt; nums.size(); i++) {
        // find the previous nums[j] that make subsetSize[i] largest
        for (int j = i - 1; j &gt;= 0; j--) {

            if (nums[i] % nums[j] == 0 &amp;&amp; 
                subsetSize[j] + 1 &gt; subsetSize[i]) 
            {
                subsetSize[i] = subsetSize[j] + 1;
                pre[i] = j;
            }
        }
        // update the largest subset
        if (maxSize &lt; subsetSize[i]) {
            maxSize = subsetSize[i];
            maxindex = i;
        }
    }
    vector&lt;int&gt; result;
    while (maxindex != -1) {
        result.push_back(nums[maxindex]);
        maxindex = pre[maxindex];
    }
    return result;        
}
void printSolution(const vector&lt;int&gt;&amp; result) {
    cout &lt;&lt; &quot;[&quot;;
    for (auto&amp; v : result) {
        cout &lt;&lt; v &lt;&lt; &quot;,&quot;;
    }
    cout &lt;&lt; &quot;]&quot; &lt;&lt; endl;
}
int main() {
    vector&lt;int&gt; nums{2,1,3};
    auto result = largestDivisibleSubset(nums);
    printSolution(result);
    nums = {1,2,4,8};
    result = largestDivisibleSubset(nums);
    printSolution(result);
}
</code></pre>
<pre><code class="language-text">Output:
[2,1,]
[8,4,2,1,]
</code></pre>
<p>This solution finds the largest divisible subset of a given set of numbers by dynamically updating the size of the subsets and maintaining the previous index of each element in their largest subset. </p>
<p>It iterates through the sorted array of numbers, updating the size of the largest subset that ends with each element by considering the previous elements that are factors of the current element. By keeping track of the maximum subset size and the index of the largest element in the subset, it constructs the largest divisible subset. </p>
<p>This approach optimizes the computation by avoiding redundant calculations and leveraging dynamic programming techniques to efficiently explore the solution space.</p>
<h3 id="complexity_1">Complexity</h3>
<ul>
<li>Runtime: <code>O(n^2)</code>, where <code>n</code> is the number of elements in the <code>nums</code> vector. The nested loop searches for previous elements with divisibility relationships, which may lead to quadratic time complexity in the worst case. However, it maintains information about subset sizes and elements, reducing redundant calculations and improving performance.</li>
<li>Extra space: <code>O(n)</code>.</li>
</ul>
<h2 id="key-takeaway">Key takeaway</h2>
<p>In this interesting problem, the index mapping is used to simplify everything. That improves the performance in both runtime and memory.</p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "search": "../../../assets/javascripts/workers/search.07f07601.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.56dfad97.min.js"></script>
      
    
  </body>
</html>